---
title: 좋은 코드, 고품질 코드란?
date: "2023-09-01"
tags:
   - oop
---

# 들어가기전에

> "소스 코드를 읽으면서 종종 그것이 어떤 의미인지 이해하지 못하는 경우가 있다. 사실 이런 문제의 원인은 매우 간단하다."  
> "코드를 완벽하게 이해하기 위해 **필요한 기본적인 기술적 소양과 능력이 부족하기 때문이다.**"  
> 디자인 패턴의 아름다움 1장
  
작성되어 있는 코드를 분석하다보면 나에게 생소한 디자인 패턴이 적용되어 있거나, 연속된 추상화 등등 이해가 힘들 때 `"내가 이런 복잡한 비즈니스를 많이 접해보지 못하고 기술적인 소양이 낮아서 그런건가?"`라는 생각을 한적이 있다.  
**좋은 코드를 보고 그 원리를 분석하여 내 것으로 만들고 싶어도 기술의 이해가 없다면 본질을 이해하지 못해 작성자의 의도를 파악할 수 없을 것이다.**  
  
하지만 내가 좋은 코드를 보고 좋은 코드라고 판단할 수 있을까?  
좋은 코드를 판단하지 못하고, 좋은 코드를 작성하지 못하는 이유는 **어떤 코드가 고품질의 코드인지 알지 못하기 때문이다.**  
아래와 같은 질문을 어느정도로 생각하나?  
  
1. 계층화와 하위 모듈화 방법은 무엇인가?
2. 클래스를 어떻게 나누는 것이 좋은가?
3. 각 클래스에는 어떤 책임과 역할이 있는가?
4. 클래스 간의 상호 작용을 설계하는 방법, 메시지는 무엇인가?
5. 상속을 사용하는 것이 옳은가?
6. 인터페이스나 추상 클래스를 사용하는 것이 옳은가?
7. 상속과 합성 중 뭐가 옳은가?
8. 결합도가 높은 코드와 낮은 코드는 무엇인가?
9. 디커플링을 달성하는 방법은 무엇인가?
10. 싱글턴 패턴이나 정적 메서드를 사용하는 것이 옳은가?
11. 객체를 생성할 때 팩터리 패턴을 사용하는 것이 옳은가?
12. 가독성을 유지하면서 확장성을 향상하기 위해 디자인 패턴을 도입하는 방법은 무엇인가?
13. 어떤 종류의 코드가 확장과 유지관리에 용이한가?
  
> "컴퓨터가 이해할 수 있는 코드는 바보라도 작성할 수 있다. 훌륭한 프로그래머는 사람이 이해할 수 있는 코드를 작성한다." - 마틴 파울러

위에서 말하는 좋은 코드, 고품질 코드를 작성하기 위한 방법들에 대해 알아보자.  
대부분의 내용은 아래의 책과 영상, 글을 참고하였다.  
- [모던 자바 인 액션](https://www.yes24.com/Product/Goods/77125987)
- [디자인 패턴의 아름다움](https://product.kyobobook.co.kr/detail/S000202093794)
- [`KSUG` 대규모 엔터프라이즈 시스템 개선 경험기 - 1부 -](https://www.youtube.com/watch?v=UwAoUshVpgM&ab_channel=SpringCampbyKSUG)
- [`KSUG` 대규모 엔터프라이즈 시스템 개선 경험기 - 2부 -](https://www.youtube.com/watch?v=u_y6UGzOPUk&ab_channel=SpringCampbyKSUG)
- [Why were default methods introduced to Java?](https://softwareengineering.stackexchange.com/questions/418912/why-were-default-methods-introduced-to-java)

# **객체지향 프로그래밍**

> 객체지향 프로그래밍의 프로그래밍 단위는 **클래스**또는 **객체**이고,  
> 절차지향 프로그래밍의 프로그래밍 단위는 **함수**이며,  
> 함수형 프로그래밍의 프로그래밍 단위는 **스테이트리스 함수**이다.
  
객체지향 프로그래밍은 `클래스의 관점`에서 생각해야 한다.  
처음부터 복잡한 프로세스를 메서드로 분해하는 대신 **어떻게 비즈니스 모델링을 할지 먼저 생각한 후 요구 사항을 클래스로 구성하고 클래스 간의 상호 작용을 설정**한다.  
객체지향 프로그래밍을 이해하기 위해서는 **캡슐화**, **추상화**, **상속**, **다형성**을 이해해야 한다.  
  
<h3>캡슐화</h3>

정보 은닉 또는 데이터 접근 보호라고도 하는데, **접근 가능한 인터페이스를 제한하여 클래스가 제공하는 메서드를 통해서만 내부 정보나 데이터에 대한 외부 접근을 허가하는 것을 뜻 한다.**  
객체 생성 시 값이 결정되며 불변 속성을 지키거나 어쩔 수 없이 속성을 수정해야 한다면 비즈니스 세부 정보를 지킬 수 있다.  
Getter,Setter를 남용하는 행위가 대표적인 안좋은 예다.  
  
클래스의 속성에 대한 접근을 제한하지 않으면 모든 코드가 클래스의 속성에 접근하고 값을 변경할 수 있게 된다.  
얼핏 이것이 더 유연하게 느껴지지만, **과도한 유연성은 제어할 수 없음을 의미하고 수정 로직이 코드의 모든 곳에 흩어져 가독성과 유지 관리 용이성에 문제를 끼친다.**  
그리고 클래스는 필요한 작업만 노출하는 제한된 메서드를 제공하여 클래스의 사용성을 향상 시킬 수 있다.  
  
<h3>추상화</h3>  

**메서드의 내부 구현을 숨기는 것을 의미한다.** `함수` 그 자체가 구현을 숨기는 추상화에 해당한다.  
따라서 클래스를 사용할 때 기능의 구현 방식에 대해 고민하지 않고, **메서드가 제공하는 기능에만 집중할 수 있다.**  
함수라는 문법을 통해 구현되기 때문에 **실제로 코드의 구현 내용은 그 자체로 추상화되는 함수의 내부에 포함된다.**  
**규칙과 구현의 분리**를 준수하여 코드의 결합 정도를 줄이고 코드의 확장성을 향상 시킬 수 있다.  
  
> 객체 지향과 도메인 주도 설계는 소프트웨어 설계에 **일관성과 맥락**을 부여한다.  
> **일관성과 맥락**은 추상화의 기본 재료이며, 추상화로부터 얻은 **모델**은 주요 관심사이다.  
> 모델은 소프트웨어에 **단순함**을 부여한다.
  
<h3>상속</h3>  

`고양이는 포유류의 일종이다.`처럼 클래스 사이의 `is-a`관계를 나타내는 데 사용된다.  
상속은 이해하기도 쉬우며 동일한 코드의 중복을 막아낼 수 있다.  
하지만 과도하게 사용할 경우, 상속 계층 구조가 너무 깊고 복잡하면 코드의 가독성과 유지 관리성이 급격하게 떨어지므로 유의해야 한다.  
  
<h3>다형성</h3>

여러가지 형태를 갖는 성질을 말하며 `수정에 대해 폐쇄적이고 확장에 대해 개방적`이라는 설계 원칙을 준수할 수 있다.  
**동일한 논리(같은 타입)를 재사용할 수 있어 코드의 재사용성을 향상 시킬 수 있다.**  
`동적 디스패치`를 통한 런타임 시점에 결정되는 행위를 다형성이라고 생각한다.  
  
다형성의 특성을 구현하기 위해
1. 상속과 메서드 재정의를 하는 방식
2. 인터페이스를 사용하여 합성하는 방식

Collection Framework의 `Iterable`을 통해 인터페이스를 사용하여 합성하는 방식을 확인해보자.  

![](./iterableDiagram.png)

```java
public static void main(String[] args) {
    List<String> list = new ArrayList<>();
    Set<String> set = new HashSet<>();

    System.out.println(list);
    System.out.println(set);
}
```

이렇게 Collection 하위 타입을 출력하게 되면 아래 코드의 구현체에 구현되어 있는 `Iterable`을 반환받아 출력받게 된다.  

```java
public abstract class AbstractCollection<E> implements Collection<E> {
    public String toString() {
        Iterator<E> it = iterator();
        // ...
    }
}

public class ArrayList<E> extends AbstractList<E>
        implements List<E>, RandomAccess, Cloneable, java.io.Serializable
{
    public Iterator<E> iterator() {
        return new Itr();
    }
    // ...
}

public class HashSet<E> extends AbstractSet<E>
    implements Set<E>, Cloneable, java.io.Serializable
{
    public Iterator<E> iterator() {
        return map.keySet().iterator();
    }
    // ...
}
```

# **추상 클래스와 인터페이스, 상속과 합성**

개발하면서 추상화를 고민할 때 추상 클래스를 쓸지, 인터페이스를 쓸지 잠깐 고민하게 된다.  
하지만 항상 인터페이스를 쓰게 되는데 그 이유는 
1. 인터페이스도 구현 메서드를 가질 수 있다.
2. 다중 상속이 안되니 정말 강한 관계라고 의도를 표현해야 할 상황인지 판단하지 못 하는 경우가 많다.
3. 상태가 필요한 경우에는 상수 모듈로 관리하거나 외부에서 전략을 주입받을 수 있다.
4. 추상 클래스는 부모 클래스를 같이 초기화해야 한다.
5. 상속 단계가 깊어지는 것이 부담스럽다.
  
항상 추상 클래스를 배제하였지만, '디자인 패턴의 아름다움'을 읽고 생각이 조금 바뀌게 되어 정리하려 한다. 
  
클래스 상속의 관점에서 **추상 클래스는 상향식 설계 방식**이며 `is-a` 관계를 나타낸다.  
**인터페이스는 반대로 하향식 설계 방식**이며 깊어지지 않고 넓어진다. 그리고 프로토콜 또는 규약의 집합으로 사용자에게 제공되는 **기능의 목록**이다.  
`has-a`(또는 `can-do`, `behave like`) 관계를 나타낸다.  
  
<h3>추상 클래스</h3>  

1. 인스턴스화할 수 없다.
2. 인스턴스 변수와 구현 메서드를 포함할 수 있다.
3. 하위 클래스는 추상 클래스의 모든 추상 메서드를 구현해야 한다.
4. **타입 계층 구조를 제공한다.**

![](./abstract.png)

추상 클래스를 사용하는 위의 다이어그램에서 만약 `노래 부를 수 있는` 타입을 추가해야한다면 어떻게 해야할까?  

![](./abstract2.png)

이와 같이 경우의 수는 2의 제곱으로 늘어나 복잡도가 기하급수적으로 높아진다.  
이 문제는 **인터페이스의 `합성`, `인터페이스`, `위임`을 사용하는게 적절하다.**  

![](./useInterface.png)

```kotlin
interface Flyable { fun fly() }
interface Tweetable { fun tweet() }

class FlyAbility : Flyable { override fun fly() = TODO("do fly") }
class TweetAbility : Tweetable { override fun tweet() = TODO("do tweet") }

class Pigeon() : Flyable, Tweetable {
    private val flyAbility = FlyAbility()       // 합성
    private val tweetAbility = TweetAbility()   // 합성

    override fun fly() = flyAbility.fly()       // 위임
    override fun tweet() = tweetAbility.tweet() // 위임
}

class Penguin() : Tweetable {
    private val tweetAbility = TweetAbility()   // 합성

    override fun tweet() = tweetAbility.tweet() // 위임
}
```

이론적으로는 `is-a`관계는 합성과 인터페이스의 `has-a`관계로 대체될 수 있고,  
다형성은 인터페이스를 사용하여 달성할 수 있으며,  
코드 재사용은 합성과 위임으로 대체할 수 있다.  
  
그럼 어떤 경우에 상속이 사용되면 좋을까? **타입 계층 구조가 필요할 때 이다.**  

```kotlin
interface Flyable { fun fly() }
interface Tweetable { fun tweet() }

abstract class Bird (val name: String) : Flyable, Tweetable

class Pigeon() : Bird("비둘기") {
    override fun fly() = TODO()
    override fun tweet() = TODO()
}

class Penguin() : Bird("펭귄") {
    override fun fly() = throw OperationNotSupportedException()
    override fun tweet() = TODO()
}
```

인터페이스로 행위를 일반화하고, 추상 클래스로 계층 구조를 나누었고, 구현 계층에서 행위를 구현하였다.  
계층 구조를 만들게 되면
1. 인지적인 카테고리를 제공한다.
2. 특정 계층의 타입에만 해당 기능을 제공할 수 있다.
  
`"저런 구조는 인터페이스로도 가능하지 않나?"`, `"추상 계층의 내부 속성만 각 구현 계층으로 내리면 인터페이스로도 가능하지 않나?"`  
맞는 말이다.  
  
인터페이스에서 기본 메서드와 속성을 정의할 수 있긴 하지만(재차 강조하지만) 인터페이스의 본래 속성은 **프로토콜 또는 규약의 집합으로, 사용자에게 제공되는 기능의 목록**이다.  
  
> [What's New in JDK 8](https://www.oracle.com/java/technologies/javase/8-whats-new.html)에서 인터페이스의 기본 메서드를 설명한다.  
> "Default methods enable new functionality to be added to the interfaces of libraries and ensure binary compatibility with code written for older versions of those interfaces."  
> **"기본 메서드를 사용하면 새 기능을 라이브러리 인터페이스에 추가할 수 있고 해당 인터페이스의 이전 버전용으로 작성된 코드와의 이진 호환성을 보장할 수 있습니다."** 라고 설명한다.  
  
"자 인터페이스에 기본 메서드로 구현 메서드를 작성할 수 있으니 적극 활용하세요."라는것이 아니라 기존에 인터페이스로 개발된 곳은 기본 메서드가 없으면 인터페이스에 새 메서드를 추가하고 이전 버전과의 호환성을 유지할 수 없기 때문이다.  
**인터페이스 정의는 구현 세부 정보를 노출하지 않고, 구체적인 수행 방법이 아닌, 어떤 작업을 수행하는지만 고려해야 하기 때문이다.**  
  
# **Getter와 Setter 남용**

객체지향 프로그래밍 언어를 사용하여 모든 코드를 클래스에 넣기만 하면 그것이 바로 객체지향 프로그래밍이라고 생각하지만 절차지향 프로그래밍 스타일로 작성한 경우가 대부분일 것이다.  
예를 들어, 많은 비즈니스 로직을 `Service` 계층에 몰아넣고 객체지향이다 라고 말하는 것과 같이 말이다.  
대부분의 백엔드 개발자들은 (표현 계층, 논리 계층, 데이터 계층) MVC 아키텍처에 익숙하여 **빈약한 도메인 모델**을 의식하지 못하며 개발한다.  
  
![](domainModel.png)
- [이미지 출처 `KSUG` 대규모 엔터프라이즈 시스템 개선 경험기 - 2부 -](https://www.youtube.com/watch?v=u_y6UGzOPUk&ab_channel=SpringCampbyKSUG)

> 💡 **풍부한 도메인 모델**  
> 1. Service 클래스는 저장소 계층과 통신하여 도메인 모델을 만들어낸다.
> 2. Service 클래스는 여러 도메인 모델의 비즈니스 논리를 결합한다.
> 3. Service 클래스는 기능과 무관한 타 시스템과의 상호 작용을 담당한다.
  
**풍부한 도메인 모델**은 데이터와 비즈니스 논리가 하나의 클래스에 포함되며 전형적인 객체지향 프로그래밍에 속한다.  
즉, `Service`에 비즈니스 로직을 작성하는 것이 아니라 각 `도메인 모델`에 책임을 부여하는 것이다.  
이에 기반한 **DDD** 개발방식은 **비즈니스 시스템을 분리하고, 비즈니스 모듈을 분할하고, 비즈니스 도메인 모델과 상호 작용을 정의하는 방법을 설계할 때 사용된다.**  
DDD를 잘 하기 위한 핵심은 비즈니스에 익숙하지 않으면 합리적인 도메인 설계를 얻을 수 없기 때문에 DDD의 개념을 공부하고 익히는 것이 아니라 **비즈니스에 친숙해지는 것이다.**  
  
그리고 많은 백엔드 개발자들은 `Setter`는 열심히 막으려 하지만 `Getter`는 합리화한다. (나도 그렇다.)  
도메인 모델의 속성이 객체일 때 클라이언트 코드가 참조한다면 신경써야할 것이 많다.  
예를 들어, `Getter`를 통해 컬렉션 내에있는 객체를 수정한다면? 수정할 수 없는 불변 컬렉션이였지만 가변 컬렉션으로 캐스팅하여 수정한다면?  
**객체 전파**, **방어적 복사**, **앨리어싱 에러**들도 고려해야 한다.  
  
시스템이 복잡할수록 코드 재사용성과 유지 관리 용이성에 대한 요구 사항은 점점 높아지기 때문에 초기 설계에 더 많은 시간과 에너지를 투자하여 **풍부한 도메인 모델에 기반한 DDD 개발 방식에 익숙해져야 할 것이다.**  

# **결론**

<h3>합성을 사용할지 상속을 사용할지?</h3>  

합성을 더 많이 사용하고 상속을 덜 사용하도록 권장하지만, 언제나 합성이 옳은것도 아니고 상속이 항상 쓸모없는 것도 아니다.  
클래스 간의 상속 구조가 안정적이어서 쉽게 변경되지 않고 상속 단계가 2단계 이하로 비교적 얕아 상속 관계가 복잡하지 않다면 과감하게 **상속**을 사용할 수 있다.  
또한, 콘크리트 클래스의 특정 함수를 재정의하려 할 때도 **상속**을 사용할 수 있다.
반대로 시스템이 불안정하고 상속 계층이 깊고 복잡하면 **합성**을 사용해야 한다.  
  
<h3>객체지향 프로그래밍? 풍부한 도메인 모델?</h3>  

항상 객체지향 프로그래밍이 옳지만은 않다.  
요구사항이 간단하고 전체적인 작업 흐름이 가지를 뻗어나가지 않고 고정된 형태를 띄는 경우에는 절차지향 프로그래밍이 적절할 수 있다.  
그리고 개발하는 시스템의 비즈니스가 비교적 단순할때는 굳이 복잡한 풍부한 도메인 모델을 설계하기 보다는 빈약한 도메인 모델이 더 적합하다.  
하지만 복잡한 시스템일때 많은 개발자들이 풍부한 도메인 모델을 쉽게 적용할 수 있진 않을 것이다.  
**풍부한 도메인 모델은 설계하기가 훨씬 까다롭고, 빈약한 도메인 모델을 기반으로 하는 전통적인 개발 방식은 수년 동안 사용되어 왔고 대부분의 개발자에게 단단하게 박혀 있기 때문에 쉽게 적용하기에는 힘들 것이다.**  
  
<h3>결국엔?</h3>  

기술이나 방법론에는 정답이 없다.  
내가 처해있는 상황을 철저하게 분석하고 어떤 방법이 더 옳은지 판단하여 최선의 방법을 선택해야 한다.  
그리고 이런 내용을 배웠다고 해서 팀내 컨벤션을 고려하지 않고 팀원들과 충분한 협의 없의  안될 것이다.  
  
![](repeat.png)
- [이미지 출처 `KSUG` 대규모 엔터프라이즈 시스템 개선 경험기 - 1부 -](https://www.youtube.com/watch?v=UwAoUshVpgM&ab_channel=SpringCampbyKSUG)

> "중복 코드를 추상화하여 끄집어내는 것은 **DRY(Don't Repeat Yourself)** 를 사용하는 좋은 출발점이지만, 그것이 전부는 아닙니다."  
> "여러분이 중복 코드를 피하려고 하는 것은 사실 각 **기능과 요구사항을 한 번만 구현** 하려고 노력하는 것입니다."  
> - Head First Object Oriented Analysis & Design

중복된 코드에 매몰되지 말고 API에 집중해서 API의 책임이 중복되지 않게 꾸준히 신경써야 하며, 고품질 코드에 대한 책임과 끈기를 가져야 할 것이다.  
그리고 스스로의 안목을 키우기 위해 꾸준한 학습은 필수이다.  

***

# 보완할 내용

- SOLID, KISS, YAGNI, DRY, LoD
- 인터페이스 분리 원칙을 위배한 케이스
  - 자바의 불변 컬렉션