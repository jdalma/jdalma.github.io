---
layout: default
title: 2021년12월
nav_order: 8
parent: 알고리즘
---
## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---


## **`[LeetCode] DP` [N-th Tribonacci Number](https://leetcode.com/problems/n-th-tribonacci-number/)**

```java
class Solution {
    public int tribonacci(int n) {
        int first = 0;
        int second = 1;
        int third = 1;
        if(n == 0) return 0;
        else if(n == 1 || n == 2) return 1;
        else{
            for(int i = 3 ; i < n ; i++){
                int result = first + second + third;
                first = second;
                second = third;
                third = result;
            }
        }
        return first + second + third;
    }
}
```

***

## **`[LeetCode] DP` [Unique Paths II](https://leetcode.com/problems/unique-paths-ii/)**

### BFS 시간초과

```java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        if(obstacleGrid.length == 1 && obstacleGrid[0].length == 1 && obstacleGrid[0][0] == 0) return 1;
        else if(obstacleGrid[0][0] == 1) return 0;
        return bfs(obstacleGrid);
    }

    public int bfs(int[][] map){
        int sizeX = map.length;
        int sizeY = map[0].length;
        int count = 0;
        int[] moveX = new int[] {0 , 1};
        int[] moveY = new int[] {1 , 0};
        Queue<int[]> queue = new LinkedList<int[]>();
        queue.offer(new int[] {0 , 0});
        while(!queue.isEmpty()){
            int[] now = queue.poll();
            int nowX = now[0];
            int nowY = now[1];
            for(int i = 0 ; i < 2 ; i++){
                int moveXpos = nowX + moveX[i];
                int moveYpos = nowY + moveY[i];
                if(moveXpos >= 0 && moveYpos >= 0 && moveXpos < sizeX && moveYpos < sizeY){
                    if(map[moveXpos][moveYpos] == 0){
                        if(moveXpos == sizeX - 1 && moveYpos == sizeY - 1) count++;
                        queue.offer(new int[] {moveXpos , moveYpos});
                    }
                }
            }
        }
        return count;
    }
}
```

### 📌 DP 통과

- `[0,0]`에서 **우측과 아래쪽으로만 이동할 수 있다.**
- 첫번째 행과 열을 0 또는 1로 채운다.(이동할 수 있는곳인지 판단)
- **그 후 `[1,1]` 부터 현재 위치의 `[row - 1][col] + [row][col - 1]`을 더해 나간다.** 
  - *미리 채워놓은 첫번째 행과 열을 재사용하는것이다.*


```java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        if(obstacleGrid[0][0] == 1) return 0;
        
        int row = obstacleGrid.length;
        int col = obstacleGrid[0].length;
        
        obstacleGrid[0][0] = 1;
        for(int i = 1 ; i < row ; i++){
            obstacleGrid[i][0] = (obstacleGrid[i][0] == 0 && obstacleGrid[i - 1][0] == 1) ? 1 : 0;
        }
        
        for(int i = 1 ; i < col ; i++){
            obstacleGrid[0][i] = (obstacleGrid[0][i] == 0 && obstacleGrid[0][i - 1] == 1) ? 1 : 0;
        }
        
        for(int i = 1 ; i < row ; i++){
            for(int j = 1 ; j < col ; j++){
                if(obstacleGrid[i][j] == 0){
                    obstacleGrid[i][j] = obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1];
                }
                else obstacleGrid[i][j] = 0;
            }
        }
        
        return obstacleGrid[row - 1][col - 1];
    }
}
```

***

## **`[LeetCode]` [Subsets](https://leetcode.com/problems/subsets/)**

### 📌 Solution

- 내가 기존에 해왔던 방식과 다르게 **조합의 리스트에서 마지막 1개씩을 삭제하며 반복문의 글로벌 변수(`k`)와 똑같을 때만 새로운 리스트를 반환하게 돼있다.**

```java
class Solution {
    List<List<Integer>> output = new ArrayList();
    int n, k;

    public void backtrack(int first, ArrayList<Integer> curr, int[] nums) {
        System.out.println("curr.size() : " + curr.size() + ", k : " + k);
        // if the combination is done
        if (curr.size() == k) {
            System.out.println("{" + first + "} return : " + curr);
            output.add(new ArrayList(curr));
            return;
        }
        for (int i = first; i < n; ++i) {
            // add i into the current combination
            curr.add(nums[i]);
            // use next integers to complete the combination
            backtrack(i + 1, curr, nums);
            // backtrack
            // System.out.print("{" + first + "}  before remove : " + curr);
            curr.remove(curr.size() - 1);
            // System.out.println("  after remove : " + curr);
        }
    }

    public List<List<Integer>> subsets(int[] nums) {
        n = nums.length;
        for (k = 0; k < n + 1; k++) {
            System.out.println("------------------- start [" + k + "]--------------");
            backtrack(0, new ArrayList<Integer>(), nums);
        }
        return output;
    }
}
```

```
Runtime: 0 ms, faster than 100.00% of Java online submissions for Subsets.
Memory Usage: 39.4 MB, less than 56.46% of Java online submissions for Subsets.

------------------- start [0]--------------
curr.size() : 0, k : 0
{0} return : []
------------------- start [1]--------------
curr.size() : 0, k : 1
curr.size() : 1, k : 1
{1} return : [1]
curr.size() : 1, k : 1
{2} return : [2]
curr.size() : 1, k : 1
{3} return : [3]
------------------- start [2]--------------
curr.size() : 0, k : 2
curr.size() : 1, k : 2
curr.size() : 2, k : 2
{2} return : [1, 2]
curr.size() : 2, k : 2
{3} return : [1, 3]
curr.size() : 1, k : 2
curr.size() : 2, k : 2
{3} return : [2, 3]
curr.size() : 1, k : 2
------------------- start [3]--------------
curr.size() : 0, k : 3
curr.size() : 1, k : 3
curr.size() : 2, k : 3
curr.size() : 3, k : 3
{3} return : [1, 2, 3]
curr.size() : 2, k : 3
curr.size() : 1, k : 3
curr.size() : 2, k : 3
curr.size() : 1, k : 3
```

***

# ## **`[LeetCode]` [Valid Parentheses](https://leetcode.com/problems/valid-parentheses/)**


```java
class Solution {
    public boolean isValid(String s) {
        Stack<Character> stack = new Stack<>();
        if(s.length() % 2 != 0) return false; 
        
        for(int i = 0 ; i < s.length() ; i++){
            char ch = s.charAt(i);
            if(ch == '(' || ch == '{' || ch == '[') stack.push(ch);
            else if(stack.isEmpty()) return false;
            else{
                char top = stack.peek();
                if(top == '(' && ch == ')') stack.pop();
                else if(top == '{' && ch == '}') stack.pop();
                else if(top == '[' && ch == ']') stack.pop();
                else return false;
            }
        }
        if(stack.size() > 0) return false;
        else return true;
    }
}
```

## Solution

```java
class Solution {

  // Hash table that takes care of the mappings.
  private HashMap<Character, Character> mappings;

  // Initialize hash map with mappings. This simply makes the code easier to read.
  public Solution() {
    this.mappings = new HashMap<Character, Character>();
    this.mappings.put(')', '(');
    this.mappings.put('}', '{');
    this.mappings.put(']', '[');
  }

  public boolean isValid(String s) {

    // Initialize a stack to be used in the algorithm.
    Stack<Character> stack = new Stack<Character>();

    for (int i = 0; i < s.length(); i++) {
      char c = s.charAt(i);

      // If the current character is a closing bracket.
      if (this.mappings.containsKey(c)) {

        // Get the top element of the stack. If the stack is empty, set a dummy value of '#'
        char topElement = stack.empty() ? '#' : stack.pop();

        // If the mapping for this bracket doesn't match the stack's top element, return false.
        if (topElement != this.mappings.get(c)) {
          return false;
        }
      } else {
        // If it was an opening bracket, push to the stack.
        stack.push(c);
      }
    }

    // If the stack still contains elements, then it is an invalid expression.
    return stack.isEmpty();
  }
}
```