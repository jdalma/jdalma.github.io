---
layout: default
title: 2021ÎÖÑ12Ïõî
nav_order: 8
parent: ÏïåÍ≥†Î¶¨Ï¶ò
---
## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---


## **`[LeetCode] DP` [N-th Tribonacci Number](https://leetcode.com/problems/n-th-tribonacci-number/)**

```java
class Solution {
    public int tribonacci(int n) {
        int first = 0;
        int second = 1;
        int third = 1;
        if(n == 0) return 0;
        else if(n == 1 || n == 2) return 1;
        else{
            for(int i = 3 ; i < n ; i++){
                int result = first + second + third;
                first = second;
                second = third;
                third = result;
            }
        }
        return first + second + third;
    }
}
```

***

## **`[LeetCode] DP` [Unique Paths II](https://leetcode.com/problems/unique-paths-ii/)**

### BFS ÏãúÍ∞ÑÏ¥àÍ≥º

```java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        if(obstacleGrid.length == 1 && obstacleGrid[0].length == 1 && obstacleGrid[0][0] == 0) return 1;
        else if(obstacleGrid[0][0] == 1) return 0;
        return bfs(obstacleGrid);
    }

    public int bfs(int[][] map){
        int sizeX = map.length;
        int sizeY = map[0].length;
        int count = 0;
        int[] moveX = new int[] {0 , 1};
        int[] moveY = new int[] {1 , 0};
        Queue<int[]> queue = new LinkedList<int[]>();
        queue.offer(new int[] {0 , 0});
        while(!queue.isEmpty()){
            int[] now = queue.poll();
            int nowX = now[0];
            int nowY = now[1];
            for(int i = 0 ; i < 2 ; i++){
                int moveXpos = nowX + moveX[i];
                int moveYpos = nowY + moveY[i];
                if(moveXpos >= 0 && moveYpos >= 0 && moveXpos < sizeX && moveYpos < sizeY){
                    if(map[moveXpos][moveYpos] == 0){
                        if(moveXpos == sizeX - 1 && moveYpos == sizeY - 1) count++;
                        queue.offer(new int[] {moveXpos , moveYpos});
                    }
                }
            }
        }
        return count;
    }
}
```

### üìå DP ÌÜµÍ≥º

- `[0,0]`ÏóêÏÑú **Ïö∞Ï∏°Í≥º ÏïÑÎûòÏ™ΩÏúºÎ°úÎßå Ïù¥ÎèôÌï† Ïàò ÏûàÎã§.**
- Ï≤´Î≤àÏß∏ ÌñâÍ≥º Ïó¥ÏùÑ 0 ÎòêÎäî 1Î°ú Ï±ÑÏö¥Îã§.(Ïù¥ÎèôÌï† Ïàò ÏûàÎäîÍ≥≥Ïù∏ÏßÄ ÌåêÎã®)
- **Í∑∏ ÌõÑ `[1,1]` Î∂ÄÌÑ∞ ÌòÑÏû¨ ÏúÑÏπòÏùò `[row - 1][col] + [row][col - 1]`ÏùÑ ÎçîÌï¥ ÎÇòÍ∞ÑÎã§.**
  - *ÎØ∏Î¶¨ Ï±ÑÏõåÎÜìÏùÄ Ï≤´Î≤àÏß∏ ÌñâÍ≥º Ïó¥ÏùÑ Ïû¨ÏÇ¨Ïö©ÌïòÎäîÍ≤ÉÏù¥Îã§.*


```java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        if(obstacleGrid[0][0] == 1) return 0;

        int row = obstacleGrid.length;
        int col = obstacleGrid[0].length;

        obstacleGrid[0][0] = 1;
        for(int i = 1 ; i < row ; i++){
            obstacleGrid[i][0] = (obstacleGrid[i][0] == 0 && obstacleGrid[i - 1][0] == 1) ? 1 : 0;
        }

        for(int i = 1 ; i < col ; i++){
            obstacleGrid[0][i] = (obstacleGrid[0][i] == 0 && obstacleGrid[0][i - 1] == 1) ? 1 : 0;
        }

        for(int i = 1 ; i < row ; i++){
            for(int j = 1 ; j < col ; j++){
                if(obstacleGrid[i][j] == 0){
                    obstacleGrid[i][j] = obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1];
                }
                else obstacleGrid[i][j] = 0;
            }
        }

        return obstacleGrid[row - 1][col - 1];
    }
}
```

***

## **`[LeetCode]` [Subsets](https://leetcode.com/problems/subsets/)**

### üìå Solution

- ÎÇ¥Í∞Ä Í∏∞Ï°¥Ïóê Ìï¥ÏôîÎçò Î∞©ÏãùÍ≥º Îã§Î•¥Í≤å **Ï°∞Ìï©Ïùò Î¶¨Ïä§Ìä∏ÏóêÏÑú ÎßàÏßÄÎßâ 1Í∞úÏî©ÏùÑ ÏÇ≠Ï†úÌïòÎ©∞ Î∞òÎ≥µÎ¨∏Ïùò Í∏ÄÎ°úÎ≤å Î≥ÄÏàò(`k`)ÏôÄ ÎòëÍ∞ôÏùÑ ÎïåÎßå ÏÉàÎ°úÏö¥ Î¶¨Ïä§Ìä∏Î•º Î∞òÌôòÌïòÍ≤å ÎèºÏûàÎã§.**

```java
class Solution {
    List<List<Integer>> output = new ArrayList();
    int n, k;

    public void backtrack(int first, ArrayList<Integer> curr, int[] nums) {
        System.out.println("curr.size() : " + curr.size() + ", k : " + k);
        // if the combination is done
        if (curr.size() == k) {
            System.out.println("{" + first + "} return : " + curr);
            output.add(new ArrayList(curr));
            return;
        }
        for (int i = first; i < n; ++i) {
            // add i into the current combination
            curr.add(nums[i]);
            // use next integers to complete the combination
            backtrack(i + 1, curr, nums);
            // backtrack
            // System.out.print("{" + first + "}  before remove : " + curr);
            curr.remove(curr.size() - 1);
            // System.out.println("  after remove : " + curr);
        }
    }

    public List<List<Integer>> subsets(int[] nums) {
        n = nums.length;
        for (k = 0; k < n + 1; k++) {
            System.out.println("------------------- start [" + k + "]--------------");
            backtrack(0, new ArrayList<Integer>(), nums);
        }
        return output;
    }
}
```

```
Runtime: 0 ms, faster than 100.00% of Java online submissions for Subsets.
Memory Usage: 39.4 MB, less than 56.46% of Java online submissions for Subsets.

------------------- start [0]--------------
curr.size() : 0, k : 0
{0} return : []
------------------- start [1]--------------
curr.size() : 0, k : 1
curr.size() : 1, k : 1
{1} return : [1]
curr.size() : 1, k : 1
{2} return : [2]
curr.size() : 1, k : 1
{3} return : [3]
------------------- start [2]--------------
curr.size() : 0, k : 2
curr.size() : 1, k : 2
curr.size() : 2, k : 2
{2} return : [1, 2]
curr.size() : 2, k : 2
{3} return : [1, 3]
curr.size() : 1, k : 2
curr.size() : 2, k : 2
{3} return : [2, 3]
curr.size() : 1, k : 2
------------------- start [3]--------------
curr.size() : 0, k : 3
curr.size() : 1, k : 3
curr.size() : 2, k : 3
curr.size() : 3, k : 3
{3} return : [1, 2, 3]
curr.size() : 2, k : 3
curr.size() : 1, k : 3
curr.size() : 2, k : 3
curr.size() : 1, k : 3
```

***

# **`[LeetCode]` [Valid Parentheses](https://leetcode.com/problems/valid-parentheses/)**


```java
class Solution {
    public boolean isValid(String s) {
        Stack<Character> stack = new Stack<>();
        if(s.length() % 2 != 0) return false;

        for(int i = 0 ; i < s.length() ; i++){
            char ch = s.charAt(i);
            if(ch == '(' || ch == '{' || ch == '[') stack.push(ch);
            else if(stack.isEmpty()) return false;
            else{
                char top = stack.peek();
                if(top == '(' && ch == ')') stack.pop();
                else if(top == '{' && ch == '}') stack.pop();
                else if(top == '[' && ch == ']') stack.pop();
                else return false;
            }
        }
        if(stack.size() > 0) return false;
        else return true;
    }
}
```

## Solution

```java
class Solution {

  // Hash table that takes care of the mappings.
  private HashMap<Character, Character> mappings;

  // Initialize hash map with mappings. This simply makes the code easier to read.
  public Solution() {
    this.mappings = new HashMap<Character, Character>();
    this.mappings.put(')', '(');
    this.mappings.put('}', '{');
    this.mappings.put(']', '[');
  }

  public boolean isValid(String s) {

    // Initialize a stack to be used in the algorithm.
    Stack<Character> stack = new Stack<Character>();

    for (int i = 0; i < s.length(); i++) {
      char c = s.charAt(i);

      // If the current character is a closing bracket.
      if (this.mappings.containsKey(c)) {

        // Get the top element of the stack. If the stack is empty, set a dummy value of '#'
        char topElement = stack.empty() ? '#' : stack.pop();

        // If the mapping for this bracket doesn't match the stack's top element, return false.
        if (topElement != this.mappings.get(c)) {
          return false;
        }
      } else {
        // If it was an opening bracket, push to the stack.
        stack.push(c);
      }
    }

    // If the stack still contains elements, then it is an invalid expression.
    return stack.isEmpty();
  }
}
```

***

# **`[LeetCode]` [Îã®Î±°Ìï≠ ÎßÅÌÅ¨Îìú Î¶¨Ïä§Ìä∏ Î≥ëÌï©](https://leetcode.com/problems/merge-two-sorted-lists/)**

- Ï†ïÎ†¨Îêú Îëê Í∞úÏùò Î¶¨Ïä§Ìä∏Î•º Î≥ëÌï©ÌïòÏó¨ Î∞òÌôòÌïúÎã§.

## Solution `Time complexity : O(n + m) , Space complexity : O(n + m)`

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        if(list1 == null) return list2;
        else if(list2 == null) return list1;
        else if(list1.val < list2.val) {
            list1.next = mergeTwoLists(list1.next , list2);
            return list1;
        }
        else{
            list2.next = mergeTwoLists(list1 , list2.next);
            return list2;
        }
    }
}
```

## üëçBest `Time complexity : O(n + m) , Space complexity : O(1)`

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        ListNode returnList = new ListNode(-1);
        ListNode tmp = returnList;
        while(list1 != null && list2 != null){
            if(list1.val <= list2.val){
                tmp.next = list1;
                list1 = list1.next;
            }
            else{
                tmp.next = list2;
                list2 = list2.next;
            }
            tmp = tmp.next;
        }

        tmp.next = list1 == null ? list2 : list1;
        return returnList.next;
    }
}
```

***

# **`[Î∞±Ï§Ä]` [ÌÉÄÏûÑÎ®∏Ïã†](https://www.acmicpc.net/problem/11657)**

## Î≤®Îßå-Ìè¨Îìú ÏïåÍ≥†Î¶¨Ï¶ò

- Ï≤òÏùåÏóê `edge`Í∏∞Ï§ÄÏúºÎ°úÎßå ÌôïÏù∏ÌïòÎ©¥ Îê† Ï§Ñ ÏïåÏïòÎã§.
- ÌïòÏßÄÎßå **ÏÇ¨Ïù¥ÌÅ¥Ïù¥ Ï°¥Ïû¨Ìï† Ïàò ÏûàÏúºÎãà** Ï≤òÏùåÏóê `(vertex - 1) * edge`Î•º ÌôïÏù∏ÌïòÏó¨Ïïº ÌñàÎã§.
- [Î≤®Îßå-Ìè¨Îìú Ï∞∏Í≥†](https://coder-in-war.tistory.com/entry/%EA%B0%9C%EB%85%90-38-%EB%B2%A8%EB%A7%8C%ED%8F%AC%EB%93%9CBellman-Ford-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)
  - `INF`Ïùº Îïå `contiune`ÌïòÎäî Ïù¥Ïú†
  - `(vertex - 1) * edge`Î•º ÌôïÏù∏ÌïòÎäî Ïù¥Ïú†

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

class Move{
    int end;
    long cost;
    public Move(int end, long cost) {
        this.end = end;
        this.cost = cost;
    }
}

class Main {
    static List<List<Move>> list = new ArrayList<>();
    static int vertex , edge;
    static long costArr[];
    static final long INF = Long.MAX_VALUE;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        vertex = Integer.parseInt(st.nextToken());
        edge = Integer.parseInt(st.nextToken());

        costArr = new long[vertex + 1];
        for(int i = 0 ; i <= vertex ; i++) {
            list.add(new ArrayList<Move>());
            costArr[i] = INF;
        }

        for(int i = 0 ; i < edge ; i++) {
            st = new StringTokenizer(br.readLine());
            int start = Integer.parseInt(st.nextToken());
            int end = Integer.parseInt(st.nextToken());
            long cost = Long.parseLong(st.nextToken());
            list.get(start).add(new Move(end , cost));
        }
        StringBuilder sb = new StringBuilder();
        if(solution()) {
            for(int i = 2 ; i <= vertex ; i++) {
                sb.append(costArr[i] == INF ? "-1" : costArr[i]).append("\n");
            }
        }
        else sb.append("-1\n");

        System.out.println(sb.toString());
    }

    public static boolean solution() {
        costArr[1] = 0;
        // Ìï¥Îãπ 3Ï§ë Î∞òÎ≥µÎ¨∏ÏùÄ (vertex - 1) * edge ÎßåÌÅºÏù¥Îã§.
        for(int q = 1 ; q < vertex ; q++) {
            for(int i = 1 ; i <= vertex ; i++) {
                if(costArr[i] == INF) continue;
                for(Move move : list.get(i)) {
                    int endVertex = move.end;
                    long cost = move.cost;
                    costArr[endVertex] = Math.min(costArr[endVertex] , costArr[i] + cost);
                }
            }
        }
        for(int i = 1 ; i <= vertex ; i++) {
            for(Move move : list.get(i)) {
                int endVertex = move.end;
                long cost = move.cost;
                if(costArr[i] != INF && costArr[endVertex] > costArr[i] + cost) {
                    return false;
                }
            }
        }
        return true;
    }
}
```

## SPFA (Shortest Path Faster Algorithm) ÏïåÍ≥†Î¶¨Ï¶ò

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

class Move{
    int end;
    long cost;
    public Move(int end, long cost) {
        this.end = end;
        this.cost = cost;
    }
}

class Main {
    static List<List<Move>> list = new ArrayList<>();
    static int vertex , edge;
    static long costArr[];
    static boolean checked[];
    static int cycleCount[];
    static final long INF = Long.MAX_VALUE;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        vertex = Integer.parseInt(st.nextToken());
        edge = Integer.parseInt(st.nextToken());

        costArr = new long[vertex + 1];
        checked = new boolean[vertex + 1];
        cycleCount = new int[vertex + 1];
        for(int i = 0 ; i <= vertex ; i++) {
            list.add(new ArrayList<Move>());
            costArr[i] = INF;
        }

        for(int i = 0 ; i < edge ; i++) {
            st = new StringTokenizer(br.readLine());
            int start = Integer.parseInt(st.nextToken());
            int end = Integer.parseInt(st.nextToken());
            long cost = Long.parseLong(st.nextToken());
            list.get(start).add(new Move(end , cost));
        }
        StringBuilder sb = new StringBuilder();
        if(solution()) {
            for(int i = 2 ; i <= vertex ; i++) {
                sb.append(costArr[i] == INF ? "-1" : costArr[i]).append("\n");
            }
        }
        else sb.append("-1\n");

        System.out.println(sb.toString());
    }

    public static boolean solution() {
        costArr[1] = 0;
        Queue<Integer> queue = new LinkedList<>();
        queue.offer(1);
        cycleCount[1]++;
        checked[1] = true;

        while(!queue.isEmpty()){
            int now = queue.poll();
            checked[now] = false;
            for(Move move : list.get(now)) {
                int endVertex = move.end;
                long cost = move.cost;
                if(costArr[endVertex] > costArr[now] + cost){
                    costArr[endVertex] = costArr[now] + cost;
                    if(!checked[endVertex]){
                        if(++cycleCount[endVertex] >= vertex){
                            return false;
                        }
                        queue.offer(endVertex);
                        checked[endVertex] = true;
                    }
                }
            }
        }
        return true;
```

***

# **`[Î∞±Ï§Ä] Îã§ÏùµÏä§Ìä∏Îùº` [ÏµúÏÜåÎπÑÏö© Íµ¨ÌïòÍ∏∞](https://www.acmicpc.net/problem/1916)**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

class Edge implements Comparable<Edge>{
	int city;
	int cost;
	public Edge(int city , int cost) {
		this.city = city;
		this.cost = cost;
	}
	@Override
	public int compareTo(Edge o) {
		return this.cost - o.cost;
	}
	@Override
	public String toString() {
		return "Edge [city=" + city + ", cost=" + cost + "]";
	}
}

class Main {
    static List<List<Edge>> list = new ArrayList<>();
    static int[] costArr;
    static boolean[] visited;
    static int city , bus;
    static int startCity , endCity;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        city = Integer.parseInt(br.readLine());
        bus = Integer.parseInt(br.readLine());
        StringTokenizer st;
        costArr = new int[city + 1];
        visited = new boolean[city + 1];
        for(int i = 0 ; i <= city ; i++){
            list.add(new ArrayList<Edge>());
            costArr[i] = Integer.MAX_VALUE; 
        }
        for(int i = 0 ; i < bus ; i++){
            st = new StringTokenizer(br.readLine());
            int start = Integer.parseInt(st.nextToken());
            int end = Integer.parseInt(st.nextToken());
            int cost = Integer.parseInt(st.nextToken());
            list.get(start).add(new Edge(end , cost));
        }
        st = new StringTokenizer(br.readLine());
        startCity = Integer.parseInt(st.nextToken());
        endCity = Integer.parseInt(st.nextToken());
        
        solution();
        System.out.println(costArr[endCity]);
//        for(int value : costArr) System.out.println(value);
    }
    
    public static void solution(){
    	PriorityQueue<Edge> queue = new PriorityQueue<>();
    	queue.offer(new Edge(startCity , 0));
    	costArr[startCity] = 0;
    	while(!queue.isEmpty()) {
    		Edge edge = queue.poll();
    		int city = edge.city;
    		int cost = edge.cost;
    		if(costArr[city] < cost) continue;
    		for(Edge moveEdge : list.get(city)) {
				if(costArr[moveEdge.city] > costArr[city] + moveEdge.cost) {
    				costArr[moveEdge.city] = costArr[city] + moveEdge.cost;
    				queue.offer(new Edge(moveEdge.city , costArr[moveEdge.city]));
    			}
    		}
    	}
    }       
}
```

***

# **`[Î∞±Ï§Ä] BFS` [ÌäπÏ†ï Í±∞Î¶¨Ïùò ÎèÑÏãú Ï∞æÍ∏∞](https://www.acmicpc.net/problem/18352)**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

class Main {
	static List<List<Integer>> list = new ArrayList<>();
	static List<Integer> resultList = new ArrayList<>();
	static int[] distArr;
	static boolean[] checked;
	static int cityCount , edgeCount , targetCost , startCity;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        cityCount = Integer.parseInt(st.nextToken());
        edgeCount = Integer.parseInt(st.nextToken());
        targetCost = Integer.parseInt(st.nextToken());
        startCity = Integer.parseInt(st.nextToken());
//        distArr = new int[cityCount + 1];
//        checked = new boolean[cityCount + 1];
        distArr = new int[300001];
      	checked = new boolean[300001];        
        Arrays.fill(distArr, Integer.MAX_VALUE);
        for(int i = 0 ; i < 300001 ; i++) list.add(new ArrayList<Integer>());
        for(int i = 0 ; i < edgeCount ; i++) {
        	st = new StringTokenizer(br.readLine());
        	int start = Integer.parseInt(st.nextToken());
        	int end = Integer.parseInt(st.nextToken());
        	list.get(start).add(end);
        }
        
        bfs();
        if(resultList.isEmpty()) {
        	System.out.println("-1");
        }
        else {
            Collections.sort(resultList);
            for(int value : resultList) System.out.println(value);        	
        }
    }
    
    public static void bfs() {
    	Queue<int[]> queue = new LinkedList<int[]>();
    	queue.offer(new int[] {startCity , 0});
    	distArr[startCity] = 0;
    	while(!queue.isEmpty()) {
    		int[] now = queue.poll();
    		int nowCity = now[0];
    		int cost = now[1];
    		if(cost + 1 > targetCost) continue;
    		for(int city : list.get(nowCity)) {
    			if(distArr[city] > cost + 1) {
    				distArr[city] = cost + 1;
    				queue.offer(new int[] {city , cost + 1});
    				if(cost + 1 == targetCost) resultList.add(city);
    			}
    		}
    	}
    }
}
```

***

# **`[Î∞±Ï§Ä] Îã§ÏùµÏä§Ìä∏Îùº` [ÏßÄÎ¶ÑÍ∏∏](https://www.acmicpc.net/problem/1446)** ‚ùå
- [DP Ï∞∏Í≥†](https://rays-space.tistory.com/16)

```java

```

***

# **`[Î∞±Ï§Ä] Îã§ÏùµÏä§Ìä∏Îùº` [ÌäπÏ†ïÌïú ÏµúÎã®Í≤ΩÎ°ú](https://www.acmicpc.net/problem/1504)**

> üìå [ÌíÄÏù¥ Ï∂úÏ≤ò](https://steady-coding.tistory.com/82)
> - Ïñ∏Îúª Î≥¥Î©¥, Îã§ÏùµÏä§Ìä∏Îùº ÏïåÍ≥†Î¶¨Ï¶òÏùÑ Ïñ¥ÎñªÍ≤å ÏùëÏö©Ìï¥ÏïºÌï† ÏßÄ Ïñ¥Î†§Ïö∏ Ïàò ÏûàÏúºÎÇò ÏâΩÍ≤å ÏÉùÍ∞ÅÌïòÎ©¥ Í∏àÎ∞© Ìï¥Í≤∞Îê©ÎãàÎã§.
> - Î∞îÎ°ú Ï™ºÍ∞úÏÑú ÏÉùÍ∞ÅÌïòÎäî Í≤ÉÏù¥Ï£†.
> - ÏõêÎûò Í±∞Ï≥êÏïºÌïòÎäî ÎÖ∏ÎìúÍ∞Ä ÏóÜÎã§Î©¥, 1 -> NÍπåÏßÄ Îã§Ïù¥Î†âÌä∏Î°ú Îã§ÏùµÏä§Ìä∏Îùº ÏïåÍ≥†Î¶¨Ï¶òÏùÑ 1Î≤àÎßå Ïã§ÌñâÌïòÎ©¥ Îê©ÎãàÎã§.
> - ÌïòÏßÄÎßå, Í±∞Ï≥êÏïºÌïòÎäî ÎÖ∏ÎìúÍ∞Ä ÏûàÎã§Î©¥ ÏïÑÎûòÏôÄ Í∞ôÏù¥ 2Í∞ÄÏßÄ Í≤ΩÏö∞Î°ú ÎÇòÎàÑÏñ¥ÏÑú ÏÉùÍ∞ÅÌï¥Ïïº Ìï©ÎãàÎã§.
> - (Ïù¥ Îïå, Í±∞Ï≥êÏïºÌïòÎäî ÎÖ∏ÎìúÎ•º v1Í≥º v2Î°ú ÌëúÌòÑÌïòÍ≤†ÏäµÎãàÎã§.)
> - (1) 1 -> v1 -> v2 -> N
> - (2) 1 -> v2 -> v1 -> N
> - 1Î≤à ÏºÄÏù¥Ïä§Ïùò Í≤ΩÏö∞, 1ÏóêÏÑú v1ÍπåÏßÄ Îã§ÏùµÏä§Ìä∏Îùº ÏïåÍ≥†Î¶¨Ï¶òÏùÑ ÏàòÌñâ, v1ÏóêÏÑú v2ÍπåÏßÄ Îã§ÏùµÏä§Ìä∏Îùº ÏïåÍ≥†Î¶¨Ï¶òÏùÑ ÏàòÌñâ, NÍπåÏßÄ Îã§ÏùµÏä§Ìä∏Îùº ÏïåÍ≥†Î¶¨Ï¶òÏùÑ ÏàòÌñâÌïòÎ©¥ Îê©ÎãàÎã§. Í∑∏Î¶¨Í≥† Í∞ÅÍ∞ÅÏùò ÏµúÎã® Í±∞Î¶¨Ïóê ÎåÄÌï¥ÏÑú Î™®Îëê ÎçîÌï©ÎãàÎã§.
> - 2Î≤à ÏºÄÏù¥Ïä§ÎèÑ ÎßàÏ∞¨Í∞ÄÏßÄÎ°ú ÏµúÎã® Í±∞Î¶¨Î•º ÎçîÌïòÍ≥†, 1Î≤à ÏºÄÏù¥Ïä§ÏóêÏÑú Íµ¨Ìïú Í≤∞Í≥ºÍ∞íÍ≥º ÎπÑÍµêÌï¥ÏÑú Îçî ÏûëÏùÄ Í∞íÏùÑ Ï†ïÎãµÏúºÎ°ú Ï∂úÎ†•ÌïòÎ©¥ Îê©ÎãàÎã§.
> - Îã§Îßå, 1Î≤àÍ≥º 2Î≤à ÏºÄÏù¥Ïä§ÏóêÏÑú ÏñªÏñ¥ÎÇ∏ Í∞íÏù¥ INFÎ≥¥Îã§ ÌÅ¨Í±∞ÎÇò Í∞ôÎã§Î©¥ v1Í≥º v2Î•º Í±∞Ï≥êÏÑú NÏóê ÎèÑÎã¨Ìï† Ïàò ÏóÜÎã§Îäî ÏùòÎØ∏Ïù¥ÎØÄÎ°ú -1ÏùÑ Ï∂úÎ†•ÌïòÎ©¥ Îê©ÎãàÎã§.

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

class Edge implements Comparable<Edge>{
    int node;
    int cost;
    public Edge(int node , int cost) {
        this.node = node;
        this.cost = cost;
    }
    @Override
    public int compareTo(Edge o) {
        return this.cost - o.cost;
    }
    @Override
    public String toString() {
        return "Edge [node=" + node + ", cost=" + cost + "]";
    }
}

class Main {
    static List<List<Edge>> list = new ArrayList<>();
    static int[] costArr;
    static boolean[] visited;
    static int vertex , edge;
    static int goThroughCity1 , goThroughCity2;
    static int INF = 200000000;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        vertex = Integer.parseInt(st.nextToken());
        edge = Integer.parseInt(st.nextToken());

        costArr = new int[vertex + 1];
        visited = new boolean[vertex + 1];
        for(int i = 0 ; i <= vertex ; i++){
            list.add(new ArrayList<Edge>());
        }

        for(int i = 0 ; i < edge ; i++){
            st = new StringTokenizer(br.readLine());
            int start = Integer.parseInt(st.nextToken());
            int end = Integer.parseInt(st.nextToken());
            int cost = Integer.parseInt(st.nextToken());
            list.get(start).add(new Edge(end , cost));
            list.get(end).add(new Edge(start , cost));
        }
        st = new StringTokenizer(br.readLine());
        goThroughCity1 = Integer.parseInt(st.nextToken());
        goThroughCity2 = Integer.parseInt(st.nextToken());

        // (1) 1 -> v1 -> v2 -> N
        int firstPath = 0;
        firstPath += solution(1 , goThroughCity1);
        firstPath += solution(goThroughCity1 , goThroughCity2);
        firstPath += solution(goThroughCity2 , vertex);

        // (2) 1 -> v2 -> v1 -> N
        int secondPath = 0;
        secondPath += solution(1 , goThroughCity2);
        secondPath += solution(goThroughCity2 , goThroughCity1);
        secondPath += solution(goThroughCity1 , vertex);

//        System.out.println(firstPath + " " + secondPath);
        int result = firstPath >= INF && secondPath >= INF ? -1 : Math.min(firstPath , secondPath);
        System.out.println(result);

    }

    public static int solution(int start , int end){
        PriorityQueue<Edge> queue = new PriorityQueue<>();

        Arrays.fill(costArr, INF);
        Arrays.fill(visited , false);
        costArr[start] = 0;

        queue.offer(new Edge(start , 0));
        while(!queue.isEmpty()){
            Edge now = queue.poll();
            int stanVertex = now.node;
            if(!visited[stanVertex]){
                visited[stanVertex] = true;
                for(Edge newEdge : list.get(stanVertex)){
                    if(!visited[newEdge.node] && costArr[newEdge.node] > costArr[stanVertex] + newEdge.cost){
                        costArr[newEdge.node] = costArr[stanVertex] + newEdge.cost;
                        queue.offer(new Edge(newEdge.node , costArr[newEdge.node]));
                    }
                }
            }
        }
        return costArr[end];
    }
}
```