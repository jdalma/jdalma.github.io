---
layout: default
title: 2021ë…„12ì›”
nav_order: 8
parent: ì•Œê³ ë¦¬ì¦˜
---
## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---


## **`[LeetCode] DP` [N-th Tribonacci Number](https://leetcode.com/problems/n-th-tribonacci-number/)**

```java
class Solution {
    public int tribonacci(int n) {
        int first = 0;
        int second = 1;
        int third = 1;
        if(n == 0) return 0;
        else if(n == 1 || n == 2) return 1;
        else{
            for(int i = 3 ; i < n ; i++){
                int result = first + second + third;
                first = second;
                second = third;
                third = result;
            }
        }
        return first + second + third;
    }
}
```

***

## **`[LeetCode] DP` [Unique Paths II](https://leetcode.com/problems/unique-paths-ii/)**

### BFS ì‹œê°„ì´ˆê³¼

```java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        if(obstacleGrid.length == 1 && obstacleGrid[0].length == 1 && obstacleGrid[0][0] == 0) return 1;
        else if(obstacleGrid[0][0] == 1) return 0;
        return bfs(obstacleGrid);
    }

    public int bfs(int[][] map){
        int sizeX = map.length;
        int sizeY = map[0].length;
        int count = 0;
        int[] moveX = new int[] {0 , 1};
        int[] moveY = new int[] {1 , 0};
        Queue<int[]> queue = new LinkedList<int[]>();
        queue.offer(new int[] {0 , 0});
        while(!queue.isEmpty()){
            int[] now = queue.poll();
            int nowX = now[0];
            int nowY = now[1];
            for(int i = 0 ; i < 2 ; i++){
                int moveXpos = nowX + moveX[i];
                int moveYpos = nowY + moveY[i];
                if(moveXpos >= 0 && moveYpos >= 0 && moveXpos < sizeX && moveYpos < sizeY){
                    if(map[moveXpos][moveYpos] == 0){
                        if(moveXpos == sizeX - 1 && moveYpos == sizeY - 1) count++;
                        queue.offer(new int[] {moveXpos , moveYpos});
                    }
                }
            }
        }
        return count;
    }
}
```

### ðŸ“Œ DP í†µê³¼

- `[0,0]`ì—ì„œ **ìš°ì¸¡ê³¼ ì•„ëž˜ìª½ìœ¼ë¡œë§Œ ì´ë™í•  ìˆ˜ ìžˆë‹¤.**
- ì²«ë²ˆì§¸ í–‰ê³¼ ì—´ì„ 0 ë˜ëŠ” 1ë¡œ ì±„ìš´ë‹¤.(ì´ë™í•  ìˆ˜ ìžˆëŠ”ê³³ì¸ì§€ íŒë‹¨)
- **ê·¸ í›„ `[1,1]` ë¶€í„° í˜„ìž¬ ìœ„ì¹˜ì˜ `[row - 1][col] + [row][col - 1]`ì„ ë”í•´ ë‚˜ê°„ë‹¤.** 
  - *ë¯¸ë¦¬ ì±„ì›Œë†“ì€ ì²«ë²ˆì§¸ í–‰ê³¼ ì—´ì„ ìž¬ì‚¬ìš©í•˜ëŠ”ê²ƒì´ë‹¤.*


```java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        if(obstacleGrid[0][0] == 1) return 0;
        
        int row = obstacleGrid.length;
        int col = obstacleGrid[0].length;
        
        obstacleGrid[0][0] = 1;
        for(int i = 1 ; i < row ; i++){
            obstacleGrid[i][0] = (obstacleGrid[i][0] == 0 && obstacleGrid[i - 1][0] == 1) ? 1 : 0;
        }
        
        for(int i = 1 ; i < col ; i++){
            obstacleGrid[0][i] = (obstacleGrid[0][i] == 0 && obstacleGrid[0][i - 1] == 1) ? 1 : 0;
        }
        
        for(int i = 1 ; i < row ; i++){
            for(int j = 1 ; j < col ; j++){
                if(obstacleGrid[i][j] == 0){
                    obstacleGrid[i][j] = obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1];
                }
                else obstacleGrid[i][j] = 0;
            }
        }
        
        return obstacleGrid[row - 1][col - 1];
    }
}
```

***

## **`[LeetCode]` [Subsets](https://leetcode.com/problems/subsets/) ì§„í–‰ ì¤‘**

```java
class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> results = new ArrayList<>();
        boolean[] checked = new boolean[nums.length];
        recursive(results , nums , 0);
        return results;
    }
    
    private void recursive(List<List<Integer>> results , int[] nums , boolean[] checked , int index){
        if(index < nums.length - 1){
            results.add(new ArrayList<Integer>());
            for(int i = 0 ; i < nums.length ; i++){
                if(checked[i])
                recursive();
            }
        }
    }
}
```