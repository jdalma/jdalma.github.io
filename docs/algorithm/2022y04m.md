---
layout: default
title: 2022년 4월
nav_order: 12
parent: 🐢 알고리즘
---
## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

# **`[백준]` [소수](https://www.acmicpc.net/problem/2581)**

```java
import java.io.*;

class Main{
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        int M = Integer.parseInt(br.readLine());
        int N = Integer.parseInt(br.readLine());

        int sum = 0;
        int min = Integer.MAX_VALUE;

        mainLoop:
        for(int i = M ; i <= N ; i++){
            if(i == 1) continue;
            for(int j = 2 ; j < i ; j++){
                if(i % j == 0) {
                    continue mainLoop;
                }
            }
            sum += i;
            min = Math.min(min , i);
        }

        String result = sum == 0 ? "-1" : sum + "\n" + min;

        bw.append(result);
        bw.flush();
        bw.close();
        br.close();
    }
}
```

# **`[백준] BFS` [양 한마리.. 양 두마리..](https://www.acmicpc.net/problem/11123)**

```java
import java.io.*;
import java.util.ArrayDeque;
import java.util.Queue;
import java.util.StringTokenizer;

class Main{
    static int[][] moves4dir = { {-1 , 0} , {0 , 1} , {1 , 0} , {0 , -1} };
    static int row , col;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        int testCase = Integer.parseInt(br.readLine());

        for(int test = 0 ; test < testCase ; test++){

            StringTokenizer st = new StringTokenizer(br.readLine());
            row = Integer.parseInt(st.nextToken());
            col = Integer.parseInt(st.nextToken());

            char[][] map = new char[row][col];
            boolean[][] visited = new boolean[row][col];

            for(int i = 0 ; i < row ; i++){
                map[i] = br.readLine().toCharArray();
            }

            int chunkCount = 0;
            for(int i = 0 ; i < row ; i++){
                for(int j = 0 ; j < col ; j++){
                    if(map[i][j] == '#'){
                        // 양 무리 방문 처리
                        check(i , j , map);
                        chunkCount++;
                    }
                }
            }

            bw.append(chunkCount + "\n");
        }

        bw.flush();
        bw.close();
        br.close();
    }

    public static void check(int x , int y , char[][] map){
        Queue<int[]> q = new ArrayDeque<>();
        q.offer(new int[]{ x , y});
        map[x][y] = '.';

        while(!q.isEmpty()){
            int[] now = q.poll();
            for(int[] pos : moves4dir){
                int moveX = now[0] + pos[0];
                int moveY = now[1] + pos[1];
                if(moveX >= 0 && moveX < row && moveY >= 0 && moveY < col){
                    if(map[moveX][moveY] == '#'){
                        q.offer(new int[] {moveX , moveY});
                        map[moveX][moveY] = '.';
                    }
                }
            }
        }
    }
}

```

# **`[백준] Dijkstra` [택배배송](https://www.acmicpc.net/problem/5972)**

```java
import java.io.*;
import java.util.*;

class Road implements Comparable<Road> {
    int road;
    int cost;

    public Road(int road, int cost) {
        this.road = road;
        this.cost = cost;
    }

    @Override
    public int compareTo(Road o) {
        return this.cost - o.cost;
    }
}

class Main {
    static int node, edge;
    static List<List<Road>> roads = new ArrayList<>();
    static int[] costs;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        StringTokenizer st = new StringTokenizer(br.readLine());

        node = Integer.parseInt(st.nextToken());
        edge = Integer.parseInt(st.nextToken());

        costs = new int[node + 1];

        // 인접 리스트 , 비용 배열 초기화
        for (int i = 0; i <= node; i++) {
            roads.add(new ArrayList<>());
            costs[i] = Integer.MAX_VALUE;
        }

        for (int i = 0; i < edge; i++) {
            st = new StringTokenizer(br.readLine());
            int start = Integer.parseInt(st.nextToken());
            int end = Integer.parseInt(st.nextToken());
            int cost = Integer.parseInt(st.nextToken());
            // 양방향 저장
            roads.get(start).add(new Road(end, cost));
            roads.get(end).add(new Road(start, cost));
        }

        dijkstra();

        bw.append(String.valueOf(costs[node]));
        bw.flush();
        bw.close();
        br.close();
    }

    public static void dijkstra() {
        // 우선순위 큐 사용
        // cost가 작은 것 부터 poll()
        PriorityQueue<Road> pq = new PriorityQueue<>();
        pq.offer(new Road(1, 0));
        costs[1] = 0;

        while (!pq.isEmpty()) {
            Road now = pq.poll();
            if (costs[now.road] < now.cost)
                continue;
            for (Road nearRoad : roads.get(now.road)) {
                int sumCost = now.cost + nearRoad.cost;
                // 비용을 누적하며 나아감
                // 현재의 누적할 비용이 costs배열의 비용보다 작다면 큐에 담는다
                if (costs[nearRoad.road] > sumCost) {
                    costs[nearRoad.road] = sumCost;
                    pq.offer(new Road(nearRoad.road, sumCost));
                }
            }
        }
    }
}
```

# **`[백준] Implementation` [낚시왕](https://www.acmicpc.net/problem/17143)**

```java
import java.io.*;
import java.util.*;

class Shark {
    int s, d, z;

    public Shark(int s, int d, int z) {
        this.s = s;
        this.d = d;
        this.z = z;
    }

    @Override
    public String toString() {
        return "Shark{" +
                "s=" + s +
                ", d=" + d +
                ", z=" + z +
                '}';
    }
}

class Main {
    static int row, col, count, result = 0;
    static Shark[][] map;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        StringTokenizer st = new StringTokenizer(br.readLine());

        row = Integer.parseInt(st.nextToken());
        col = Integer.parseInt(st.nextToken());
        count = Integer.parseInt(st.nextToken());

        if (count > 0) {
            map = new Shark[row][col];

            for (int i = 0; i < count; i++) {
                st = new StringTokenizer(br.readLine());
                int x = Integer.parseInt(st.nextToken()) - 1;
                int y = Integer.parseInt(st.nextToken()) - 1;
                int s = Integer.parseInt(st.nextToken());
                int d = Integer.parseInt(st.nextToken());
                int z = Integer.parseInt(st.nextToken());
                map[x][y] = new Shark(s, d, z);
            }

            for (int people = 0; people < col; people++) {
                findShark(people);
                timePasses();
            }
        }

        bw.append(String.valueOf(result));
        bw.flush();
        bw.close();
        br.close();
    }

    public static void findShark(int y) {
        for (int x = 0; x < row; x++) {
            if (map[x][y] != null) {
                // 상어의 무게 누적
                result += map[x][y].z;
                map[x][y] = null;
                break;
            }
        }
    }

    public static void timePasses() {

        // 상어가 다 움직이고 나서 상어가 중첩되었는지 판단해야 하니 임시 배열 생성
        Shark[][] tmp = new Shark[row][col];

        for (int x = 0; x < row; x++) {
            for (int y = 0; y < col; y++) {
                if (map[x][y] != null) {
                    move(x, y, map[x][y], tmp);
                }
            }
        }
        // 임시배열에 살아 있는 상어만 얕은 복사한다.
        copy(tmp);
    }

    public static void copy(Shark[][] tmp) {
        for (int x = 0; x < row; x++) {
            for (int y = 0; y < col; y++) {
                map[x][y] = tmp[x][y];
            }
        }
    }

    // 1
    // 4 3
    // 2
    public static void move(int x, int y, Shark shark, Shark[][] tmp) {
        int dir = shark.d;
        int distance = shark.s;

        int moveX = x;
        int moveY = y;

        // 움직일 거리가 0보다 클 때만 움직일 위치를 구한다.
        if (distance > 0) {
            if (dir == 1) {
                moveX = move(row, x, distance * -1, shark);
            } else if (dir == 2) {
                moveX = move(row, x, distance, shark);
            } else if (dir == 3) {
                moveY = move(col, y, distance, shark);
            } else {
                moveY = move(col, y, distance * -1, shark);
            }
        }

        if (tmp[moveX][moveY] != null && tmp[moveX][moveY].z > shark.z) {
            return;
        } else {
            tmp[moveX][moveY] = shark;
        }
    }

    public static int move(int range, int pos, int distance, Shark shark) {
        int count = Math.abs(distance);
        for (int i = 1; i <= count; i++) {
            if (distance > 0) {
                ++pos;
                if (range == pos) {
                    distance *= -1;
                    pos -= 2;
                    // 상어가 되돌아가면 방향을 바꿔준다.
                    shark.d = shark.d == 2 ? 1 : 4;
                }
            } else {
                --pos;
                if (-1 == pos) {
                    distance *= -1;
                    pos += 2;
                    // 상어가 되돌아가면 방향을 바꿔준다.
                    shark.d = shark.d == 1 ? 2 : 3;
                }
            }
        }
        return pos;
    }

    public static void print(Shark[][] m) {
        for (int x = 0; x < row; x++) {
            for (int y = 0; y < col; y++) {
                if (m[x][y] != null) {
                    System.out.println((x + 1) + " " + (y + 1) + " " + m[x][y]);
                }
            }
        }
    }
}
```

***

# **`[프로그래머스] 해시` [위장](https://programmers.co.kr/learn/courses/30/lessons/42578)**

```java
import java.util.Map;
import java.util.HashMap;
import java.util.Set;

class Solution {
    public int solution(String[][] clothes) {
        Map<String , Integer> map = new HashMap<>();

        for(int i = 0 ; i < clothes.length ; i++){
            String key = clothes[i][1];
            int value = map.getOrDefault(key , 0);
            map.put(key , value + 1);
        }

        int sum = 1;
        int multi = 0;
        Set<String> keySet = map.keySet();
        for(String key : keySet){
            int value = map.get(key);
            // 해당 의상을 입지 않을 경우도 있으니 + 1
            sum *= (value + 1);
        }

        // 아무것도 안입을 경우는 뺀다 - 1
        return sum - 1;
    }
}
```

***

# **`[프로그래머스] BFS` [게임 맵 최단거리](https://programmers.co.kr/learn/courses/30/lessons/1844)**

```java
import java.util.Queue;
import java.util.ArrayDeque;

class Solution {
    int row , col;
    int[][] moves4dir = { {-1 , 0} , {0 , 1} , {1 , 0} , {0 , -1} };

    public int solution(int[][] maps) {
        row = maps.length;
        col = maps[0].length;

        int answer = Integer.MAX_VALUE;
        
        boolean[][] visited = new boolean[row][col];
        Queue<int[]> q = new ArrayDeque<>();

        // int[x , y , count]
        q.offer(new int[] {0 , 0 , 1});
        visited[0][0] = true;

        while(!q.isEmpty()){
            int[] now = q.poll();
            if(now[0] == row - 1 && now[1] == col - 1){
                answer = Math.min(answer , now[2]);
                continue;
            }
            for(int[] move : moves4dir){
                int moveX = now[0] + move[0];
                int moveY = now[1] + move[1];
                if(!isOutOfRange(moveX , moveY) && !visited[moveX][moveY] && maps[moveX][moveY] == 1){
                    visited[moveX][moveY] = true;
                    q.offer(new int[] {moveX , moveY , now[2] + 1});
                }
            }
        }

        return answer == Integer.MAX_VALUE ? -1 : answer;
    }

    public boolean isOutOfRange(int x , int y){
        if(x < 0 || x >= row || y < 0 || y >= col) return true;
        return false;
    }
}
```

***

# **`[프로그래머스]` [정수 삼각형](https://programmers.co.kr/learn/courses/30/lessons/43105)** ❌

## `DFS` 시간초과

```java
class Solution {
    int row , col;
    int[][] map;
    public int solution(int[][] triangle) {
        map = triangle;
        row = triangle.length;
        col = triangle[0].length;

        return DFS(0, 0, 0);
    }

    public int DFS(int x , int y , int max){
        if(x >= row) return max;

        return Math.max(DFS(x + 1 , y , max + map[x][y]) , DFS(x + 1 , y + 1 , max + map[x][y]));
    }    
// 정확성: 50.0
// 효율성: 0.0
// 합계: 50.0 / 100.0
// DP 너무 어려워요
}
```

## `DP - TopDown`

```java
class Solution {
    public int solution(int[][] triangle) {
        int answer = 0;
        
        for(int i = 1 ; i < triangle.length ; i++){
            for(int j = 0 ; j < triangle[i].length ; j++){
                
                if(j == 0){
                    triangle[i][j] = triangle[i][j] + triangle[i - 1][j];
                }
                else if(i == j){
                    triangle[i][j] = triangle[i][j] + triangle[i - 1][j - 1];
                }
                else{
                    int left = triangle[i][j] + triangle[i - 1][j];
                    int right = triangle[i][j] + triangle[i - 1][j - 1];
                    triangle[i][j] = Math.max(left , right);                    
                }
                answer = Math.max(answer , triangle[i][j]);
            }
        }
        
        return answer;
    }
}
```

## `DP - Bottom Up`

```java
class Solution {
    public int solution(int[][] triangle) {
        for(int i = triangle.length - 2 ; i >= 0 ; i--){
            for(int j = 0 ; j < triangle[i].length ; j++){
                int left = triangle[i][j] + triangle[i + 1][j];
                int right = triangle[i][j] + triangle[i + 1][j + 1];
                triangle[i][j] = Math.max(left , right);
            }
        }
        
        return triangle[0][0];
    }
}
```

***

# **`[프로그래머스]` [올바른 괄호의 개수](https://programmers.co.kr/learn/courses/30/lessons/12929)** 📝

```java
import java.util.*;

class P {
    int open , close;
    public P(int open , int close){
        this.open = open;
        this.close = close;
    }
}

class Solution {
    
    public int solution(int n) {
        int result = 0;    
        Deque<P> stack = new ArrayDeque<P>();
        stack.push(new P(0 , 0));
        while(!stack.isEmpty()){
            P p = stack.pop();
            
            if(p.open > n) continue;
            if(p.open < p.close) continue;
            if(p.open + p.close == n * 2) {
                result++;
                continue;
            };
            
            stack.push(new P(p.open + 1 , p.close));
            stack.push(new P(p.open , p.close + 1));
        }
        
        return result;
    }
}
```

***


# **`[백준] String` [ROT13](https://www.acmicpc.net/problem/4446)**

```java
import java.io.*;
import java.util.ArrayList;
import java.util.List;

class Main {
    static char[] lowerVowel = { 'a', 'i', 'y', 'e', 'o', 'u' };
    static char[] lowerConsonant = { 'b', 'k', 'x', 'z', 'n', 'h', 'd', 'c', 'w', 'g', 'p', 'v', 'j', 'q', 't', 's',
            'r', 'l', 'm', 'f' };
    static char[] upperVowel = { 'A', 'I', 'Y', 'E', 'O', 'U' };
    static char[] upperConsonant = { 'B', 'K', 'X', 'Z', 'N', 'H', 'D', 'C', 'W', 'G', 'P', 'V', 'J', 'Q', 'T', 'S',
            'R', 'L', 'M', 'F' };

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        String line;
        while ((line = br.readLine()) != null) {
            StringBuilder result = new StringBuilder();
            char[] input = line.toCharArray();
            for (char ch : input) {
                char after = ' ';
                if (Character.isAlphabetic(ch)) {
                    // 모음
                    if (isVowel(ch)) {
                        if (Character.isUpperCase(ch)) {
                            after = convert(upperVowel, ch, 3);
                        } else {
                            after = convert(lowerVowel, ch, 3);
                        }
                    }
                    // 자음
                    else {
                        if (Character.isUpperCase(ch)) {
                            after = convert(upperConsonant, ch, 10);
                        } else {
                            after = convert(lowerConsonant, ch, 10);
                        }
                    }
                } else
                    after = ch;
                result.append(after);
            }
            result.append("\n");
            bw.append(result.toString());
            bw.flush();
        }
        bw.close();
        br.close();
    }

    public static boolean isVowel(char ch) {
        // 모음이라면 true
        char c = Character.toLowerCase(ch);
        for (int i = 0; i < lowerVowel.length; i++) {
            if (c == lowerVowel[i])
                return true;
        }
        return false;
    }

    public static char convert(char[] arr, char ch, int plusIndex) {
        int index = 0;
        for (int i = 0; i < arr.length; i++) {
            if (ch == arr[i]) {
                index = i;
                break;
            }
        }

        int sumIndex = index + plusIndex;
        if (sumIndex > arr.length - 1) {
            sumIndex = sumIndex - arr.length;
        }

        return arr[sumIndex];
    }
}
```

# **`[백준] Dijkstra` [최단경로](https://www.acmicpc.net/problem/1753)**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

class Edge implements Comparable<Edge>{
    int vertex;
    int cost;
    public Edge(int vertex, int cost) {
        this.vertex = vertex;
        this.cost = cost;
    }
    @Override
    public int compareTo(Edge o) {
        return cost - o.cost;
    }
}

class Main {
    static int[] result;
    static List<ArrayList<Edge>> list = new ArrayList<>();
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        int vertex = Integer.parseInt(st.nextToken());
        int edge = Integer.parseInt(st.nextToken());

        
        result = new int[vertex + 1];
        Arrays.fill(result , Integer.MAX_VALUE);

        int stanVertex = Integer.parseInt(br.readLine());

        for(int i = 0 ; i <= vertex ; i++) list.add(new ArrayList<>());
        // 단방향 인접리스트 생성
        for(int i = 0 ; i < edge ; i++){
            st = new StringTokenizer(br.readLine());
            int sVertex = Integer.parseInt(st.nextToken());
            int eVertex = Integer.parseInt(st.nextToken());
            int cost = Integer.parseInt(st.nextToken());
            list.get(sVertex).add(new Edge(eVertex , cost));
        }

        // 시작점 (0번)과 연결된 모든 노드들 탐색
        bfs(stanVertex , vertex);

        StringBuilder resultString = new StringBuilder();
        for(int i = 1 ; i < result.length; i++){
            if(result[i] == Integer.MAX_VALUE) resultString.append("INF\n");
            else resultString.append(result[i]).append("\n");
        }
        System.out.println(resultString.toString());
    }

    public static void bfs(int stanVertex , int vertexSize){
        PriorityQueue<Edge> pq = new PriorityQueue<>();
        result[stanVertex] = 0;
        pq.offer(new Edge(stanVertex , 0));

        while(!pq.isEmpty()){
            Edge now = pq.poll();
            int nowVertex = now.vertex;
            int nowCost = now.cost;
            if(nowCost > result[nowVertex]) continue;
            for(Edge edges : list.get(nowVertex)){
                if(result[edges.vertex] > nowCost + edges.cost){
                    result[edges.vertex] = nowCost + edges.cost;
                    pq.offer(new Edge(edges.vertex , nowCost + edges.cost));
                }
            }
        }
    }
}
```

# **`[백준] BFS` [내리막 길](https://www.acmicpc.net/problem/1520)** 📝

## **<span class="text-red-300">메모리 초과</span>**

```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.ArrayDeque;
import java.util.Comparator;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.StringTokenizer;

class Move implements Comparable<Move>{
	int x , y , cost;

	public Move(int x, int y, int cost) {
		this.x = x;
		this.y = y;
		this.cost = cost;
	}

	@Override
	public int compareTo(Move o) {
		return this.cost - o.cost;
	}
}

class Main {

	static int[][] moves4Dir = { {-1 , 0} , {0 , 1} , {1 , 0} , {0 , -1} };
	static int row , col;
	static int[][] map;
	static int count = 0;
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

		StringTokenizer st = new StringTokenizer(br.readLine());
		
		row = Integer.parseInt(st.nextToken());
		col = Integer.parseInt(st.nextToken());
		
		map = new int[row][col];
		
		for(int i = 0 ; i < row ; i++) {
			st = new StringTokenizer(br.readLine());
			for(int j = 0 ; j < col ; j++){
				map[i][j] = Integer.parseInt(st.nextToken());
			}
		}
		
		bfs();
		
		bw.append(String.valueOf(count));
		bw.flush();
		bw.close();
		br.close();
	}
	
	public static void bfs() {
		PriorityQueue<Move> q = new PriorityQueue<>();
		q.offer(new Move(0 , 0 , map[0][0]));
		
		while(!q.isEmpty()) {
			Move now = q.poll();
			if(now.x == row - 1 && now.y == col - 1) {
				count++;
				continue;
			}
			for(int[] move : moves4Dir) {
				int moveX = now.x + move[0];
				int moveY = now.y + move[1];
				if(!isOutOfRange(moveX , moveY) && map[moveX][moveY] < now.cost) {
					q.offer(new Move(moveX , moveY , map[moveX][moveY]));
				}
			}
		}
	}
	
	public static boolean isOutOfRange(int x , int y) {
		if(x < 0 || x >= row || y < 0 || y >= col) {
			return true;
		}
		return false;
	}
}
```

## **<span class="text-green-300">해결</span>**

- 우선순위 큐에서 나오는 기준을 `cost`가 높은 순으로 나오게 한다.
  - **이미 낮은 곳이 먼저 들려버린다면 갈 수 있는 경우의 수를 모두 확인할 수 없다**
- **`count[][]`를 둬서 처음 가는 지역에만 `Queue`에 넣고 기존에 들렸던 곳인데 `cost`가 낮다면 현재 위치에 담겨있는 경우의 수를 더 해준다.**

```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.PriorityQueue;
import java.util.StringTokenizer;

class Move implements Comparable<Move>{
	int x , y , cost;

	public Move(int x, int y, int cost) {
		this.x = x;
		this.y = y;
		this.cost = cost;
	}

	@Override
	public int compareTo(Move o) {
		return o.cost - this.cost;
	}
}

class Main {

	static int[][] moves4Dir = { {-1 , 0} , {0 , 1} , {1 , 0} , {0 , -1} };
	static int row , col;
	static int[][] map;
	static int[][] count;
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

		StringTokenizer st = new StringTokenizer(br.readLine());
		
		row = Integer.parseInt(st.nextToken());
		col = Integer.parseInt(st.nextToken());
		
		map = new int[row][col];
		count = new int[row][col];
		
		for(int i = 0 ; i < row ; i++) {
			st = new StringTokenizer(br.readLine());
			for(int j = 0 ; j < col ; j++){
				map[i][j] = Integer.parseInt(st.nextToken());
			}
		}
		
		bfs();
		
		bw.append(String.valueOf(count[row - 1][col - 1]));
		bw.flush();
		bw.close();
		br.close();
	}
	
	public static void bfs() {
		PriorityQueue<Move> q = new PriorityQueue<>();
		q.offer(new Move(0 , 0 , map[0][0]));
		count[0][0] = 1; 
		
		while(!q.isEmpty()) {
			Move now = q.poll();
			for(int[] move : moves4Dir) {
				int moveX = now.x + move[0];
				int moveY = now.y + move[1];
				if(!isOutOfRange(moveX , moveY) && map[moveX][moveY] < map[now.x][now.y]) {
					if(count[moveX][moveY] == 0) {
						q.offer(new Move(moveX , moveY , map[moveX][moveY]));
					}
					count[moveX][moveY] += count[now.x][now.y];
				}
			}
		}
	}
	
	public static boolean isOutOfRange(int x , int y) {
		if(x < 0 || x >= row || y < 0 || y >= col) {
			return true;
		}
		return false;
	}
}
```

***

[1주차]: https://github.com/jdalma/Algorithm-Study/tree/main/%5BWeek1%20-%20BFS%26DFS%5D/%EC%A0%95%ED%98%84%EC%A4%80

# **[Algorithm Study 1주차 - `BFS&DFS`][1주차]**

## [알고리즘 수업 - 깊이 우선 탐색 1](https://github.com/jdalma/Algorithm-Study/tree/main/%5BWeek1%20-%20BFS%26DFS%5D/%EC%A0%95%ED%98%84%EC%A4%80/24479.java)
## [알고리즘 수업 - 깊이 우선 탐색 3](https://github.com/jdalma/Algorithm-Study/tree/main/%5BWeek1%20-%20BFS%26DFS%5D/%EC%A0%95%ED%98%84%EC%A4%80/24481.java)
## [알고리즘 수업 - 너비 우선 탐색 1](https://github.com/jdalma/Algorithm-Study/tree/main/%5BWeek1%20-%20BFS%26DFS%5D/%EC%A0%95%ED%98%84%EC%A4%80/24444.java)
## [침투](https://github.com/jdalma/Algorithm-Study/tree/main/%5BWeek1%20-%20BFS%26DFS%5D/%EC%A0%95%ED%98%84%EC%A4%80/13565.java)
## [영역 구하기](https://github.com/jdalma/Algorithm-Study/tree/main/%5BWeek1%20-%20BFS%26DFS%5D/%EC%A0%95%ED%98%84%EC%A4%80/2583.java)
## [현명한 나이트](https://github.com/jdalma/Algorithm-Study/tree/main/%5BWeek1%20-%20BFS%26DFS%5D/%EC%A0%95%ED%98%84%EC%A4%80/18404.java)
## [빙산](https://github.com/jdalma/Algorithm-Study/tree/main/%5BWeek1%20-%20BFS%26DFS%5D/%EC%A0%95%ED%98%84%EC%A4%80/2573.java)
## [벽 부수고 이동하기](https://github.com/jdalma/Algorithm-Study/tree/main/%5BWeek1%20-%20BFS%26DFS%5D/%EC%A0%95%ED%98%84%EC%A4%80/2206.java)
## [열쇠](https://github.com/jdalma/Algorithm-Study/tree/main/%5BWeek1%20-%20BFS%26DFS%5D/%EC%A0%95%ED%98%84%EC%A4%80/9328.java)
## [Metroidvania Extreme](https://github.com/jdalma/Algorithm-Study/tree/main/%5BWeek1%20-%20BFS%26DFS%5D/%EC%A0%95%ED%98%84%EC%A4%80/20130.java)
## [집배원 한상덕](https://www.acmicpc.net/problem/2842) ❌

***

[2주차]: https://github.com/PowerAlgorithm/Algorithm-Study/tree/main/%5BWeek2%20-%20UnionFind%26Kruskal%5D

# **[Algorithm Study 2주차 - `UnionFind & Kruskal`][2주차]**

## Count Circle Groups
## 중량제한
## MST 게임
## 전력난
## 퍼레이드
## 학교 탐방하기
## 회의준비
## 공항
## 통신망 분할
## 백조의 호수
## 유럽여행


***

# **`[백준] 그래프 탐색` [배열에서 이동](https://www.acmicpc.net/problem/1981)** ⭐

```java

```

***

# **`[Leetcode] LCS` [Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)** ⭐

```java

```