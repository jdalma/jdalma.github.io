---
layout: default
title: 2022ë…„ 4ì›”
nav_order: 12
parent: ğŸ¢ ì•Œê³ ë¦¬ì¦˜
---
## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

# **`[ë°±ì¤€]` [ì†Œìˆ˜](https://www.acmicpc.net/problem/2581)**

```java
import java.io.*;

class Main{
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        int M = Integer.parseInt(br.readLine());
        int N = Integer.parseInt(br.readLine());

        int sum = 0;
        int min = Integer.MAX_VALUE;

        mainLoop:
        for(int i = M ; i <= N ; i++){
            if(i == 1) continue;
            for(int j = 2 ; j < i ; j++){
                if(i % j == 0) {
                    continue mainLoop;
                }
            }
            sum += i;
            min = Math.min(min , i);
        }

        String result = sum == 0 ? "-1" : sum + "\n" + min;

        bw.append(result);
        bw.flush();
        bw.close();
        br.close();
    }
}
```

# **`[ë°±ì¤€] BFS` [ì–‘ í•œë§ˆë¦¬.. ì–‘ ë‘ë§ˆë¦¬..](https://www.acmicpc.net/problem/11123)**

```java
import java.io.*;
import java.util.ArrayDeque;
import java.util.Queue;
import java.util.StringTokenizer;

class Main{
    static int[][] moves4dir = { {-1 , 0} , {0 , 1} , {1 , 0} , {0 , -1} };
    static int row , col;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        int testCase = Integer.parseInt(br.readLine());

        for(int test = 0 ; test < testCase ; test++){

            StringTokenizer st = new StringTokenizer(br.readLine());
            row = Integer.parseInt(st.nextToken());
            col = Integer.parseInt(st.nextToken());

            char[][] map = new char[row][col];
            boolean[][] visited = new boolean[row][col];

            for(int i = 0 ; i < row ; i++){
                map[i] = br.readLine().toCharArray();
            }

            int chunkCount = 0;
            for(int i = 0 ; i < row ; i++){
                for(int j = 0 ; j < col ; j++){
                    if(map[i][j] == '#'){
                        // ì–‘ ë¬´ë¦¬ ë°©ë¬¸ ì²˜ë¦¬
                        check(i , j , map);
                        chunkCount++;
                    }
                }
            }

            bw.append(chunkCount + "\n");
        }

        bw.flush();
        bw.close();
        br.close();
    }

    public static void check(int x , int y , char[][] map){
        Queue<int[]> q = new ArrayDeque<>();
        q.offer(new int[]{ x , y});
        map[x][y] = '.';

        while(!q.isEmpty()){
            int[] now = q.poll();
            for(int[] pos : moves4dir){
                int moveX = now[0] + pos[0];
                int moveY = now[1] + pos[1];
                if(moveX >= 0 && moveX < row && moveY >= 0 && moveY < col){
                    if(map[moveX][moveY] == '#'){
                        q.offer(new int[] {moveX , moveY});
                        map[moveX][moveY] = '.';
                    }
                }
            }
        }
    }
}

```

# **`[ë°±ì¤€] Dijkstra` [íƒë°°ë°°ì†¡](https://www.acmicpc.net/problem/5972)**

```java
import java.io.*;
import java.util.*;

class Road implements Comparable<Road> {
    int road;
    int cost;

    public Road(int road, int cost) {
        this.road = road;
        this.cost = cost;
    }

    @Override
    public int compareTo(Road o) {
        return this.cost - o.cost;
    }
}

class Main {
    static int node, edge;
    static List<List<Road>> roads = new ArrayList<>();
    static int[] costs;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        StringTokenizer st = new StringTokenizer(br.readLine());

        node = Integer.parseInt(st.nextToken());
        edge = Integer.parseInt(st.nextToken());

        costs = new int[node + 1];

        // ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ , ë¹„ìš© ë°°ì—´ ì´ˆê¸°í™”
        for (int i = 0; i <= node; i++) {
            roads.add(new ArrayList<>());
            costs[i] = Integer.MAX_VALUE;
        }

        for (int i = 0; i < edge; i++) {
            st = new StringTokenizer(br.readLine());
            int start = Integer.parseInt(st.nextToken());
            int end = Integer.parseInt(st.nextToken());
            int cost = Integer.parseInt(st.nextToken());
            // ì–‘ë°©í–¥ ì €ì¥
            roads.get(start).add(new Road(end, cost));
            roads.get(end).add(new Road(start, cost));
        }

        dijkstra();

        bw.append(String.valueOf(costs[node]));
        bw.flush();
        bw.close();
        br.close();
    }

    public static void dijkstra() {
        // ìš°ì„ ìˆœìœ„ í ì‚¬ìš©
        // costê°€ ì‘ì€ ê²ƒ ë¶€í„° poll()
        PriorityQueue<Road> pq = new PriorityQueue<>();
        pq.offer(new Road(1, 0));
        costs[1] = 0;

        while (!pq.isEmpty()) {
            Road now = pq.poll();
            if (costs[now.road] < now.cost)
                continue;
            for (Road nearRoad : roads.get(now.road)) {
                int sumCost = now.cost + nearRoad.cost;
                // ë¹„ìš©ì„ ëˆ„ì í•˜ë©° ë‚˜ì•„ê°
                // í˜„ì¬ì˜ ëˆ„ì í•  ë¹„ìš©ì´ costsë°°ì—´ì˜ ë¹„ìš©ë³´ë‹¤ ì‘ë‹¤ë©´ íì— ë‹´ëŠ”ë‹¤
                if (costs[nearRoad.road] > sumCost) {
                    costs[nearRoad.road] = sumCost;
                    pq.offer(new Road(nearRoad.road, sumCost));
                }
            }
        }
    }
}
```

# **`[ë°±ì¤€] Implementation` [ë‚šì‹œì™•](https://www.acmicpc.net/problem/17143)**

```java
import java.io.*;
import java.util.*;

class Shark {
    int s, d, z;

    public Shark(int s, int d, int z) {
        this.s = s;
        this.d = d;
        this.z = z;
    }

    @Override
    public String toString() {
        return "Shark{" +
                "s=" + s +
                ", d=" + d +
                ", z=" + z +
                '}';
    }
}

class Main {
    static int row, col, count, result = 0;
    static Shark[][] map;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        StringTokenizer st = new StringTokenizer(br.readLine());

        row = Integer.parseInt(st.nextToken());
        col = Integer.parseInt(st.nextToken());
        count = Integer.parseInt(st.nextToken());

        if (count > 0) {
            map = new Shark[row][col];

            for (int i = 0; i < count; i++) {
                st = new StringTokenizer(br.readLine());
                int x = Integer.parseInt(st.nextToken()) - 1;
                int y = Integer.parseInt(st.nextToken()) - 1;
                int s = Integer.parseInt(st.nextToken());
                int d = Integer.parseInt(st.nextToken());
                int z = Integer.parseInt(st.nextToken());
                map[x][y] = new Shark(s, d, z);
            }

            for (int people = 0; people < col; people++) {
                findShark(people);
                timePasses();
            }
        }

        bw.append(String.valueOf(result));
        bw.flush();
        bw.close();
        br.close();
    }

    public static void findShark(int y) {
        for (int x = 0; x < row; x++) {
            if (map[x][y] != null) {
                // ìƒì–´ì˜ ë¬´ê²Œ ëˆ„ì 
                result += map[x][y].z;
                map[x][y] = null;
                break;
            }
        }
    }

    public static void timePasses() {

        // ìƒì–´ê°€ ë‹¤ ì›€ì§ì´ê³  ë‚˜ì„œ ìƒì–´ê°€ ì¤‘ì²©ë˜ì—ˆëŠ”ì§€ íŒë‹¨í•´ì•¼ í•˜ë‹ˆ ì„ì‹œ ë°°ì—´ ìƒì„±
        Shark[][] tmp = new Shark[row][col];

        for (int x = 0; x < row; x++) {
            for (int y = 0; y < col; y++) {
                if (map[x][y] != null) {
                    move(x, y, map[x][y], tmp);
                }
            }
        }
        // ì„ì‹œë°°ì—´ì— ì‚´ì•„ ìˆëŠ” ìƒì–´ë§Œ ì–•ì€ ë³µì‚¬í•œë‹¤.
        copy(tmp);
    }

    public static void copy(Shark[][] tmp) {
        for (int x = 0; x < row; x++) {
            for (int y = 0; y < col; y++) {
                map[x][y] = tmp[x][y];
            }
        }
    }

    // 1
    // 4 3
    // 2
    public static void move(int x, int y, Shark shark, Shark[][] tmp) {
        int dir = shark.d;
        int distance = shark.s;

        int moveX = x;
        int moveY = y;

        // ì›€ì§ì¼ ê±°ë¦¬ê°€ 0ë³´ë‹¤ í´ ë•Œë§Œ ì›€ì§ì¼ ìœ„ì¹˜ë¥¼ êµ¬í•œë‹¤.
        if (distance > 0) {
            if (dir == 1) {
                moveX = move(row, x, distance * -1, shark);
            } else if (dir == 2) {
                moveX = move(row, x, distance, shark);
            } else if (dir == 3) {
                moveY = move(col, y, distance, shark);
            } else {
                moveY = move(col, y, distance * -1, shark);
            }
        }

        if (tmp[moveX][moveY] != null && tmp[moveX][moveY].z > shark.z) {
            return;
        } else {
            tmp[moveX][moveY] = shark;
        }
    }

    public static int move(int range, int pos, int distance, Shark shark) {
        int count = Math.abs(distance);
        for (int i = 1; i <= count; i++) {
            if (distance > 0) {
                ++pos;
                if (range == pos) {
                    distance *= -1;
                    pos -= 2;
                    // ìƒì–´ê°€ ë˜ëŒì•„ê°€ë©´ ë°©í–¥ì„ ë°”ê¿”ì¤€ë‹¤.
                    shark.d = shark.d == 2 ? 1 : 4;
                }
            } else {
                --pos;
                if (-1 == pos) {
                    distance *= -1;
                    pos += 2;
                    // ìƒì–´ê°€ ë˜ëŒì•„ê°€ë©´ ë°©í–¥ì„ ë°”ê¿”ì¤€ë‹¤.
                    shark.d = shark.d == 1 ? 2 : 3;
                }
            }
        }
        return pos;
    }

    public static void print(Shark[][] m) {
        for (int x = 0; x < row; x++) {
            for (int y = 0; y < col; y++) {
                if (m[x][y] != null) {
                    System.out.println((x + 1) + " " + (y + 1) + " " + m[x][y]);
                }
            }
        }
    }
}
```

***

# **`[í”„ë¡œê·¸ë˜ë¨¸ìŠ¤] í•´ì‹œ` [ìœ„ì¥](https://programmers.co.kr/learn/courses/30/lessons/42578)**

```java
import java.util.Map;
import java.util.HashMap;
import java.util.Set;

class Solution {
    public int solution(String[][] clothes) {
        Map<String , Integer> map = new HashMap<>();

        for(int i = 0 ; i < clothes.length ; i++){
            String key = clothes[i][1];
            int value = map.getOrDefault(key , 0);
            map.put(key , value + 1);
        }

        int sum = 1;
        int multi = 0;
        Set<String> keySet = map.keySet();
        for(String key : keySet){
            int value = map.get(key);
            // í•´ë‹¹ ì˜ìƒì„ ì…ì§€ ì•Šì„ ê²½ìš°ë„ ìˆìœ¼ë‹ˆ + 1
            sum *= (value + 1);
        }

        // ì•„ë¬´ê²ƒë„ ì•ˆì…ì„ ê²½ìš°ëŠ” ëº€ë‹¤ - 1
        return sum - 1;
    }
}
```

***

# **`[í”„ë¡œê·¸ë˜ë¨¸ìŠ¤] BFS` [ê²Œì„ ë§µ ìµœë‹¨ê±°ë¦¬](https://programmers.co.kr/learn/courses/30/lessons/1844)**

```java
import java.util.Queue;
import java.util.ArrayDeque;

class Solution {
    int row , col;
    int[][] moves4dir = { {-1 , 0} , {0 , 1} , {1 , 0} , {0 , -1} };

    public int solution(int[][] maps) {
        row = maps.length;
        col = maps[0].length;

        int answer = Integer.MAX_VALUE;
        
        boolean[][] visited = new boolean[row][col];
        Queue<int[]> q = new ArrayDeque<>();

        // int[x , y , count]
        q.offer(new int[] {0 , 0 , 1});
        visited[0][0] = true;

        while(!q.isEmpty()){
            int[] now = q.poll();
            if(now[0] == row - 1 && now[1] == col - 1){
                answer = Math.min(answer , now[2]);
                continue;
            }
            for(int[] move : moves4dir){
                int moveX = now[0] + move[0];
                int moveY = now[1] + move[1];
                if(!isOutOfRange(moveX , moveY) && !visited[moveX][moveY] && maps[moveX][moveY] == 1){
                    visited[moveX][moveY] = true;
                    q.offer(new int[] {moveX , moveY , now[2] + 1});
                }
            }
        }

        return answer == Integer.MAX_VALUE ? -1 : answer;
    }

    public boolean isOutOfRange(int x , int y){
        if(x < 0 || x >= row || y < 0 || y >= col) return true;
        return false;
    }
}
```

***

# **`[í”„ë¡œê·¸ë˜ë¨¸ìŠ¤]` [ì •ìˆ˜ ì‚¼ê°í˜•](https://programmers.co.kr/learn/courses/30/lessons/43105)** âŒ

## `DFS` ì‹œê°„ì´ˆê³¼

```java
class Solution {
    int row , col;
    int[][] map;
    public int solution(int[][] triangle) {
        map = triangle;
        row = triangle.length;
        col = triangle[0].length;

        return DFS(0, 0, 0);
    }

    public int DFS(int x , int y , int max){
        if(x >= row) return max;

        return Math.max(DFS(x + 1 , y , max + map[x][y]) , DFS(x + 1 , y + 1 , max + map[x][y]));
    }    
// ì •í™•ì„±: 50.0
// íš¨ìœ¨ì„±: 0.0
// í•©ê³„: 50.0 / 100.0
// DP ë„ˆë¬´ ì–´ë ¤ì›Œìš”
}
```

## `DP - TopDown`

```java
class Solution {
    public int solution(int[][] triangle) {
        int answer = 0;
        
        for(int i = 1 ; i < triangle.length ; i++){
            for(int j = 0 ; j < triangle[i].length ; j++){
                
                if(j == 0){
                    triangle[i][j] = triangle[i][j] + triangle[i - 1][j];
                }
                else if(i == j){
                    triangle[i][j] = triangle[i][j] + triangle[i - 1][j - 1];
                }
                else{
                    int left = triangle[i][j] + triangle[i - 1][j];
                    int right = triangle[i][j] + triangle[i - 1][j - 1];
                    triangle[i][j] = Math.max(left , right);                    
                }
                answer = Math.max(answer , triangle[i][j]);
            }
        }
        
        return answer;
    }
}
```

## `DP - Bottom Up`

```java
class Solution {
    public int solution(int[][] triangle) {
        for(int i = triangle.length - 2 ; i >= 0 ; i--){
            for(int j = 0 ; j < triangle[i].length ; j++){
                int left = triangle[i][j] + triangle[i + 1][j];
                int right = triangle[i][j] + triangle[i + 1][j + 1];
                triangle[i][j] = Math.max(left , right);
            }
        }
        
        return triangle[0][0];
    }
}
```

***

# **`[í”„ë¡œê·¸ë˜ë¨¸ìŠ¤]` [ì˜¬ë°”ë¥¸ ê´„í˜¸ì˜ ê°œìˆ˜](https://programmers.co.kr/learn/courses/30/lessons/12929)** ğŸ“

```java
import java.util.*;

class P {
    int open , close;
    public P(int open , int close){
        this.open = open;
        this.close = close;
    }
}

class Solution {
    
    public int solution(int n) {
        int result = 0;    
        Deque<P> stack = new ArrayDeque<P>();
        stack.push(new P(0 , 0));
        while(!stack.isEmpty()){
            P p = stack.pop();
            
            if(p.open > n) continue;
            if(p.open < p.close) continue;
            if(p.open + p.close == n * 2) {
                result++;
                continue;
            };
            
            stack.push(new P(p.open + 1 , p.close));
            stack.push(new P(p.open , p.close + 1));
        }
        
        return result;
    }
}
```

***


# **`[ë°±ì¤€] String` [ROT13](https://www.acmicpc.net/problem/4446)**

```java
import java.io.*;
import java.util.ArrayList;
import java.util.List;

class Main {
    static char[] lowerVowel = { 'a', 'i', 'y', 'e', 'o', 'u' };
    static char[] lowerConsonant = { 'b', 'k', 'x', 'z', 'n', 'h', 'd', 'c', 'w', 'g', 'p', 'v', 'j', 'q', 't', 's',
            'r', 'l', 'm', 'f' };
    static char[] upperVowel = { 'A', 'I', 'Y', 'E', 'O', 'U' };
    static char[] upperConsonant = { 'B', 'K', 'X', 'Z', 'N', 'H', 'D', 'C', 'W', 'G', 'P', 'V', 'J', 'Q', 'T', 'S',
            'R', 'L', 'M', 'F' };

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        String line;
        while ((line = br.readLine()) != null) {
            StringBuilder result = new StringBuilder();
            char[] input = line.toCharArray();
            for (char ch : input) {
                char after = ' ';
                if (Character.isAlphabetic(ch)) {
                    // ëª¨ìŒ
                    if (isVowel(ch)) {
                        if (Character.isUpperCase(ch)) {
                            after = convert(upperVowel, ch, 3);
                        } else {
                            after = convert(lowerVowel, ch, 3);
                        }
                    }
                    // ììŒ
                    else {
                        if (Character.isUpperCase(ch)) {
                            after = convert(upperConsonant, ch, 10);
                        } else {
                            after = convert(lowerConsonant, ch, 10);
                        }
                    }
                } else
                    after = ch;
                result.append(after);
            }
            result.append("\n");
            bw.append(result.toString());
            bw.flush();
        }
        bw.close();
        br.close();
    }

    public static boolean isVowel(char ch) {
        // ëª¨ìŒì´ë¼ë©´ true
        char c = Character.toLowerCase(ch);
        for (int i = 0; i < lowerVowel.length; i++) {
            if (c == lowerVowel[i])
                return true;
        }
        return false;
    }

    public static char convert(char[] arr, char ch, int plusIndex) {
        int index = 0;
        for (int i = 0; i < arr.length; i++) {
            if (ch == arr[i]) {
                index = i;
                break;
            }
        }

        int sumIndex = index + plusIndex;
        if (sumIndex > arr.length - 1) {
            sumIndex = sumIndex - arr.length;
        }

        return arr[sumIndex];
    }
}
```

# **`[ë°±ì¤€] Dijkstra` [ìµœë‹¨ê²½ë¡œ](https://www.acmicpc.net/problem/1753)**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

class Edge implements Comparable<Edge>{
    int vertex;
    int cost;
    public Edge(int vertex, int cost) {
        this.vertex = vertex;
        this.cost = cost;
    }
    @Override
    public int compareTo(Edge o) {
        return cost - o.cost;
    }
}

class Main {
    static int[] result;
    static List<ArrayList<Edge>> list = new ArrayList<>();
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        int vertex = Integer.parseInt(st.nextToken());
        int edge = Integer.parseInt(st.nextToken());

        
        result = new int[vertex + 1];
        Arrays.fill(result , Integer.MAX_VALUE);

        int stanVertex = Integer.parseInt(br.readLine());

        for(int i = 0 ; i <= vertex ; i++) list.add(new ArrayList<>());
        // ë‹¨ë°©í–¥ ì¸ì ‘ë¦¬ìŠ¤íŠ¸ ìƒì„±
        for(int i = 0 ; i < edge ; i++){
            st = new StringTokenizer(br.readLine());
            int sVertex = Integer.parseInt(st.nextToken());
            int eVertex = Integer.parseInt(st.nextToken());
            int cost = Integer.parseInt(st.nextToken());
            list.get(sVertex).add(new Edge(eVertex , cost));
        }

        // ì‹œì‘ì  (0ë²ˆ)ê³¼ ì—°ê²°ëœ ëª¨ë“  ë…¸ë“œë“¤ íƒìƒ‰
        bfs(stanVertex , vertex);

        StringBuilder resultString = new StringBuilder();
        for(int i = 1 ; i < result.length; i++){
            if(result[i] == Integer.MAX_VALUE) resultString.append("INF\n");
            else resultString.append(result[i]).append("\n");
        }
        System.out.println(resultString.toString());
    }

    public static void bfs(int stanVertex , int vertexSize){
        PriorityQueue<Edge> pq = new PriorityQueue<>();
        result[stanVertex] = 0;
        pq.offer(new Edge(stanVertex , 0));

        while(!pq.isEmpty()){
            Edge now = pq.poll();
            int nowVertex = now.vertex;
            int nowCost = now.cost;
            if(nowCost > result[nowVertex]) continue;
            for(Edge edges : list.get(nowVertex)){
                if(result[edges.vertex] > nowCost + edges.cost){
                    result[edges.vertex] = nowCost + edges.cost;
                    pq.offer(new Edge(edges.vertex , nowCost + edges.cost));
                }
            }
        }
    }
}
```

# **`[ë°±ì¤€] BFS` [ë‚´ë¦¬ë§‰ ê¸¸](https://www.acmicpc.net/problem/1520)** ğŸ“

## **<span class="text-red-300">ë©”ëª¨ë¦¬ ì´ˆê³¼</span>**

```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.ArrayDeque;
import java.util.Comparator;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.StringTokenizer;

class Move implements Comparable<Move>{
	int x , y , cost;

	public Move(int x, int y, int cost) {
		this.x = x;
		this.y = y;
		this.cost = cost;
	}

	@Override
	public int compareTo(Move o) {
		return this.cost - o.cost;
	}
}

class Main {

	static int[][] moves4Dir = { {-1 , 0} , {0 , 1} , {1 , 0} , {0 , -1} };
	static int row , col;
	static int[][] map;
	static int count = 0;
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

		StringTokenizer st = new StringTokenizer(br.readLine());
		
		row = Integer.parseInt(st.nextToken());
		col = Integer.parseInt(st.nextToken());
		
		map = new int[row][col];
		
		for(int i = 0 ; i < row ; i++) {
			st = new StringTokenizer(br.readLine());
			for(int j = 0 ; j < col ; j++){
				map[i][j] = Integer.parseInt(st.nextToken());
			}
		}
		
		bfs();
		
		bw.append(String.valueOf(count));
		bw.flush();
		bw.close();
		br.close();
	}
	
	public static void bfs() {
		PriorityQueue<Move> q = new PriorityQueue<>();
		q.offer(new Move(0 , 0 , map[0][0]));
		
		while(!q.isEmpty()) {
			Move now = q.poll();
			if(now.x == row - 1 && now.y == col - 1) {
				count++;
				continue;
			}
			for(int[] move : moves4Dir) {
				int moveX = now.x + move[0];
				int moveY = now.y + move[1];
				if(!isOutOfRange(moveX , moveY) && map[moveX][moveY] < now.cost) {
					q.offer(new Move(moveX , moveY , map[moveX][moveY]));
				}
			}
		}
	}
	
	public static boolean isOutOfRange(int x , int y) {
		if(x < 0 || x >= row || y < 0 || y >= col) {
			return true;
		}
		return false;
	}
}
```

## **<span class="text-green-300">í•´ê²°</span>**

- ìš°ì„ ìˆœìœ„ íì—ì„œ ë‚˜ì˜¤ëŠ” ê¸°ì¤€ì„ `cost`ê°€ ë†’ì€ ìˆœìœ¼ë¡œ ë‚˜ì˜¤ê²Œ í•œë‹¤.
  - **ì´ë¯¸ ë‚®ì€ ê³³ì´ ë¨¼ì € ë“¤ë ¤ë²„ë¦°ë‹¤ë©´ ê°ˆ ìˆ˜ ìˆëŠ” ê²½ìš°ì˜ ìˆ˜ë¥¼ ëª¨ë‘ í™•ì¸í•  ìˆ˜ ì—†ë‹¤**
- **`count[][]`ë¥¼ ë‘¬ì„œ ì²˜ìŒ ê°€ëŠ” ì§€ì—­ì—ë§Œ `Queue`ì— ë„£ê³  ê¸°ì¡´ì— ë“¤ë ¸ë˜ ê³³ì¸ë° `cost`ê°€ ë‚®ë‹¤ë©´ í˜„ì¬ ìœ„ì¹˜ì— ë‹´ê²¨ìˆëŠ” ê²½ìš°ì˜ ìˆ˜ë¥¼ ë” í•´ì¤€ë‹¤.**

```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.PriorityQueue;
import java.util.StringTokenizer;

class Move implements Comparable<Move>{
	int x , y , cost;

	public Move(int x, int y, int cost) {
		this.x = x;
		this.y = y;
		this.cost = cost;
	}

	@Override
	public int compareTo(Move o) {
		return o.cost - this.cost;
	}
}

class Main {

	static int[][] moves4Dir = { {-1 , 0} , {0 , 1} , {1 , 0} , {0 , -1} };
	static int row , col;
	static int[][] map;
	static int[][] count;
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

		StringTokenizer st = new StringTokenizer(br.readLine());
		
		row = Integer.parseInt(st.nextToken());
		col = Integer.parseInt(st.nextToken());
		
		map = new int[row][col];
		count = new int[row][col];
		
		for(int i = 0 ; i < row ; i++) {
			st = new StringTokenizer(br.readLine());
			for(int j = 0 ; j < col ; j++){
				map[i][j] = Integer.parseInt(st.nextToken());
			}
		}
		
		bfs();
		
		bw.append(String.valueOf(count[row - 1][col - 1]));
		bw.flush();
		bw.close();
		br.close();
	}
	
	public static void bfs() {
		PriorityQueue<Move> q = new PriorityQueue<>();
		q.offer(new Move(0 , 0 , map[0][0]));
		count[0][0] = 1; 
		
		while(!q.isEmpty()) {
			Move now = q.poll();
			for(int[] move : moves4Dir) {
				int moveX = now.x + move[0];
				int moveY = now.y + move[1];
				if(!isOutOfRange(moveX , moveY) && map[moveX][moveY] < map[now.x][now.y]) {
					if(count[moveX][moveY] == 0) {
						q.offer(new Move(moveX , moveY , map[moveX][moveY]));
					}
					count[moveX][moveY] += count[now.x][now.y];
				}
			}
		}
	}
	
	public static boolean isOutOfRange(int x , int y) {
		if(x < 0 || x >= row || y < 0 || y >= col) {
			return true;
		}
		return false;
	}
}
```

***

[1ì£¼ì°¨]: https://github.com/jdalma/Algorithm-Study/tree/main/%5BWeek1%20-%20BFS%26DFS%5D/%EC%A0%95%ED%98%84%EC%A4%80

# **[Algorithm Study 1ì£¼ì°¨ - `BFS&DFS`][1ì£¼ì°¨]**

## [ì•Œê³ ë¦¬ì¦˜ ìˆ˜ì—… - ê¹Šì´ ìš°ì„  íƒìƒ‰ 1](https://github.com/jdalma/Algorithm-Study/tree/main/%5BWeek1%20-%20BFS%26DFS%5D/%EC%A0%95%ED%98%84%EC%A4%80/24479.java)
## [ì•Œê³ ë¦¬ì¦˜ ìˆ˜ì—… - ê¹Šì´ ìš°ì„  íƒìƒ‰ 3](https://github.com/jdalma/Algorithm-Study/tree/main/%5BWeek1%20-%20BFS%26DFS%5D/%EC%A0%95%ED%98%84%EC%A4%80/24481.java)
## [ì•Œê³ ë¦¬ì¦˜ ìˆ˜ì—… - ë„ˆë¹„ ìš°ì„  íƒìƒ‰ 1](https://github.com/jdalma/Algorithm-Study/tree/main/%5BWeek1%20-%20BFS%26DFS%5D/%EC%A0%95%ED%98%84%EC%A4%80/24444.java)
## [ì¹¨íˆ¬](https://github.com/jdalma/Algorithm-Study/tree/main/%5BWeek1%20-%20BFS%26DFS%5D/%EC%A0%95%ED%98%84%EC%A4%80/13565.java)
## [ì˜ì—­ êµ¬í•˜ê¸°](https://github.com/jdalma/Algorithm-Study/tree/main/%5BWeek1%20-%20BFS%26DFS%5D/%EC%A0%95%ED%98%84%EC%A4%80/2583.java)
## [í˜„ëª…í•œ ë‚˜ì´íŠ¸](https://github.com/jdalma/Algorithm-Study/tree/main/%5BWeek1%20-%20BFS%26DFS%5D/%EC%A0%95%ED%98%84%EC%A4%80/18404.java)
## [ë¹™ì‚°](https://github.com/jdalma/Algorithm-Study/tree/main/%5BWeek1%20-%20BFS%26DFS%5D/%EC%A0%95%ED%98%84%EC%A4%80/2573.java)
## [ë²½ ë¶€ìˆ˜ê³  ì´ë™í•˜ê¸°](https://github.com/jdalma/Algorithm-Study/tree/main/%5BWeek1%20-%20BFS%26DFS%5D/%EC%A0%95%ED%98%84%EC%A4%80/2206.java)
## [ì—´ì‡ ](https://github.com/jdalma/Algorithm-Study/tree/main/%5BWeek1%20-%20BFS%26DFS%5D/%EC%A0%95%ED%98%84%EC%A4%80/9328.java)
## [Metroidvania Extreme](https://github.com/jdalma/Algorithm-Study/tree/main/%5BWeek1%20-%20BFS%26DFS%5D/%EC%A0%95%ED%98%84%EC%A4%80/20130.java)
## [ì§‘ë°°ì› í•œìƒë•](https://www.acmicpc.net/problem/2842) âŒ

***

[2ì£¼ì°¨]: https://github.com/PowerAlgorithm/Algorithm-Study/tree/main/%5BWeek2%20-%20UnionFind%26Kruskal%5D

# **[Algorithm Study 2ì£¼ì°¨ - `UnionFind & Kruskal`][2ì£¼ì°¨]**

## Count Circle Groups
## ì¤‘ëŸ‰ì œí•œ
## MST ê²Œì„
## ì „ë ¥ë‚œ
## í¼ë ˆì´ë“œ
## í•™êµ íƒë°©í•˜ê¸°
## íšŒì˜ì¤€ë¹„
## ê³µí•­
## í†µì‹ ë§ ë¶„í• 
## ë°±ì¡°ì˜ í˜¸ìˆ˜
## ìœ ëŸ½ì—¬í–‰


***

# **`[ë°±ì¤€] ê·¸ë˜í”„ íƒìƒ‰` [ë°°ì—´ì—ì„œ ì´ë™](https://www.acmicpc.net/problem/1981)** â­

```java

```

***

# **`[Leetcode] LCS` [Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)** â­

```java

```