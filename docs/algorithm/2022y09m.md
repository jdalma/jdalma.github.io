---
layout: default
title: 2022년 9월
nav_order: 17
parent: 🐢 알고리즘
---
## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

# **[Codesoom Algorithm Study 9일차 09.01 - `Heap`](https://github.com/jdalma/algorithm-for-coding-test/tree/main/DAY-09)**


## [최소 힙](https://github.com/jdalma/algorithm-for-coding-test/blob/main/DAY-09/1927.java)

## [절댓값 힙](https://github.com/jdalma/algorithm-for-coding-test/blob/main/DAY-09/11286.java)

```
배열에서 절댓값이 가장 작은 값을 출력하고, 그 값을 배열에서 제거한다. 절댓값이 가장 작은 값이 여러개일 때는, 가장 작은 수를 출력하고, 그 값을 배열에서 제거한다.
```

- 위의 지문 그대로 정렬을 구현하니 통과했다

```java
class Number implements Comparable<Number> {
    int number;
    int abs;

    public Number(int number) {
        this.number = number;
        this.abs = Math.abs(number);
    }

    @Override
    public int compareTo(Number o) {
        if(this.abs == o.abs){
            return this.number - o.number;
        }
        return this.abs - o.abs;
    }
}
```

## [카드 정렬하기](https://github.com/jdalma/algorithm-for-coding-test/blob/main/DAY-09/1715.java) ❌

- 두 개의 묶음을 더 했다는 flag를 들고 있는 클래스를 추가해서 정렬을 할까?
- 생각이 아래의 `while`문에 갇혀 있었다

```java
while(!pq.isEmpty()){
    // ...
}
```

<br>

- 두 개의 더한 `sum`을 큐에 넣으면서 누적해주고 `pq.size`가 1 이상일 때만 누적해줬으면 됐다...
- 다른 분의 블로그를 보고 생각을 좀 유연하게 가져야겠다고 느꼈다

```java
while(pq.size() > 1){
    // ...
}
```

***

# **[Codesoom Algorithm Study 10일차 09.02 - `Dynamic Programming`](https://github.com/jdalma/algorithm-for-coding-test/tree/main/DAY-10)**

- ~~기본 문제 3문제는 다 실패했다..~~ 블로그 글 보면서 기본 문제 3문제를 이해하니 추가문제 3문제는 직접 풀 수 있었다
- 문제 지문을 잘 이해하고 지문에서 말한대로 구현하니 조금 감이 잡혔다
- `1로 만들기` , `2xn 타일링` , `계단 오르기`는 백준에 제출하지 않았으니 추후에 다시 풀어봐야겠다

## [1로 만들기](https://github.com/jdalma/algorithm-for-coding-test/blob/main/DAY-10/1463.java)
## [2xn 타일링](https://github.com/jdalma/algorithm-for-coding-test/blob/main/DAY-10/11726.java)
## [계단 오르기](https://github.com/jdalma/algorithm-for-coding-test/blob/main/DAY-10/2579.java)

## [정수 삼각형](https://github.com/jdalma/algorithm-for-coding-test/blob/main/DAY-10/1932.java)
- `N - 1`부터 위로 올라가면서 11시방향 , 1시방향을 더해가며 최대값을 누적하였다

## [스티커](https://github.com/jdalma/algorithm-for-coding-test/blob/main/DAY-10/9465.java)
- `1번 인덱스` 부터 `i - 1`의 스티커 점수를 `N`까지 누적하였다
- **상하좌우**를 무시하고 아래처럼 누적해주니 통과하였다

```java
map[0][1] += map[1][0];
map[1][1] += map[0][0];
for (int i = 2; i < size; i++) {
    map[0][i] = Math.max(map[1][i - 2], map[1][i - 1]) + map[0][i];
    map[1][i] = Math.max(map[0][i - 2], map[0][i - 1]) + map[1][i];
}
```

## [RGB거리](https://github.com/jdalma/algorithm-for-coding-test/blob/main/DAY-10/1149.java)

```
1번 집의 색은 2번 집의 색과 같지 않아야 한다.
N번 집의 색은 N-1번 집의 색과 같지 않아야 한다.
i(2 ≤ i ≤ N-1)번 집의 색은 i-1번, i+1번 집의 색과 같지 않아야 한다
```

- 이 지문 자체가 대각선만 구하라는 말이기 때문에 정수 삼각형 문제와 동일했다

```java
for(int i = 1 ; i < homeCount ; i++){
    map[i][0] = Math.min(map[i - 1][1] , map[i - 1][2]) + map[i][0];
    map[i][1] = Math.min(map[i - 1][0] , map[i - 1][2]) + map[i][1];
    map[i][2] = Math.min(map[i - 1][0] , map[i - 1][1]) + map[i][2];
}
```

# **[Codesoom Algorithm Study 11일차 09.05 - `BFS`](https://github.com/jdalma/algorithm-for-coding-test/tree/main/DAY-11)**

- 이번 3문제는 특별한 것이 없었고 일반적인 BFS였다
- 이런 종류의 문제는 DFS로 풀지 않고 항상 BFS로 푸는 것 같다...
- 개인적으로 BFS를 더 선호하는 것 같기도 하다

## [바이러스](https://github.com/jdalma/algorithm-for-coding-test/blob/main/DAY-11/2606.java)
## [유기농 배추](https://github.com/jdalma/algorithm-for-coding-test/blob/main/DAY-11/1012.java)
## [단지번호붙이기](https://github.com/jdalma/algorithm-for-coding-test/blob/main/DAY-11/2667.java)

***

# **Algorithm Study 20주차 - `DP`**


## 돌 게임 2

## 카드 구매하기 🚨

```java
public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        int buy = Integer.parseInt(br.readLine());

        StringTokenizer st = new StringTokenizer(br.readLine());
        int[] prices = new int[buy + 1];
        int[] dp = new int[buy + 1];
        for(int i = 1 ; i <= buy ; i++){
            prices[i] = Integer.parseInt(st.nextToken());
        }

        for(int i = 1 ; i <= buy ; i++){
            for(int j = 1 ; j <= i ; j++){
                dp[i] = Math.max(dp[i] , dp[i - j] + prices[j]);
            }
        }
        System.out.println(dp[buy]);
    }
}

```

## 합분해 ❌
## 암호코드 ❌
## 로봇 조종하기 ❌

***

# **[Codesoom Algorithm Study 12일차 09.06 - `최단거리`](https://github.com/jdalma/algorithm-for-coding-test/tree/main/DAY-12)**

## [A -> B](https://github.com/jdalma/algorithm-for-coding-test/blob/main/DAY-12/16953.java)

-  **1을 수의 가장 오른쪽에 추가한다.**를 `int`로 사용해서 틀렸었다

## [미로 탐색](https://github.com/jdalma/algorithm-for-coding-test/blob/main/DAY-12/2178.java)

## [숨바꼭질](https://github.com/jdalma/algorithm-for-coding-test/blob/main/DAY-12/1697.java)

- 단순 BFS로만 생각하고 `memoization`을 생각 못 했어서 **메모리 초과**

***

# **[Codesoom Algorithm Study 13일차 09.07 - `플로이드 워셜`](https://github.com/jdalma/algorithm-for-coding-test/tree/main/DAY-13)**

## [케빈 베이컨의 6단계 법칙](https://github.com/jdalma/algorithm-for-coding-test/blob/main/DAY-13/1389.java)
## [경로 찾기](https://github.com/jdalma/algorithm-for-coding-test/blob/main/DAY-13/11403.java)
## [서강그라운드](https://github.com/jdalma/algorithm-for-coding-test/blob/main/DAY-13/14938.java)

- 예전에 풀었던 문젠데 예전에 놓쳤던 부분에서 똑같이 놓쳤다...
- 인접행렬의 자기 자신을 `0`으로 채우지 않아 아이템을 누적할 때 제외돼서 틀렸다

***

# **[Codesoom Algorithm Study 14일차 09.08 - `다익스트라`](https://github.com/jdalma/algorithm-for-coding-test/tree/main/DAY-14)**

- 다익스트라를 오랜만에 풀어서 고민하면서 풀었다
- 비용 변수를 `int`로 잡아서 틀렸다

## [특정 거리의 도시 찾기](https://github.com/jdalma/algorithm-for-coding-test/blob/main/DAY-14/18352.java)
## [최소비용 구하기](https://github.com/jdalma/algorithm-for-coding-test/blob/main/DAY-14/1916.java)
## [최단경로](https://github.com/jdalma/algorithm-for-coding-test/blob/main/DAY-14/1753.java)


# **[Codesoom Algorithm Study 15일차 09.12 - `분할정복`](https://github.com/jdalma/algorithm-for-coding-test/tree/main/DAY-15)**

- 3문제 다 재귀를 4분면으로 나누어 접근하면 풀 수 있는 문제
- **Z**는 모든 경우를 다 탐색하다가 시간초과가 났다. **입력으로 받은 위치에 해당하는 부분만 탐색하는 것**이였다.
- **쿼드 트리** 괄호 삽입 때문에 고생하다가 결국 다른 분의 블로그를 찾아서 풀었다.
  - 괄호 삽입은 재귀를 잘 이해했으면 무난히 이해했을 것 같은데 아직 재귀가 어려워서 그런 것 같다 ㅠㅠ

## [색종이 만들기](https://github.com/jdalma/algorithm-for-coding-test/blob/main/DAY-15/2630.java)
## [Z](https://github.com/jdalma/algorithm-for-coding-test/blob/main/DAY-15/1074.java)
## [쿼드트리](https://github.com/jdalma/algorithm-for-coding-test/blob/main/DAY-15/1992.java)

# **[Codesoom Algorithm Study 16일차 09.13 - `백 트래킹`](https://github.com/jdalma/algorithm-for-coding-test/tree/main/DAY-16)**

## [N과 M (2)](https://github.com/jdalma/algorithm-for-coding-test/blob/main/DAY-16/15650.java)

## [0 만들기](https://github.com/jdalma/algorithm-for-coding-test/blob/main/DAY-16/7490.java)

- 숫자를 이어붙이는 ` ` 공백 때문에 고생했다.
- 중복을 허용하는 조합을 사용하여 연산 배열을 채워 계산해줄려고 했지만.. ` ` 공백을 어떻게 처리해야할지 고민하다가 **StringTokenizer**를 사용하여 푼 블로그를 참고하여 풀었다.
- `+|-`로 구분자를 여러 개 구분할 수 있는 것을 처음 알았다.

## [N-Queen](https://github.com/jdalma/algorithm-for-coding-test/blob/main/DAY-16/9663.java)

- 재귀로 2차원 배열을 체크하며 놓을려고 했다.
- 대각선은 BFS로 돌리면서 놓을 수 없는 곳은 `+1`씩 증가시켜주고 콜 스택에서 빠질 때는 `-1`씩 감소 시켜 줄려고했다..
- 작성하면서 시간이나 메모리가 터질 것 같아 다른 분 블로그를 참고했다.
  - 1차원 배열을 사용하여 **인덱스는 열**로 , **값은 행**으로 구분해서 사용했다. 


```java
public static void placed(int count) {
    if (count == size) {
        result++;
        return;
    }

    for (int i = 0; i < size; i++) {
        map[count] = i;
        if (isPossible(count)) {
            placed(count + 1);
        }
    }
}

public static boolean isPossible(int count) {
    for (int i = 0; i < count; i++) {
        // 해당 열의 행과 i열의 행이 일치할경우 (같은 행에 존재할 경우)
        if (map[i] == map[count]) {
            return false;
        }

        // 대각선상에 놓여있는 경우
        // (열의 차와 행의 차가 같을 경우가 대각선에 놓여있는 경우다)
        else if (Math.abs(count - i) == Math.abs(map[count] - map[i])) {
            return false;
        }
    }
    return true;
}
```

# **[Codesoom Algorithm Study 17일차 09.16 - `구현`](https://github.com/jdalma/algorithm-for-coding-test/tree/main/DAY-17)**

- 3문제 다 예전에 봤던 문제인데 다시 풀어도 아이디어를 생각해내기 어려웠다..

## [마인크래프트](https://www.acmicpc.net/problem/18111)
- 완탐을 하면 터지겠지라고 생각만하고 고민만하다가 시간을 많이 버렸다..
- 결국 완탐이였다
- 인벤토리에 있는 블록을 다 쓰면 반복문 탈출하고 높이를 높혀 다시 계산했지만 틀렸다
- 제거하고 인벤토리에 블록을 다시 채우기 때문에 반복문 탈출을 하지 말고 계산이 끝난 후 블록이 0보다 작은지만 확인하면 됐다

## [테트로미노](https://www.acmicpc.net/problem/14500) ❌
- 이 문제는 해설을 보면 이해가 가긴 하는데... 다시 풀라고하면 못 풀 것 같은 문제
- `ㅜ`를 따로 처리하고 나머지는 DFS로 4칸 씩 이동하는 문제였다

## [아기상어](https://www.acmicpc.net/problem/16236)
- **상어가 어디 먹이를 먼저 먹을까** 고민이였던 문제
- 핵심은 상어가 이동할 수 있는 곳은 다 이동하며 **먹을 수 있는 먹이를 우선순위 큐에 계속 담는다.**
- 상어가 탐색을 다 끝냈다면 **먹이를 우선순위에 맞게 한 개만 꺼내어 상어의 위치를 그 먹이의 위치로 바꾸고 먹이를 먹는다.**
- 상어가 먹이를 먹을 수 없을 때 까지 반복한다.

# **[Codesoom Algorithm Study 18일차 09.16 - `수학`](https://github.com/jdalma/algorithm-for-coding-test/tree/main/DAY-18)**

- **곱셈**문제는 비슷한 유형을 더 풀어봐야 알 것 같다...
- 읽어봐도 잘 모르겠다

## [소수 구하기](https://github.com/jdalma/algorithm-for-coding-test/blob/main/DAY-18/1929.java) 
- [st-lab](https://st-lab.tistory.com/81)을 읽어보니 아래와 같이 구현했다 `168ms`
  - number의 제곱근 만큼 돌아도 된다

```java
public static boolean[] setPrime(int number){
    boolean[] result = new boolean[number + 1];
    result[0] = true;
    result[1] = true;

    for(int i = 2 ; i <= Math.sqrt(number) ; i++){
        if(result[i]){
            continue;
        }
        for(int j = i * i ; j <= number ; j += i){
            result[j] = true;
        }
    }
    return result;
}
```

- 나는 아래와 비슷하게 풀었다 `200ms`.. 시간은 비슷하다 

```java
public static boolean[] setPrime(int number){
    boolean[] result = new boolean[number + 1];
    result[0] = true;
    result[1] = true;

    for(int i = 2 ; i <= number ; i++){
        for(int j = i + i ; j <= number ; j += i){
            result[j] = true;
        }
    }
    return result;
}
```

## [곱셈](https://www.acmicpc.net/problem/1629) ❌
- 이 문제가 `분할 정복을 이용한 거듭제곱`이라는 것을 읽고 바로 포기

## [암호 만들기](https://www.acmicpc.net/problem/1759)
- 조합 + 자음과 모음 개수 확인
