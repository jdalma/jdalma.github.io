---
layout: default
title: 2021ÎÖÑ9Ïõî
nav_order: 5
parent: ÏïåÍ≥†Î¶¨Ï¶ò
---
## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---


# **`[Î∞±Ï§Ä] BFS` [ÎØ∏Î°úÌÉêÏÉâ](https://www.acmicpc.net/problem/2178)**


```java
package algo;

import java.util.*;
import java.io.*;

public class Main {
	static int[] moveX = {-1 , 0 , 1 , 0};
    static int[] moveY = {0 , 1 , 0 , -1};
	static int[][] maze;
	static boolean[][] checked;
	static int x , y;
    public static void main(String[] args) throws IOException {
    	BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    	StringTokenizer st = new StringTokenizer(br.readLine());
    	x = Integer.parseInt(st.nextToken());
    	y = Integer.parseInt(st.nextToken());
    	maze = new int[x][y];
    	checked = new boolean[x][y];
    	for(int i = 0 ; i < x ; i++) {
    		String[] line = br.readLine().split("");
    		for(int j = 0 ; j < y ; j++) {
    			maze[i][j] = Integer.parseInt(line[j]);
    		}
    	}
    	checked[0][0] = true;
    	bfs();
    }

    public static void bfs() {
    	Queue<int[]> queue = new LinkedList<int[]>();
    	queue.offer(new int[] {0 , 0 , 1});
    	while(!queue.isEmpty()) {
    		int[] nowArr = queue.poll();
    		int nowX = nowArr[0];
    		int nowY = nowArr[1];
    		int moveCount = nowArr[2];
			if(nowX == x - 1 && nowY == y - 1) {
				System.out.println(moveCount);
				System.exit(0);
			}
			else {
				for(int i = 0 ; i < 4 ; i++) {
	    			int moveXpos = nowX + moveX[i];
	    			int moveYpos = nowY + moveY[i];
	    			if(moveXpos >= 0 && moveYpos >= 0 && moveXpos < x && moveYpos < y && maze[moveXpos][moveYpos] == 1 && !checked[moveXpos][moveYpos]){
	    				checked[moveXpos][moveYpos] = true;
	    				queue.offer(new int[] {moveXpos , moveYpos , moveCount + 1});
	    			}
	    		}
			}
    	}
    }
}
```

***

# **`[Î∞±Ï§Ä] DFS` [Î∞îÏù¥Îü¨Ïä§](https://www.acmicpc.net/problem/2606)**


```java
import java.util.*;
import java.io.*;

public class Main {
	static List<ArrayList<Integer>> link = new ArrayList<>();
	static boolean[] checked;
	static int nodeSize , rowSize;
	static int result = 0;
    public static void main(String[] args) throws IOException {
    	BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    	StringTokenizer st;
    	nodeSize = Integer.parseInt(br.readLine());
    	rowSize = Integer.parseInt(br.readLine());
    	checked = new boolean[nodeSize + 1];
    	for(int i = 0 ; i < nodeSize + 1 ; i++) link.add(new ArrayList<Integer>());
    	for(int i = 0 ; i < rowSize ; i++) {
    		st = new StringTokenizer(br.readLine());
    		int start = Integer.parseInt(st.nextToken());
    		int end = Integer.parseInt(st.nextToken());
    		link.get(start).add(end);
    		link.get(end).add(start);
    	}
//    	bfs(); // Î©îÎ™®Î¶¨ Ï¥àÍ≥º
    	checked[1] = true;
    	dfs(1);
    	System.out.println(result);
    }

    public static void bfs() {
    	Queue<Integer> queue = new LinkedList<Integer>();
    	queue.offer(1);
    	while(!queue.isEmpty()) {
    		int node = queue.poll();
    		for(int newNode : link.get(node)) {
    			queue.offer(newNode);
    			result++;
    		}
    	}
    }

    public static void dfs(int node) {
    	for(int nearNode : link.get(node)) {
    		if(!checked[nearNode]) {
    			checked[nearNode] = true;
        		result++;
        		dfs(nearNode);
    		}
    	}
    }
}
```

***

# üî• **`[Î∞±Ï§Ä] DFS - Î∞±Ìä∏ÎûòÌÇπ` [NÍ≥º M (9)](https://www.acmicpc.net/problem/15663)**

```java
import java.io.*;
import java.util.*;

public class Main {
    static boolean[] checked;
    static int[] printArr;
    static int[] numArr;
    static StringBuilder result;
    static int num1 , num2;
    static int prevNum = Integer.MIN_VALUE;
    static LinkedHashSet<String> resultSet = new LinkedHashSet<>();
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        num1 = Integer.parseInt(st.nextToken());
        num2 = Integer.parseInt(st.nextToken());
        st = new StringTokenizer(br.readLine());
        numArr = new int[num1];
        for(int i = 0 ; i < num1 ; i++){
            numArr[i] = Integer.parseInt(st.nextToken());
        }
        checked = new boolean[num1];
        printArr = new int[num2];
        Arrays.sort(numArr);
        recursive(0);
        resultSet.forEach(System.out::println);
    }

    public static void recursive(int index){
        if(index == num2){
            result = new StringBuilder();
            for(int value : printArr){
                result.append(value).append(" ");
            }
            resultSet.add(result.toString());
            return;
        }
        else{
            for(int j = 0 ; j < num1 ; j++){
                if(!checked[j]){
                    checked[j] = true;
                    printArr[index] = numArr[j];
                    recursive(index + 1);
                    checked[j] = false;
                }
            }
        }
    }
}
```

***

# **`[Î∞±Ï§Ä] DFS - Î∞±Ìä∏ÎûòÌÇπ` [NÍ≥º M (10)](https://www.acmicpc.net/problem/15664)**

```java
import java.io.*;
import java.util.*;

public class Main {
    static boolean[] checked;
    static int[] printArr;
    static int[] numArr;
    static StringBuilder result;
    static int num1 , num2;
    static int prevNum = Integer.MIN_VALUE;
    static LinkedHashSet<String> resultSet = new LinkedHashSet<>();
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        num1 = Integer.parseInt(st.nextToken());
        num2 = Integer.parseInt(st.nextToken());
        st = new StringTokenizer(br.readLine());
        numArr = new int[num1];
        for(int i = 0 ; i < num1 ; i++){
            numArr[i] = Integer.parseInt(st.nextToken());
        }
        checked = new boolean[num1];
        printArr = new int[num2];
        Arrays.sort(numArr);
        recursive(0,0);
        resultSet.forEach(System.out::println);
    }

    public static void recursive(int start , int index){
        if(index == num2){
            result = new StringBuilder();
            for(int value : printArr){
                result.append(value).append(" ");
            }
            resultSet.add(result.toString());
            return;
        }
        else{
            for(int j = start ; j < num1 ; j++){
                if(!checked[j]){
                    checked[j] = true;
                    printArr[index] = numArr[j];
                    recursive(j , index + 1);
                    checked[j] = false;
                }
            }
        }
    }
}
```

***

# **`[Î∞±Ï§Ä] DFS - Î∞±Ìä∏ÎûòÌÇπ` [NÍ≥º M (11)](https://www.acmicpc.net/problem/15665)**

```java
import java.io.*;
import java.util.*;

public class Main {
    static int[] printArr;
    static int[] numArr;
    static StringBuilder result = new StringBuilder();
    static int num1 , num2;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        num1 = Integer.parseInt(st.nextToken());
        num2 = Integer.parseInt(st.nextToken());
        st = new StringTokenizer(br.readLine());
        numArr = new int[num1];
        for(int i = 0 ; i < num1 ; i++){
            numArr[i] = Integer.parseInt(st.nextToken());
        }
        printArr = new int[num2];
        Arrays.sort(numArr);
        recursive(0);
        System.out.println(result.toString());
    }

    public static void recursive(int index){
        if(index == num2){
            for(int value : printArr){
                result.append(value).append(" ");
            }
            result.append("\n");
            return;
        }
        else{
            for(int j = 0 ; j < num1 ; j++){
                if(printArr[index] != numArr[j]){
                    printArr[index] = numArr[j];
                    recursive(index + 1);
                }
            }
        }
    }
}
```

***

# **`[Î∞±Ï§Ä] DFS - Î∞±Ìä∏ÎûòÌÇπ` [NÍ≥º M (12)](https://www.acmicpc.net/problem/15666)**

```java
import java.io.*;
import java.util.*;

public class Main {
    static int[] printArr;
    static int[] numArr;
    static StringBuilder result;
    static LinkedHashSet<String> resultSet = new LinkedHashSet<>();
    static int num1 , num2;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        num1 = Integer.parseInt(st.nextToken());
        num2 = Integer.parseInt(st.nextToken());
        st = new StringTokenizer(br.readLine());
        numArr = new int[num1];
        for(int i = 0 ; i < num1 ; i++){
            numArr[i] = Integer.parseInt(st.nextToken());
        }
        printArr = new int[num2];
        Arrays.sort(numArr);
        recursive(0 ,0);
        resultSet.forEach(System.out::println);
    }

    public static void recursive(int start , int index){
        if(index == num2){
            result = new StringBuilder();
            for(int value : printArr){
                result.append(value).append(" ");
            }
            resultSet.add(result.toString());
            return;
        }
        else{
            for(int j = start ; j < num1 ; j++){
                printArr[index] = numArr[j];
                recursive(j ,index + 1);
            }
        }
    }
}
```

***

# **`[Î∞±Ï§Ä] DFS - Î∞±Ìä∏ÎûòÌÇπ` [Ïó∞ÏÇ∞Ïûê ÎÅºÏõåÎÑ£Í∏∞](https://www.acmicpc.net/problem/14888) ÏßÑÌñâÏ§ë**

```java
import java.util.*;
import java.io.*;

public class Main {
	static int[] symbolArr = new int[4];
	static int[] numArr;
	static int[] printArr;
	static boolean[] checked;
	static int max = Integer.MIN_VALUE, min = Integer.MAX_VALUE;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int size = Integer.parseInt(br.readLine());
        numArr = new int[size];
        checked = new boolean[size];
        printArr = new int[size];
        StringTokenizer st = new StringTokenizer(br.readLine());
        for(int i = 0 ; i < size ; i++) {
        	numArr[i] = Integer.parseInt(st.nextToken());
        }
        st = new StringTokenizer(br.readLine());
        symbolArr[0] = Integer.parseInt(st.nextToken());
        symbolArr[1] = Integer.parseInt(st.nextToken());
        symbolArr[2] = Integer.parseInt(st.nextToken());
        symbolArr[3] = Integer.parseInt(st.nextToken());

        recursive(0);
        System.out.println(max + "\n" + min);
    }
    public static void recursive(int count) {
    	if(count == numArr.length) {
    		int resultValue = printArr[0];
    		int index = 1;
    		for(int i = 0 ; i < symbolArr.length ; i++) {
    			for(int j = 0 ; j < symbolArr[i] ; j++) {
    				if(i == 0) resultValue += printArr[index];
    				else if(i == 1) resultValue -= printArr[index];
    				else if(i == 2) resultValue *= printArr[index];
    				else if(i == 3) {
    					if(resultValue < 0) {
    						resultValue = (Math.abs(resultValue) / printArr[index]) * -1;
    					}
    					else if(printArr[index] != 0){
//    						resultValue = resultValue / printArr[index];
    					}
    				}
    				System.out.print(printArr[index]);
    				index++;
    			}
    			System.out.println();
    		}
    		max = Math.max(resultValue, max);
    		min = Math.min(resultValue, min);
    	}
    	else if(count < numArr.length){
    		for(int i = count ; i < numArr.length ; i++) {
    			printArr[i] = numArr[i];
    			recursive(count + 1);
    		}
    	}
    }
}
```

***

# **`[Î∞±Ï§Ä] BFS` [Ïú†Í∏∞ÎÜç Î∞∞Ï∂î](https://www.acmicpc.net/problem/1012)**

```java
import java.io.*;
import java.util.*;


public class Main {
	static int[] moveX = {-1 , 0 , 1 , 0};
    static int[] moveY = {0 , 1 , 0 , -1};
    static int[][] map;
    static int resultCount;
    static int x , y;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int testCase = Integer.parseInt(br.readLine());
        for(int test = 0 ; test < testCase ; test++) {
        	resultCount = 0;
        	StringTokenizer st = new StringTokenizer(br.readLine());
        	x = Integer.parseInt(st.nextToken());
        	y = Integer.parseInt(st.nextToken());
        	int count = Integer.parseInt(st.nextToken());
        	map = new int[x][y];
        	for(int j = 0 ; j < count ; j++) {
        		st = new StringTokenizer(br.readLine());
        		int posX = Integer.parseInt(st.nextToken());
        		int posY = Integer.parseInt(st.nextToken());
        		map[posX][posY] = 1;
        	}
        	for(int i = 0 ; i < x ; i++) {
        		for(int j = 0 ; j < y ; j++) {
        			if(map[i][j] == 1) {
        				map[i][j] = 0;
        				resultCount++;
        				bfs(i , j);
        			}
        		}
        	}
        	System.out.println(resultCount);
        }
    }

    public static void bfs(int locX , int locY) {
    	Queue<int[]> queue = new LinkedList<int[]>();
    	queue.offer(new int[] {locX , locY});
    	while(!queue.isEmpty()) {
    		int[] now = queue.poll();
    		int nowX = now[0];
    		int nowY = now[1];
    		for(int i = 0 ; i < 4 ; i++) {
    			int moveXpos = nowX + moveX[i];
    			int moveYpos = nowY + moveY[i];
    			if(moveXpos >= 0 && moveYpos >= 0 && moveXpos < x && moveYpos < y && map[moveXpos][moveYpos] == 1) {
    				map[moveXpos][moveYpos] = 0;
    				queue.offer(new int[] {moveXpos , moveYpos});
    			}
    		}
    	}
    }
}
```

***

# **`[Î∞±Ï§Ä] DP` [1Î°ú ÎßåÎì§Í∏∞](https://www.acmicpc.net/problem/1463)**

```java

```

***

# **`[Î∞±Ï§Ä] Î∂ÑÌï†Ï†ïÎ≥µ` [ÌûàÏä§ÌÜ†Í∑∏Îû®](https://www.acmicpc.net/problem/1725) ‚ùå**

- [Ï∞∏Í≥†](https://st-lab.tistory.com/255)
- [Segmant Tree](https://m.blog.naver.com/ndb796/221282210534)

```java

```

***

# **`[Î∞±Ï§Ä] Stack` [Í≤ÄÏó¥](https://www.acmicpc.net/problem/3111) <span style="color:red; font-weight:bold">Ï∂úÎ†•Ï¥àÍ≥º</span> ‚ùå**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;


class Main {
    static String removeStr;
    static String str;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        removeStr = br.readLine();
        str = br.readLine();
        if(removeStr.length() <= 0) System.out.println(str);
        else System.out.println(solution());
    }

    public static String solution(){
        StringBuilder resultString = new StringBuilder();
        Stack<Character> stack = new Stack<>();
        Stack<Character> revStack = new Stack<>();
        int leftIndex = 0 , rightIndex = str.length() - 1;
        boolean reverseFlag = false;
        while(leftIndex <= rightIndex){
            if(!reverseFlag && leftIndex < str.length()){
                stack.push(str.charAt(leftIndex++));
                if(stack.size() >= removeStr.length() && stack.peek() == removeStr.charAt(removeStr.length() - 1)){
                    if(duplCheck(stack)) reverseFlag = true;
                }
            }
            if(reverseFlag && leftIndex <= rightIndex){
                revStack.push(str.charAt(rightIndex--));
                if(revStack.size() >= removeStr.length() && revStack.peek() == removeStr.charAt(removeStr.length() - 1)){
                    if(duplCheck(revStack)) reverseFlag = false;
                }
            }
        }
        // Ï∂úÎ†• Ï¥àÍ≥º !!!
        for(char ch : stack) resultString.append(ch);
        for(int i = revStack.size() - 1 ; i >= 0 ; i--) resultString.append(revStack.get(i));
        while(true){
            int removeIndex = resultString.indexOf(removeStr);
            if(removeIndex < 0) break;
            resultString.delete(removeIndex , removeIndex + removeStr.length());
        }
        return resultString.toString();
    }

    public static boolean duplCheck(Stack<Character> stack){
        int removeStrLength = removeStr.length() - 1;
        boolean flag = true;
        for(int i = stack.size() - 1 ; i >= stack.size() - removeStr.length() ; i--){
            if(stack.get(i) != removeStr.charAt(removeStrLength--)){
                flag = false;
                break;
            }
        }
        if(flag) {
            for (int i = 0; i < removeStr.length(); i++) {
                stack.pop();
            }
        }
        return flag;
    }
}
```



***

# **`[Î∞±Ï§Ä DFS , BFS]` [Ïà®Î∞îÍº≠Ïßà4](https://www.acmicpc.net/problem/13913)**

```java

```

***

# **`[Î∞±Ï§Ä] BFS` [ÏïåÍ≥†Ïä§Ìåü](https://www.acmicpc.net/problem/1261) ‚ùå**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

class Position{
    int x;
    int y;
    int breakWall;
    public Position(int x, int y, int breakWall) {
        this.x = x;
        this.y = y;
        this.breakWall = breakWall;
    }
}

class Main {
    static int[] moveX = {-1 , 0 , 1 , 0};
    static int[] moveY = {0 , 1 , 0 , -1};
    static int[][] map;
    static boolean[][] visited;
    static List<Integer> resultList = new ArrayList<>();
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int y = Integer.parseInt(st.nextToken());
        int x = Integer.parseInt(st.nextToken());
        map = new int[x][y];
        visited = new boolean[x][y];
        for(int i = 0 ; i < x ; i++){
            String[] line = br.readLine().split("");
            for(int j = 0 ; j < y ; j++){
                map[i][j] = Integer.parseInt(line[j]);
            }
        }
        start(x - 1, y - 1);
        System.out.println(resultList);
    }

    public static void start(int targetX , int targetY){
        Queue<Position> queue = new LinkedList<>();
        queue.offer(new Position(0 , 0 ,0));
        while(!queue.isEmpty()){
            Position now = queue.poll();
            if(now.x == targetX && now.y == targetY){
                resultList.add(now.breakWall);
            }
            else {
                for (int i = 0; i < 4; i++) {
                    int moveXpos = now.x + moveX[i];
                    int moveYpos = now.y + moveY[i];
                    if (moveXpos >= 0 && moveYpos >= 0 && moveXpos <= targetX && moveYpos <= targetY && !visited[moveXpos][moveYpos]) {
                        if (map[moveXpos][moveYpos] == 1) {
                            queue.offer(new Position(moveXpos, moveYpos, now.breakWall + 1));
                        } else queue.offer(new Position(moveXpos, moveYpos, now.breakWall));
                        visited[moveXpos][moveYpos] = true;
                    }
                }
            }
        }
    }
}
```
