---
layout: default
title: 2021ë…„9ì›”
nav_order: 5
parent: ì•Œê³ ë¦¬ì¦˜
---
## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---


# **`[ë°±ì¤€] BFS` [ë¯¸ë¡œíƒìƒ‰](https://www.acmicpc.net/problem/2178)**


```java
package algo;

import java.util.*;
import java.io.*;

public class Main {
	static int[] moveX = {-1 , 0 , 1 , 0};
    static int[] moveY = {0 , 1 , 0 , -1};
	static int[][] maze;
	static boolean[][] checked;
	static int x , y;
    public static void main(String[] args) throws IOException {
    	BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    	StringTokenizer st = new StringTokenizer(br.readLine());
    	x = Integer.parseInt(st.nextToken());
    	y = Integer.parseInt(st.nextToken());
    	maze = new int[x][y];
    	checked = new boolean[x][y];
    	for(int i = 0 ; i < x ; i++) {
    		String[] line = br.readLine().split("");
    		for(int j = 0 ; j < y ; j++) {
    			maze[i][j] = Integer.parseInt(line[j]);
    		}
    	}
    	checked[0][0] = true;
    	bfs();
    }

    public static void bfs() {
    	Queue<int[]> queue = new LinkedList<int[]>();
    	queue.offer(new int[] {0 , 0 , 1});
    	while(!queue.isEmpty()) {
    		int[] nowArr = queue.poll();
    		int nowX = nowArr[0];
    		int nowY = nowArr[1];
    		int moveCount = nowArr[2];
			if(nowX == x - 1 && nowY == y - 1) {
				System.out.println(moveCount);
				System.exit(0);
			}
			else {
				for(int i = 0 ; i < 4 ; i++) {
	    			int moveXpos = nowX + moveX[i];
	    			int moveYpos = nowY + moveY[i];
	    			if(moveXpos >= 0 && moveYpos >= 0 && moveXpos < x && moveYpos < y && maze[moveXpos][moveYpos] == 1 && !checked[moveXpos][moveYpos]){
	    				checked[moveXpos][moveYpos] = true;
	    				queue.offer(new int[] {moveXpos , moveYpos , moveCount + 1});
	    			}
	    		}
			}
    	}
    }
}
```

***

# **`[ë°±ì¤€] DFS` [ë°”ì´ëŸ¬ìŠ¤](https://www.acmicpc.net/problem/2606)**


```java
import java.util.*;
import java.io.*;

public class Main {
	static List<ArrayList<Integer>> link = new ArrayList<>();
	static boolean[] checked;
	static int nodeSize , rowSize;
	static int result = 0;
    public static void main(String[] args) throws IOException {
    	BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    	StringTokenizer st;
    	nodeSize = Integer.parseInt(br.readLine());
    	rowSize = Integer.parseInt(br.readLine());
    	checked = new boolean[nodeSize + 1];
    	for(int i = 0 ; i < nodeSize + 1 ; i++) link.add(new ArrayList<Integer>());
    	for(int i = 0 ; i < rowSize ; i++) {
    		st = new StringTokenizer(br.readLine());
    		int start = Integer.parseInt(st.nextToken());
    		int end = Integer.parseInt(st.nextToken());
    		link.get(start).add(end);
    		link.get(end).add(start);
    	}
//    	bfs(); // ë©”ëª¨ë¦¬ ì´ˆê³¼
    	checked[1] = true;
    	dfs(1);
    	System.out.println(result);
    }

    public static void bfs() {
    	Queue<Integer> queue = new LinkedList<Integer>();
    	queue.offer(1);
    	while(!queue.isEmpty()) {
    		int node = queue.poll();
    		for(int newNode : link.get(node)) {
    			queue.offer(newNode);
    			result++;
    		}
    	}
    }

    public static void dfs(int node) {
    	for(int nearNode : link.get(node)) {
    		if(!checked[nearNode]) {
    			checked[nearNode] = true;
        		result++;
        		dfs(nearNode);
    		}
    	}
    }
}
```

***

# ğŸ”¥ **`[ë°±ì¤€] DFS - ë°±íŠ¸ë˜í‚¹` [Nê³¼ M (9)](https://www.acmicpc.net/problem/15663)**

```java
import java.io.*;
import java.util.*;

public class Main {
    static boolean[] checked;
    static int[] printArr;
    static int[] numArr;
    static StringBuilder result;
    static int num1 , num2;
    static int prevNum = Integer.MIN_VALUE;
    static LinkedHashSet<String> resultSet = new LinkedHashSet<>();
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        num1 = Integer.parseInt(st.nextToken());
        num2 = Integer.parseInt(st.nextToken());
        st = new StringTokenizer(br.readLine());
        numArr = new int[num1];
        for(int i = 0 ; i < num1 ; i++){
            numArr[i] = Integer.parseInt(st.nextToken());
        }
        checked = new boolean[num1];
        printArr = new int[num2];
        Arrays.sort(numArr);
        recursive(0);
        resultSet.forEach(System.out::println);
    }

    public static void recursive(int index){
        if(index == num2){
            result = new StringBuilder();
            for(int value : printArr){
                result.append(value).append(" ");
            }
            resultSet.add(result.toString());
            return;
        }
        else{
            for(int j = 0 ; j < num1 ; j++){
                if(!checked[j]){
                    checked[j] = true;
                    printArr[index] = numArr[j];
                    recursive(index + 1);
                    checked[j] = false;
                }
            }
        }
    }
}
```

***

# **`[ë°±ì¤€] DFS - ë°±íŠ¸ë˜í‚¹` [Nê³¼ M (10)](https://www.acmicpc.net/problem/15664)**

```java
import java.io.*;
import java.util.*;

public class Main {
    static boolean[] checked;
    static int[] printArr;
    static int[] numArr;
    static StringBuilder result;
    static int num1 , num2;
    static int prevNum = Integer.MIN_VALUE;
    static LinkedHashSet<String> resultSet = new LinkedHashSet<>();
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        num1 = Integer.parseInt(st.nextToken());
        num2 = Integer.parseInt(st.nextToken());
        st = new StringTokenizer(br.readLine());
        numArr = new int[num1];
        for(int i = 0 ; i < num1 ; i++){
            numArr[i] = Integer.parseInt(st.nextToken());
        }
        checked = new boolean[num1];
        printArr = new int[num2];
        Arrays.sort(numArr);
        recursive(0,0);
        resultSet.forEach(System.out::println);
    }

    public static void recursive(int start , int index){
        if(index == num2){
            result = new StringBuilder();
            for(int value : printArr){
                result.append(value).append(" ");
            }
            resultSet.add(result.toString());
            return;
        }
        else{
            for(int j = start ; j < num1 ; j++){
                if(!checked[j]){
                    checked[j] = true;
                    printArr[index] = numArr[j];
                    recursive(j , index + 1);
                    checked[j] = false;
                }
            }
        }
    }
}
```

***

# **`[ë°±ì¤€] DFS - ë°±íŠ¸ë˜í‚¹` [Nê³¼ M (11)](https://www.acmicpc.net/problem/15665)**

```java
import java.io.*;
import java.util.*;

public class Main {
    static int[] printArr;
    static int[] numArr;
    static StringBuilder result = new StringBuilder();
    static int num1 , num2;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        num1 = Integer.parseInt(st.nextToken());
        num2 = Integer.parseInt(st.nextToken());
        st = new StringTokenizer(br.readLine());
        numArr = new int[num1];
        for(int i = 0 ; i < num1 ; i++){
            numArr[i] = Integer.parseInt(st.nextToken());
        }
        printArr = new int[num2];
        Arrays.sort(numArr);
        recursive(0);
        System.out.println(result.toString());
    }

    public static void recursive(int index){
        if(index == num2){
            for(int value : printArr){
                result.append(value).append(" ");
            }
            result.append("\n");
            return;
        }
        else{
            for(int j = 0 ; j < num1 ; j++){
                if(printArr[index] != numArr[j]){
                    printArr[index] = numArr[j];
                    recursive(index + 1);
                }
            }
        }
    }
}
```

***

# **`[ë°±ì¤€] DFS - ë°±íŠ¸ë˜í‚¹` [Nê³¼ M (12)](https://www.acmicpc.net/problem/15666)**

```java
import java.io.*;
import java.util.*;

public class Main {
    static int[] printArr;
    static int[] numArr;
    static StringBuilder result;
    static LinkedHashSet<String> resultSet = new LinkedHashSet<>();
    static int num1 , num2;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        num1 = Integer.parseInt(st.nextToken());
        num2 = Integer.parseInt(st.nextToken());
        st = new StringTokenizer(br.readLine());
        numArr = new int[num1];
        for(int i = 0 ; i < num1 ; i++){
            numArr[i] = Integer.parseInt(st.nextToken());
        }
        printArr = new int[num2];
        Arrays.sort(numArr);
        recursive(0 ,0);
        resultSet.forEach(System.out::println);
    }

    public static void recursive(int start , int index){
        if(index == num2){
            result = new StringBuilder();
            for(int value : printArr){
                result.append(value).append(" ");
            }
            resultSet.add(result.toString());
            return;
        }
        else{
            for(int j = start ; j < num1 ; j++){
                printArr[index] = numArr[j];
                recursive(j ,index + 1);
            }
        }
    }
}
```

***

# **`ğŸ”¥ [ë°±ì¤€] DFS - ë°±íŠ¸ë˜í‚¹` [ì—°ì‚°ì ë¼ì›Œë„£ê¸°](https://www.acmicpc.net/problem/14888)**

```java
import java.util.*;
import java.io.*;

public class Main {
    static int[] symbolArr = new int[12];
    static int[] numArr;
    static int[] printArr;
    static boolean[] checked;
    static int max = Integer.MIN_VALUE, min = Integer.MAX_VALUE;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int size = Integer.parseInt(br.readLine());
        numArr = new int[size];
        checked = new boolean[size];
        printArr = new int[size];
        StringTokenizer st = new StringTokenizer(br.readLine());
        for(int i = 0 ; i < size ; i++) {
            numArr[i] = Integer.parseInt(st.nextToken());
        }
        st = new StringTokenizer(br.readLine());
        int index = 0;
        for(int i = 0 ; i < 4 ; i++){
            int count = Integer.parseInt(st.nextToken());
            for(int j = 0 ; j < count ; j++){
                symbolArr[index++] = i + 1;
            }
        }
        recursive(1 ,0 , numArr[0]);
        System.out.println(max + "\n" + min);
    }
    public static void recursive(int index , int count , int number) {
        if(count == numArr.length - 1) {
//            System.out.println("result = " + number);
            max = Math.max(number, max);
            min = Math.min(number, min);
        }
        else{
            for(int i = 0 ; i < numArr.length ; i++) {
                if(!checked[i]){
                    checked[i] = true;
                    switch(symbolArr[i]){
                        case 1:
                            recursive(index + 1 ,count + 1 , number + numArr[index]);
//                            System.out.print("+");
                            break;
                        case 2:
                            recursive(index + 1 ,count + 1 , number - numArr[index]);
//                            System.out.print("-");
                            break;
                        case 3:
                            recursive(index + 1 ,count + 1 , number * numArr[index]);
//                            System.out.print("*");
                            break;
                        case 4:
                            recursive(index + 1 ,count + 1 , number / numArr[index]);
//                            System.out.print("/");
                            break;
                    }
                    checked[i] = false;
                }
            }
        }
    }
}
```

***

# **`[ë°±ì¤€] BFS` [ìœ ê¸°ë† ë°°ì¶”](https://www.acmicpc.net/problem/1012)**

```java
import java.io.*;
import java.util.*;


public class Main {
	static int[] moveX = {-1 , 0 , 1 , 0};
    static int[] moveY = {0 , 1 , 0 , -1};
    static int[][] map;
    static int resultCount;
    static int x , y;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int testCase = Integer.parseInt(br.readLine());
        for(int test = 0 ; test < testCase ; test++) {
        	resultCount = 0;
        	StringTokenizer st = new StringTokenizer(br.readLine());
        	x = Integer.parseInt(st.nextToken());
        	y = Integer.parseInt(st.nextToken());
        	int count = Integer.parseInt(st.nextToken());
        	map = new int[x][y];
        	for(int j = 0 ; j < count ; j++) {
        		st = new StringTokenizer(br.readLine());
        		int posX = Integer.parseInt(st.nextToken());
        		int posY = Integer.parseInt(st.nextToken());
        		map[posX][posY] = 1;
        	}
        	for(int i = 0 ; i < x ; i++) {
        		for(int j = 0 ; j < y ; j++) {
        			if(map[i][j] == 1) {
        				map[i][j] = 0;
        				resultCount++;
        				bfs(i , j);
        			}
        		}
        	}
        	System.out.println(resultCount);
        }
    }

    public static void bfs(int locX , int locY) {
    	Queue<int[]> queue = new LinkedList<int[]>();
    	queue.offer(new int[] {locX , locY});
    	while(!queue.isEmpty()) {
    		int[] now = queue.poll();
    		int nowX = now[0];
    		int nowY = now[1];
    		for(int i = 0 ; i < 4 ; i++) {
    			int moveXpos = nowX + moveX[i];
    			int moveYpos = nowY + moveY[i];
    			if(moveXpos >= 0 && moveYpos >= 0 && moveXpos < x && moveYpos < y && map[moveXpos][moveYpos] == 1) {
    				map[moveXpos][moveYpos] = 0;
    				queue.offer(new int[] {moveXpos , moveYpos});
    			}
    		}
    	}
    }
}
```

***

# **`[ë°±ì¤€] BFS` [ì—°ê²° ìš”ì†Œì˜ ê°œìˆ˜](https://www.acmicpc.net/problem/11724)**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

class Main {
    static boolean[] checked;
    static List<List<Integer>> list = new ArrayList<>();
    static int result = 0;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int vertex = Integer.parseInt(st.nextToken());
        int edge = Integer.parseInt(st.nextToken());
        checked = new boolean[vertex + 1];
        for(int i = 0 ; i <= vertex ; i++) list.add(new ArrayList<Integer>());
        for(int i = 0 ; i < edge ; i++){
            st = new StringTokenizer(br.readLine());
            int vertex1 = Integer.parseInt(st.nextToken());
            int vertex2 = Integer.parseInt(st.nextToken());
            list.get(vertex1).add(vertex2);
            list.get(vertex2).add(vertex1);
        }

        for(int i = 1 ; i <= vertex ; i++){
            if(!checked[i]){
                result++;
                bfs(i);
            }
        }

        System.out.println(result);
    }

    public static void bfs(int vertex){
        Queue<Integer> queue = new LinkedList<>();
        queue.offer(vertex);
        while(!queue.isEmpty()){
            int nowVertex = queue.poll();
            checked[nowVertex] = true;
            for(int linkVertex : list.get(nowVertex)){
                if(!checked[linkVertex]){
                    checked[linkVertex] = true;
                    queue.offer(linkVertex);
                }
            }
        }
    }
}
```

***

# **`[ë°±ì¤€] BFS` [ì„¬ì˜ ê°œìˆ˜](https://www.acmicpc.net/problem/4963)**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

class Main {
    static int[] moveX = new int[] {-1 , -1 , 0 , 1 , 1 , 1 , 0 , -1};
    static int[] moveY = new int[] {0 , 1 , 1 , 1 , 0 , -1 , -1 , -1};
    static int[][] map;
    static int result;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;
        while(true){
            st = new StringTokenizer(br.readLine());
            int width = Integer.parseInt(st.nextToken());
            int height = Integer.parseInt(st.nextToken());
            if(width == 0 && height == 0){
                break;
            }
            result = 0;
            map = new int[height][width];
            for(int i = 0 ; i < height ; i++){
                String[] line = br.readLine().split(" ");
                for(int j = 0 ; j < width ; j++){
                    map[i][j] = Integer.parseInt(line[j]);
                }
            }
            for(int i = 0 ; i < height ; i++){
                for(int j = 0 ; j < width ; j++){
                    if(map[i][j] == 1){
                        result++;
                        bfs(i , j , height , width);
                    }
                }
            }
            System.out.println(result);
        }
    }
    public static void bfs(int x , int y , int height , int width){
        Queue<int[]> queue = new LinkedList<>();
        queue.offer(new int[] {x , y});
        while(!queue.isEmpty()){
            int[] now = queue.poll();
            int nowX = now[0];
            int nowY = now[1];
            for(int i = 0 ; i < 8 ; i++){
                int moveXpos = nowX + moveX[i];
                int moveYpos = nowY + moveY[i];
                if(moveXpos >= 0 && moveYpos >= 0 && moveXpos < height && moveYpos < width && map[moveXpos][moveYpos] == 1){
                    map[moveXpos][moveYpos] = 0;
                    queue.offer(new int[] {moveXpos , moveYpos});
                }
            }
        }
    }
}
```

***

# **`[ë°±ì¤€] BFS` [í† ë§ˆí† ](https://www.acmicpc.net/problem/7569)**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

class Position{
    int x;
    int y;
    int z;
    int count;
    public Position(int x, int y, int z , int count) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.count = count;
    }
}

class Main {
    static int[][][] map;
    static boolean[][][] checked;
    static int[] moveZ = {1 , 0 , 0 , 0 , 0 , -1};
    static int[] moveX = {0 , -1 , 0 , 1 , 0 , 0};
    static int[] moveY = {0 , 0 , 1 , 0 , -1 , 0};
    static int result = -1;
    static int x , y , z;
    static boolean flag = false;
    static Queue<Position> queue = new LinkedList<>();
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        y = Integer.parseInt(st.nextToken());
        x = Integer.parseInt(st.nextToken());
        z = Integer.parseInt(st.nextToken());
        map = new int[x][y][z];
        checked = new boolean[x][y][z];
        for(int i = 0 ; i < z ; i++){
            for(int j = 0 ; j < x ; j++){
                String[] line = br.readLine().split(" ");
                for(int k = 0 ; k < y ; k++){
                    int value = Integer.parseInt(line[k]);
                    if(value == 0) flag = true;
                    else if(value == 1){
                        queue.offer(new Position(j , k , i , 0));
                        checked[j][k][i] = true;
                    }
                    map[j][k][i] = value;
                }
            }
        }
        if(!flag){
            System.out.println(0);
        }
        else{
            bfs();
            for(int i = 0 ; i < z ; i++){
                for(int j = 0 ; j < x ; j++){
                    for(int k = 0 ; k < y ; k++){
                        if(map[j][k][i] == 0) {
                            System.out.println(-1);
                            System.exit(0);
                        }
                    }
                }
            }
            System.out.println(result);
        }
    }

    public static void bfs(){
        while(!queue.isEmpty()){
            Position now = queue.poll();
            for(int i = 0 ; i < 6 ; i++){
                int moveXpos = now.x + moveX[i];
                int moveYpos = now.y + moveY[i];
                int moveZpos = now.z + moveZ[i];
                if(moveXpos >= 0 && moveYpos >= 0 && moveZpos >= 0 && moveXpos < x && moveYpos < y && moveZpos < z){
                    if(map[moveXpos][moveYpos][moveZpos] == 0 && !checked[moveXpos][moveYpos][moveZpos]){
                        map[moveXpos][moveYpos][moveZpos] = 1;
                        checked[moveXpos][moveYpos][moveZpos] = true;
//                        System.out.println(moveXpos + " , " + moveYpos + " , " + moveZpos);
                        queue.offer(new Position(moveXpos , moveYpos , moveZpos , now.count + 1));
                        if(now.count + 1 > result) result = now.count + 1;
                    }
                }
            }
        }
    }
}
```

***

# **`[ë°±ì¤€] DFS` [íŠ¸ë¦¬ì˜ ë¶€ëª¨ ì°¾ê¸°](https://www.acmicpc.net/problem/11725)**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

class Main {
    static int[] printArr;
    static List<ArrayList<Integer>> list = new ArrayList<>();
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int size = Integer.parseInt(br.readLine());
        printArr = new int[size + 1];
        for(int i = 0 ; i < size + 1 ; i++) list.add(new ArrayList<Integer>());
        for(int i = 0 ; i < size - 1 ; i++){
            StringTokenizer st = new StringTokenizer(br.readLine());
            int parent = Integer.parseInt(st.nextToken());
            int child = Integer.parseInt(st.nextToken());
            list.get(parent).add(child);
            list.get(child).add(parent);
        }

        dfs(1);
        for(int i = 2 ; i < printArr.length ; i++){
            System.out.println(printArr[i]);
        }
    }

    public static void dfs(int parent){
        for(int value : list.get(parent)){
//            System.out.println(value);
            if(printArr[value] == 0){
                printArr[value] = parent;
                dfs(value);
            }
        }
    }
}
```

***

# **`[ë°±ì¤€] DFS` [ABCDE](https://www.acmicpc.net/problem/13023)**

```java
import java.io.*;
import java.util.*;

class Main {
    static List<ArrayList<Integer>> list = new ArrayList<>();
    static boolean[] checked;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int peopleCount = Integer.parseInt(st.nextToken());
        int relationCount = Integer.parseInt(st.nextToken());
        checked = new boolean[peopleCount];
        for(int i = 0 ; i < peopleCount ; i++) list.add(new ArrayList<Integer>());
        for(int i = 0 ; i < relationCount ; i++){
            st = new StringTokenizer(br.readLine());
            int first = Integer.parseInt(st.nextToken());
            int second = Integer.parseInt(st.nextToken());
            list.get(first).add(second);
            list.get(second).add(first);
        }
        for(int i = 0 ; i < list.size() ; i++){
            Arrays.fill(checked , false);
            checked[i] = true;
            dfs(i , 0);
        }
        System.out.println("0");
    }
    public static void dfs(int start , int depth){
        if(depth >= 4){
            System.out.println("1");
            System.exit(0);
        }
        else{
            for(int relationPeople : list.get(start)){
                if(!checked[relationPeople]){
                    checked[relationPeople] = true;
//                    System.out.println(start + " -> " + relationPeople + " : " + (depth + 1) );
                    dfs(relationPeople , depth + 1);
                    checked[relationPeople] = false;
                }
            }
        }
    }
}
```

***

# **`[ë°±ì¤€] BFS` [ì–‘](https://www.acmicpc.net/problem/3184)**

```java
import java.io.*;
import java.util.*;

class Main {
    static int[] moveX = {-1 , 0 , 1 , 0};
    static int[] moveY = {0 , 1 , 0 , -1};
    static char[][] map;
    static boolean[][] checked;
    static List<int[]> wolfPos = new ArrayList<>();
    static int rows , cols;
    static int sheepCount = 0, wolfCount = 0;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        rows = Integer.parseInt(st.nextToken());
        cols = Integer.parseInt(st.nextToken());
        map = new char[rows][cols];
        checked = new boolean[rows][cols];
        for(int i = 0 ; i < rows ; i++){
            char[] line = br.readLine().toString().toCharArray();
            for(int j = 0 ; j < line.length ; j++){
                char ch = line[j];
                map[i][j] = ch;
                if(ch == 'o') sheepCount++;
                else if(ch == 'v') {
                    wolfPos.add(new int[] {i , j});
                    wolfCount++;
                }
            }
        }

        for(int[] pos : wolfPos){
            if(!checked[pos[0]][pos[1]]){
                bfs(pos);
            }
        }
        System.out.println(sheepCount + " " + wolfCount);
    }
    public static void bfs(int[] pos){
        Queue<int[]> queue = new LinkedList<int[]>();
        queue.offer(pos);
        int areaSheepCount = 0;
        int areaWolfCount = 0;
        checked[pos[0]][pos[1]] = true;
        while(!queue.isEmpty()){
            int[] now = queue.poll();
            if(map[now[0]][now[1]] == 'o') areaSheepCount++;
            else if(map[now[0]][now[1]] == 'v') areaWolfCount++;
            for(int i = 0 ; i < 4 ; i++){
                int moveXpos = now[0] + moveX[i];
                int moveYpos = now[1] + moveY[i];
                if(moveXpos >= 0 && moveYpos >= 0 && moveXpos < rows && moveYpos < cols){
                    if(!checked[moveXpos][moveYpos] && map[moveXpos][moveYpos] != '#'){
                        checked[moveXpos][moveYpos] = true;
                        queue.offer(new int[] {moveXpos , moveYpos});
                    }
                }
            }
        }
        if(areaSheepCount > areaWolfCount) wolfCount -= areaWolfCount;
        else sheepCount -= areaSheepCount;
    }
}
```

***

# ğŸ”¥ **`[ë°±ì¤€] Next Permutationì„ êµ¬í˜„í•˜ëŠ” ë¬¸ì œ` [ë‹¤ìŒ ìˆœì—´](https://www.acmicpc.net/problem/10972) âŒ ğŸ“**

- [ì°¸ê³ ](https://pangtrue.tistory.com/327)

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int size = Integer.parseInt(br.readLine());
        StringTokenizer st = new StringTokenizer(br.readLine());
        int[] numberArr = new int[size];
        for(int i = 0 ; i < size ; i++){
            numberArr[i] = Integer.parseInt(st.nextToken());
        }

        if(nextPermutation(numberArr)){
            for(int value : numberArr) System.out.print(value + " ");
        }
        else System.out.println(-1);
    }

    public static boolean nextPermutation(int[] numberArr){
        int firstIndex = numberArr.length - 1;
        int secondIndex = numberArr.length - 1;

        // firstIndex -> ë’¤ì—ì„œ firstIndex - 1ì´ firstIndex ë³´ë‹¤ ê°™ê±°ë‚˜ í° ê²½ìš° ì°¾ìŒ
        while(firstIndex > 0 &&  numberArr[firstIndex - 1] >= numberArr[firstIndex]) firstIndex--;
        if(firstIndex <= 0) return false;

        // secondIndex -> ë‹¤ì‹œ ë’¤ì—ì„œ secondIndexê°€ firstIndex - 1 ë³´ë‹¤ ê°™ê±°ë‚˜ í° ê²½ìš° ì°¾ìŒ
        while(numberArr[firstIndex - 1] > numberArr[secondIndex]) secondIndex--;

        // firstIndex ì™€ secondIndex ìŠ¤ì™‘
        int tmpValue = numberArr[firstIndex - 1];
        numberArr[firstIndex - 1] = numberArr[secondIndex];
        numberArr[secondIndex] = tmpValue;

        // firstIndex ë¶€í„° ëê¹Œì§€ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬
//        System.out.println("firstIndex - " + firstIndex);
//        System.out.println("secondIndex - " + secondIndex);
        Arrays.sort(numberArr , firstIndex , numberArr.length);
        return true;
    }
}
```

***

# **`[ë°±ì¤€] DFS` [ëª¨ë“  ìˆœì—´](https://www.acmicpc.net/problem/10974)**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

class Main {
    static int[] numberArr;
    static int[] printArr;
    static int[] targetArr;
    static boolean[] checked;
    static StringBuilder result = new StringBuilder();
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int size = Integer.parseInt(br.readLine());
        numberArr = new int[size];
        printArr = new int[size];
        targetArr = new int[size];
        checked = new boolean[size];
        for(int i = 0 ; i < size ; i++){
            numberArr[i] = i + 1;
        }
        dfs(0);
        System.out.println(result.toString());
    }

    public static void dfs(int depth){
        if(depth == numberArr.length){
            for(int value : printArr) result.append(value).append(" ");
            result.append("\n");
        }
        else if(depth < numberArr.length){
            for(int i = 0 ; i < numberArr.length ; i++){
                if(!checked[i]){
                    checked[i] = true;
                    printArr[depth] = numberArr[i];
                    dfs(depth + 1);
                    checked[i] = false;
                }
            }
        }
    }
}
```

***

# **`[ë°±ì¤€] BFS` [ë‚˜ì´íŠ¸ì˜ ì´ë™](https://www.acmicpc.net/problem/7562)**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

class Main {
    static int[] startPos = new int[2];
    static int[] destiPos = new int[2];
    static int[] moveX = {-2 , -1 , 1 , 2 , 2 , 1 , -1 , -2};
    static int[] moveY = {1 , 2 , 2 , 1 , -1 , -2 , -2 , -1};
    static int[][] map;
    static boolean[][] checked;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int size = Integer.parseInt(br.readLine());
        for(int count = 0 ; count < size ; count++){
            int mapSize = Integer.parseInt(br.readLine());
            map = new int[mapSize][mapSize];
            checked = new boolean[mapSize][mapSize];
            String[] startRow = br.readLine().split(" ");
            startPos[0] = Integer.parseInt(startRow[0]);
            startPos[1] = Integer.parseInt(startRow[1]);
            String[] endRow = br.readLine().split(" ");
            destiPos[0] = Integer.parseInt(endRow[0]);
            destiPos[1] = Integer.parseInt(endRow[1]);
            bfs();
        }
    }
    public static void bfs(){
        Queue<int[]> queue = new LinkedList<int[]>();
        queue.offer(new int[]{startPos[0] , startPos[1] , 0});
        checked[startPos[0]][startPos[1]] = true;
        while(!queue.isEmpty()){
            int[] now = queue.poll();
            int nowX = now[0];
            int nowY = now[1];
            int nowCount = now[2];
            if(nowX == destiPos[0] && nowY == destiPos[1]){
                System.out.println(nowCount);
                break;
            }
            else{
                for(int i = 0 ; i < moveX.length ; i++){
                    int moveXpos = nowX + moveX[i];
                    int moveYpos = nowY + moveY[i];
                    if(moveXpos >= 0 && moveYpos >= 0 && moveXpos < map.length && moveYpos < map.length){
                        if(!checked[moveXpos][moveYpos]){
                            checked[moveXpos][moveYpos] = true;
                            queue.offer(new int[]{moveXpos , moveYpos , nowCount + 1});
                        }
                    }
                }
            }
        }
    }
}
```


***

# **`[ë°±ì¤€] DP` [1ë¡œ ë§Œë“¤ê¸°](https://www.acmicpc.net/problem/1463) âŒ**

```java

```

***

# **`[ë°±ì¤€] ë¶„í• ì •ë³µ` [íˆìŠ¤í† ê·¸ë¨](https://www.acmicpc.net/problem/1725) âŒ**

- [ì°¸ê³ ](https://st-lab.tistory.com/255)
- [Segmant Tree](https://m.blog.naver.com/ndb796/221282210534)

```java

```

***

# **`[ë°±ì¤€] Stack` [ê²€ì—´](https://www.acmicpc.net/problem/3111) <span style="color:red; font-weight:bold">ì¶œë ¥ì´ˆê³¼</span> âŒ**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;


class Main {
    static String removeStr;
    static String str;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        removeStr = br.readLine();
        str = br.readLine();
        if(removeStr.length() <= 0) System.out.println(str);
        else System.out.println(solution());
    }

    public static String solution(){
        StringBuilder resultString = new StringBuilder();
        Stack<Character> stack = new Stack<>();
        Stack<Character> revStack = new Stack<>();
        int leftIndex = 0 , rightIndex = str.length() - 1;
        boolean reverseFlag = false;
        while(leftIndex <= rightIndex){
            if(!reverseFlag && leftIndex < str.length()){
                stack.push(str.charAt(leftIndex++));
                if(stack.size() >= removeStr.length() && stack.peek() == removeStr.charAt(removeStr.length() - 1)){
                    if(duplCheck(stack)) reverseFlag = true;
                }
            }
            if(reverseFlag && leftIndex <= rightIndex){
                revStack.push(str.charAt(rightIndex--));
                if(revStack.size() >= removeStr.length() && revStack.peek() == removeStr.charAt(removeStr.length() - 1)){
                    if(duplCheck(revStack)) reverseFlag = false;
                }
            }
        }
        // ì¶œë ¥ ì´ˆê³¼ !!!
        for(char ch : stack) resultString.append(ch);
        for(int i = revStack.size() - 1 ; i >= 0 ; i--) resultString.append(revStack.get(i));
        while(true){
            int removeIndex = resultString.indexOf(removeStr);
            if(removeIndex < 0) break;
            resultString.delete(removeIndex , removeIndex + removeStr.length());
        }
        return resultString.toString();
    }

    public static boolean duplCheck(Stack<Character> stack){
        int removeStrLength = removeStr.length() - 1;
        boolean flag = true;
        for(int i = stack.size() - 1 ; i >= stack.size() - removeStr.length() ; i--){
            if(stack.get(i) != removeStr.charAt(removeStrLength--)){
                flag = false;
                break;
            }
        }
        if(flag) {
            for (int i = 0; i < removeStr.length(); i++) {
                stack.pop();
            }
        }
        return flag;
    }
}
```

***

# **`[ë°±ì¤€] BFS` [A->B](https://www.acmicpc.net/problem/16953)**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        double start = Double.parseDouble(st.nextToken());
        double target = Double.parseDouble(st.nextToken());
        bfs(start , target);
        System.out.println(-1);
    }

    public static void bfs(double start , double target){
        Queue<double[]> queue = new LinkedList<>();
        queue.offer(new double[] {start , 1});
        while(!queue.isEmpty()){
            double[] now = queue.poll();
            double nowValue = now[0];

            double count = now[1];
            if(nowValue == target){
                System.out.println((int)count);
                System.exit(0);
            }
            else{
                double value1 = nowValue * 2;
                double value2 = nowValue * 10 + 1;
                if(value1 <= target) queue.offer(new double[]{value1 , count + 1});
                if(value2 <= target) queue.offer(new double[]{value2 , count + 1});
            }
        }
    }
}
```

***

# **`[ë°±ì¤€ BFS]` [ì´Œìˆ˜ê³„ì‚°](https://www.acmicpc.net/problem/2644)**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

class Main {
    static List<List<Integer>> list = new ArrayList<>();
    static int start , target;
    static boolean[] checked;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int people = Integer.parseInt(br.readLine());
        checked = new boolean[people + 1];
        for(int i = 0 ; i < people + 1; i++) list.add(new ArrayList<>());

        StringTokenizer st = new StringTokenizer(br.readLine());
        start = Integer.parseInt(st.nextToken());
        target = Integer.parseInt(st.nextToken());
        int count = Integer.parseInt(br.readLine());
        for(int i = 0 ; i < count ; i++){
            st = new StringTokenizer(br.readLine());
            int people1 = Integer.parseInt(st.nextToken());
            int people2 = Integer.parseInt(st.nextToken());
            list.get(people1).add(people2);
            list.get(people2).add(people1);
        }
        bfs(start);
        System.out.println("-1");
    }
    public static void bfs(int start){
        Queue<int[]> queue = new LinkedList<>();
        queue.offer(new int[] {start , 0});
        while(!queue.isEmpty()){
            int[] now = queue.poll();
            int people = now[0];
            int count = now[1];
            if(people == target){
                System.out.println(count);
                System.exit(0);
            }
            else {
                for(int relationalPeople : list.get(people)){
                    if(!checked[relationalPeople]){
                        checked[relationalPeople] = true;
                        queue.offer(new int[]{relationalPeople , count + 1});
                    }
                }
            }
        }
    }
}
```

***

# ğŸ”¥ **`[ë°±ì¤€ BFS]` [ìˆ¨ë°”ê¼­ì§ˆ3](https://www.acmicpc.net/problem/13549)**

- ì›ë˜ ì´ ë¬¸ì œëŠ” ë‹¨ìˆœí•œ BFSë¥¼ ìš”êµ¬í•˜ëŠ” ë¬¸ì œê°€ ì•„ë‹™ë‹ˆë‹¤.
- ì™œëƒí•˜ë©´, BFSë¥¼ í•˜ê¸° ìœ„í•´ì„œëŠ” ëª¨ë“  ê°„ì„ ì˜ ê°€ì¤‘ì¹˜ê°€ ë™ì¼í•´ì•¼ í•œë‹¤ëŠ” ì „ì œ ì¡°ê±´ì´ í•„ìš”í•˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.
- ì´ ë¬¸ì œëŠ” ê°€ì¤‘ì¹˜ê°€ 0ì¸ ê°„ì„ ì´ ìˆê¸° ë•Œë¬¸ì— ì¼ë°˜ì ìœ¼ë¡œëŠ” ë‹¨ìˆœí•œ BFSë¥¼ ì“¸ ìˆ˜ ì—†ìœ¼ë‚˜, ë¬¸ì œì˜ íŠ¹ì„± ë•Œë¬¸ì— ë°©ë¬¸ ìˆœì„œì— ë”°ë¼ì„œ ë‹¨ìˆœ BFSë¡œë„ ìš°ì—°íˆë„ í•­ìƒ ì •ë‹µì„ ì°¾ì„ ìˆ˜ ìˆì„ ë¿ì…ë‹ˆë‹¤.
- ì™œ í•˜í•„ ì´ ìˆœì„œë¡œ í•˜ë©´ í•­ìƒ ì •ë‹µì´ ë‚˜ì˜¤ëŠ”ê°€ë¥¼ ì¦ëª…í•˜ëŠ” ê±´ ë§¤ìš° ë³µì¡í•œ ì¼ì…ë‹ˆë‹¤.

- ì´ ë¬¸ì œë¥¼ ë³´ë‹¤ ì¼ë°˜í™”ëœ ê²½ìš° (ê°€ì¤‘ì¹˜ê°€ 0ì¸ ê°„ì„ ì´ ìˆëŠ” ê²½ìš°)ì— ëŒ€í•´ í•´ê²°í•˜ë ¤ë©´, ì¦‰, ì´ ë¬¸ì œì˜ ì˜ë„ëŒ€ë¡œ í’€ë ¤ë©´ ë‹¤ìŒê³¼ ê°™ì€ ë°©ë²•ë“¤ì„ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
	- **ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜**
	- **0-1 BFS** : ê°€ì¤‘ì¹˜ê°€ 0ì¸ ê°„ì„ ì— ì—°ê²°ëœ ì •ì ì€ íì˜ ë§¨ ë’¤ê°€ ì•„ë‹Œ ë§¨ ì•ì— ë„£ëŠ” ë°©ë²•
	- `* 2`ë¥¼ ë³„ë„ì˜ ê°„ì„ ìœ¼ë¡œ ìƒê°í•˜ì§€ ì•Šê³ , +1ì´ë‚˜ -1ì— ì˜í•œ ì¢Œí‘œë¥¼ íì— ë„£ì„ ë•Œ ê·¸ ì¢Œí‘œì˜ 2ì˜ ê±°ë“­ì œê³± ë°°ì¸ ì¢Œí‘œë“¤ì„ ì „ë¶€ íì— ë„£ëŠ” ë°©ë²•
- [ì°¸ê³ ](https://www.acmicpc.net/board/view/38887#comment-69010)


```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

class Main {
    static int[] move = {1 , -1 , 2};
    static int[] distance;
    static int start , destination;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        start = Integer.parseInt(st.nextToken());
        destination = Integer.parseInt(st.nextToken());
        distance = new int[100002];
        Arrays.fill(distance , Integer.MAX_VALUE);
        bfs();
    }

    public static void bfs(){
        Queue<int[]> queue = new LinkedList<int[]>();
        queue.offer(new int[] {start , 0});
        distance[start] = 0;
        while(!queue.isEmpty()){
            int[] now = queue.poll();
            if(now[0] == destination){
                System.out.println(now[1]);
                System.exit(0);
            }
            for(int i = 2 ; i >= 0 ; i--){
                int movePos = i == 2 ? now[0] * move[i] : now[0] + move[i];
                int moveCnt = i == 2 ? now[1] : now[1] + 1;
                if(movePos >= 0 && movePos < 100002 && distance[movePos] >= moveCnt){
                    distance[movePos] = moveCnt;
                    queue.offer(new int[] {movePos , moveCnt});
                }
            }
        }
    }
}
```

***

# **`[ë°±ì¤€ BFS]` [ìˆ¨ë°”ê¼­ì§ˆ4](https://www.acmicpc.net/problem/13913)**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

class Main {
    static int[] move = {1 , -1 , 2};
    static int[] moveDistance;
    static int[] distance;
    static int start , destination;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        start = Integer.parseInt(st.nextToken());
        destination = Integer.parseInt(st.nextToken());
        moveDistance = new int[100002];
        distance = new int[100002];
        Arrays.fill(distance , Integer.MAX_VALUE);
        bfs();
    }

    public static void bfs(){
        Queue<int[]> queue = new LinkedList<int[]>();
        queue.offer(new int[] {start , 0});
        while(!queue.isEmpty()){
            int[] now = queue.poll();
            if(now[0] == destination){
                System.out.println(now[1]);
                int footPrintIndex = destination;
                Deque<Integer> footPrint = new LinkedList<>();
                footPrint.addFirst(footPrintIndex);
                while(footPrintIndex != start){
                    footPrint.addFirst(moveDistance[footPrintIndex]);
//                    System.out.println(moveDistance[footPrintIndex] + " : " + footPrintIndex);
                    footPrintIndex = moveDistance[footPrintIndex];
                }
                while(!footPrint.isEmpty()){
                    System.out.print(footPrint.poll() + " ");
                }
                System.exit(0);
            }
            for(int i = 2 ; i >= 0 ; i--){
                int movePos = i == 2 ? now[0] * move[i] : now[0] + move[i];
                int moveCnt = now[1] + 1;
                if(movePos >= 0 && movePos < 100002 && distance[movePos] >= moveCnt){
                    distance[movePos] = moveCnt;
                    moveDistance[movePos] = now[0];
                    queue.offer(new int[] {movePos , moveCnt});
                }
            }
        }
    }
}
```

***

# **`[ë°±ì¤€] BFS` [ì•Œê³ ìŠ¤íŒŸ](https://www.acmicpc.net/problem/1261) âŒ**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

class Position{
    int x;
    int y;
    int breakWall;
    public Position(int x, int y, int breakWall) {
        this.x = x;
        this.y = y;
        this.breakWall = breakWall;
    }
}

class Main {
    static int[] moveX = {-1 , 0 , 1 , 0};
    static int[] moveY = {0 , 1 , 0 , -1};
    static int[][] map;
    static boolean[][] visited;
    static List<Integer> resultList = new ArrayList<>();
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int y = Integer.parseInt(st.nextToken());
        int x = Integer.parseInt(st.nextToken());
        map = new int[x][y];
        visited = new boolean[x][y];
        for(int i = 0 ; i < x ; i++){
            String[] line = br.readLine().split("");
            for(int j = 0 ; j < y ; j++){
                map[i][j] = Integer.parseInt(line[j]);
            }
        }
        start(x - 1, y - 1);
        System.out.println(resultList);
    }

    public static void start(int targetX , int targetY){
        Queue<Position> queue = new LinkedList<>();
        queue.offer(new Position(0 , 0 ,0));
        while(!queue.isEmpty()){
            Position now = queue.poll();
            if(now.x == targetX && now.y == targetY){
                resultList.add(now.breakWall);
            }
            else {
                for (int i = 0; i < 4; i++) {
                    int moveXpos = now.x + moveX[i];
                    int moveYpos = now.y + moveY[i];
                    if (moveXpos >= 0 && moveYpos >= 0 && moveXpos <= targetX && moveYpos <= targetY && !visited[moveXpos][moveYpos]) {
                        if (map[moveXpos][moveYpos] == 1) {
                            queue.offer(new Position(moveXpos, moveYpos, now.breakWall + 1));
                        } else queue.offer(new Position(moveXpos, moveYpos, now.breakWall));
                        visited[moveXpos][moveYpos] = true;
                    }
                }
            }
        }
    }
}
```
