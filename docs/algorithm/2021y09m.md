---
layout: default
title: 2021ÎÖÑ9Ïõî
nav_order: 5
parent: ÏïåÍ≥†Î¶¨Ï¶ò
---
## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---


# **`[Î∞±Ï§Ä] BFS` [ÎØ∏Î°úÌÉêÏÉâ](https://www.acmicpc.net/problem/2178)**


```java
package algo;

import java.util.*;
import java.io.*;

public class Main {
	static int[] moveX = {-1 , 0 , 1 , 0};
    static int[] moveY = {0 , 1 , 0 , -1};
	static int[][] maze;
	static boolean[][] checked;
	static int x , y;
    public static void main(String[] args) throws IOException {
    	BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    	StringTokenizer st = new StringTokenizer(br.readLine());
    	x = Integer.parseInt(st.nextToken());
    	y = Integer.parseInt(st.nextToken());
    	maze = new int[x][y];
    	checked = new boolean[x][y];
    	for(int i = 0 ; i < x ; i++) {
    		String[] line = br.readLine().split("");
    		for(int j = 0 ; j < y ; j++) {
    			maze[i][j] = Integer.parseInt(line[j]);
    		}
    	}
    	checked[0][0] = true;
    	bfs();
    }

    public static void bfs() {
    	Queue<int[]> queue = new LinkedList<int[]>();
    	queue.offer(new int[] {0 , 0 , 1});
    	while(!queue.isEmpty()) {
    		int[] nowArr = queue.poll();
    		int nowX = nowArr[0];
    		int nowY = nowArr[1];
    		int moveCount = nowArr[2];
			if(nowX == x - 1 && nowY == y - 1) {
				System.out.println(moveCount);
				System.exit(0);
			}
			else {
				for(int i = 0 ; i < 4 ; i++) {
	    			int moveXpos = nowX + moveX[i];
	    			int moveYpos = nowY + moveY[i];
	    			if(moveXpos >= 0 && moveYpos >= 0 && moveXpos < x && moveYpos < y && maze[moveXpos][moveYpos] == 1 && !checked[moveXpos][moveYpos]){
	    				checked[moveXpos][moveYpos] = true;
	    				queue.offer(new int[] {moveXpos , moveYpos , moveCount + 1});
	    			}
	    		}
			}
    	}
    }
}
```

***

# **`[Î∞±Ï§Ä] DFS` [Î∞îÏù¥Îü¨Ïä§](https://www.acmicpc.net/problem/2606)**


```java
import java.util.*;
import java.io.*;

public class Main {
	static List<ArrayList<Integer>> link = new ArrayList<>();
	static boolean[] checked;
	static int nodeSize , rowSize;
	static int result = 0;
    public static void main(String[] args) throws IOException {
    	BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    	StringTokenizer st;
    	nodeSize = Integer.parseInt(br.readLine());
    	rowSize = Integer.parseInt(br.readLine());
    	checked = new boolean[nodeSize + 1];
    	for(int i = 0 ; i < nodeSize + 1 ; i++) link.add(new ArrayList<Integer>());
    	for(int i = 0 ; i < rowSize ; i++) {
    		st = new StringTokenizer(br.readLine());
    		int start = Integer.parseInt(st.nextToken());
    		int end = Integer.parseInt(st.nextToken());
    		link.get(start).add(end);
    		link.get(end).add(start);
    	}
//    	bfs(); // Î©îÎ™®Î¶¨ Ï¥àÍ≥º
    	checked[1] = true;
    	dfs(1);
    	System.out.println(result);
    }

    public static void bfs() {
    	Queue<Integer> queue = new LinkedList<Integer>();
    	queue.offer(1);
    	while(!queue.isEmpty()) {
    		int node = queue.poll();
    		for(int newNode : link.get(node)) {
    			queue.offer(newNode);
    			result++;
    		}
    	}
    }

    public static void dfs(int node) {
    	for(int nearNode : link.get(node)) {
    		if(!checked[nearNode]) {
    			checked[nearNode] = true;
        		result++;
        		dfs(nearNode);
    		}
    	}
    }
}
```

***

# üî• **`[Î∞±Ï§Ä] DFS - Î∞±Ìä∏ÎûòÌÇπ` [NÍ≥º M (9)](https://www.acmicpc.net/problem/15663)**

```java
import java.io.*;
import java.util.*;

public class Main {
    static boolean[] checked;
    static int[] printArr;
    static int[] numArr;
    static StringBuilder result;
    static int num1 , num2;
    static int prevNum = Integer.MIN_VALUE;
    static LinkedHashSet<String> resultSet = new LinkedHashSet<>();
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        num1 = Integer.parseInt(st.nextToken());
        num2 = Integer.parseInt(st.nextToken());
        st = new StringTokenizer(br.readLine());
        numArr = new int[num1];
        for(int i = 0 ; i < num1 ; i++){
            numArr[i] = Integer.parseInt(st.nextToken());
        }
        checked = new boolean[num1];
        printArr = new int[num2];
        Arrays.sort(numArr);
        recursive(0);
        resultSet.forEach(System.out::println);
    }

    public static void recursive(int index){
        if(index == num2){
            result = new StringBuilder();
            for(int value : printArr){
                result.append(value).append(" ");
            }
            resultSet.add(result.toString());
            return;
        }
        else{
            for(int j = 0 ; j < num1 ; j++){
                if(!checked[j]){
                    checked[j] = true;
                    printArr[index] = numArr[j];
                    recursive(index + 1);
                    checked[j] = false;
                }
            }
        }
    }
}
```

***

# **`[Î∞±Ï§Ä] DFS - Î∞±Ìä∏ÎûòÌÇπ` [NÍ≥º M (10)](https://www.acmicpc.net/problem/15664)**

```java
import java.io.*;
import java.util.*;

public class Main {
    static boolean[] checked;
    static int[] printArr;
    static int[] numArr;
    static StringBuilder result;
    static int num1 , num2;
    static int prevNum = Integer.MIN_VALUE;
    static LinkedHashSet<String> resultSet = new LinkedHashSet<>();
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        num1 = Integer.parseInt(st.nextToken());
        num2 = Integer.parseInt(st.nextToken());
        st = new StringTokenizer(br.readLine());
        numArr = new int[num1];
        for(int i = 0 ; i < num1 ; i++){
            numArr[i] = Integer.parseInt(st.nextToken());
        }
        checked = new boolean[num1];
        printArr = new int[num2];
        Arrays.sort(numArr);
        recursive(0,0);
        resultSet.forEach(System.out::println);
    }

    public static void recursive(int start , int index){
        if(index == num2){
            result = new StringBuilder();
            for(int value : printArr){
                result.append(value).append(" ");
            }
            resultSet.add(result.toString());
            return;
        }
        else{
            for(int j = start ; j < num1 ; j++){
                if(!checked[j]){
                    checked[j] = true;
                    printArr[index] = numArr[j];
                    recursive(j , index + 1);
                    checked[j] = false;
                }
            }
        }
    }
}
```

***

# **`[Î∞±Ï§Ä] DFS - Î∞±Ìä∏ÎûòÌÇπ` [NÍ≥º M (11)](https://www.acmicpc.net/problem/15665)**

```java
import java.io.*;
import java.util.*;

public class Main {
    static int[] printArr;
    static int[] numArr;
    static StringBuilder result = new StringBuilder();
    static int num1 , num2;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        num1 = Integer.parseInt(st.nextToken());
        num2 = Integer.parseInt(st.nextToken());
        st = new StringTokenizer(br.readLine());
        numArr = new int[num1];
        for(int i = 0 ; i < num1 ; i++){
            numArr[i] = Integer.parseInt(st.nextToken());
        }
        printArr = new int[num2];
        Arrays.sort(numArr);
        recursive(0);
        System.out.println(result.toString());
    }

    public static void recursive(int index){
        if(index == num2){
            for(int value : printArr){
                result.append(value).append(" ");
            }
            result.append("\n");
            return;
        }
        else{
            for(int j = 0 ; j < num1 ; j++){
                if(printArr[index] != numArr[j]){
                    printArr[index] = numArr[j];
                    recursive(index + 1);
                }
            }
        }
    }
}
```

***

# **`[Î∞±Ï§Ä] DFS - Î∞±Ìä∏ÎûòÌÇπ` [NÍ≥º M (12)](https://www.acmicpc.net/problem/15666)**

```java
import java.io.*;
import java.util.*;

public class Main {
    static int[] printArr;
    static int[] numArr;
    static StringBuilder result;
    static LinkedHashSet<String> resultSet = new LinkedHashSet<>();
    static int num1 , num2;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        num1 = Integer.parseInt(st.nextToken());
        num2 = Integer.parseInt(st.nextToken());
        st = new StringTokenizer(br.readLine());
        numArr = new int[num1];
        for(int i = 0 ; i < num1 ; i++){
            numArr[i] = Integer.parseInt(st.nextToken());
        }
        printArr = new int[num2];
        Arrays.sort(numArr);
        recursive(0 ,0);
        resultSet.forEach(System.out::println);
    }

    public static void recursive(int start , int index){
        if(index == num2){
            result = new StringBuilder();
            for(int value : printArr){
                result.append(value).append(" ");
            }
            resultSet.add(result.toString());
            return;
        }
        else{
            for(int j = start ; j < num1 ; j++){
                printArr[index] = numArr[j];
                recursive(j ,index + 1);
            }
        }
    }
}
```

***

# **`[Î∞±Ï§Ä] DFS - Î∞±Ìä∏ÎûòÌÇπ` [Ïó∞ÏÇ∞Ïûê ÎÅºÏõåÎÑ£Í∏∞](https://www.acmicpc.net/problem/14888) ‚ùå**

```java
import java.util.*;
import java.io.*;

public class Main {
	static int[] symbolArr = new int[4];
	static int[] numArr;
	static int[] printArr;
	static boolean[] checked;
	static int max = Integer.MIN_VALUE, min = Integer.MAX_VALUE;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int size = Integer.parseInt(br.readLine());
        numArr = new int[size];
        checked = new boolean[size];
        printArr = new int[size];
        StringTokenizer st = new StringTokenizer(br.readLine());
        for(int i = 0 ; i < size ; i++) {
        	numArr[i] = Integer.parseInt(st.nextToken());
        }
        st = new StringTokenizer(br.readLine());
        symbolArr[0] = Integer.parseInt(st.nextToken());
        symbolArr[1] = Integer.parseInt(st.nextToken());
        symbolArr[2] = Integer.parseInt(st.nextToken());
        symbolArr[3] = Integer.parseInt(st.nextToken());

        recursive(0);
        System.out.println(max + "\n" + min);
    }
    public static void recursive(int count) {
    	if(count == numArr.length) {
    		int resultValue = printArr[0];
    		int index = 1;
    		for(int i = 0 ; i < symbolArr.length ; i++) {
    			for(int j = 0 ; j < symbolArr[i] ; j++) {
    				if(i == 0) resultValue += printArr[index];
    				else if(i == 1) resultValue -= printArr[index];
    				else if(i == 2) resultValue *= printArr[index];
    				else if(i == 3) {
    					if(resultValue < 0) {
    						resultValue = (Math.abs(resultValue) / printArr[index]) * -1;
    					}
    					else if(printArr[index] != 0){
//    						resultValue = resultValue / printArr[index];
    					}
    				}
    				System.out.print(printArr[index]);
    				index++;
    			}
    			System.out.println();
    		}
    		max = Math.max(resultValue, max);
    		min = Math.min(resultValue, min);
    	}
    	else if(count < numArr.length){
    		for(int i = count ; i < numArr.length ; i++) {
    			printArr[i] = numArr[i];
    			recursive(count + 1);
    		}
    	}
    }
}
```

***

# **`[Î∞±Ï§Ä] BFS` [Ïú†Í∏∞ÎÜç Î∞∞Ï∂î](https://www.acmicpc.net/problem/1012)**

```java
import java.io.*;
import java.util.*;


public class Main {
	static int[] moveX = {-1 , 0 , 1 , 0};
    static int[] moveY = {0 , 1 , 0 , -1};
    static int[][] map;
    static int resultCount;
    static int x , y;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int testCase = Integer.parseInt(br.readLine());
        for(int test = 0 ; test < testCase ; test++) {
        	resultCount = 0;
        	StringTokenizer st = new StringTokenizer(br.readLine());
        	x = Integer.parseInt(st.nextToken());
        	y = Integer.parseInt(st.nextToken());
        	int count = Integer.parseInt(st.nextToken());
        	map = new int[x][y];
        	for(int j = 0 ; j < count ; j++) {
        		st = new StringTokenizer(br.readLine());
        		int posX = Integer.parseInt(st.nextToken());
        		int posY = Integer.parseInt(st.nextToken());
        		map[posX][posY] = 1;
        	}
        	for(int i = 0 ; i < x ; i++) {
        		for(int j = 0 ; j < y ; j++) {
        			if(map[i][j] == 1) {
        				map[i][j] = 0;
        				resultCount++;
        				bfs(i , j);
        			}
        		}
        	}
        	System.out.println(resultCount);
        }
    }

    public static void bfs(int locX , int locY) {
    	Queue<int[]> queue = new LinkedList<int[]>();
    	queue.offer(new int[] {locX , locY});
    	while(!queue.isEmpty()) {
    		int[] now = queue.poll();
    		int nowX = now[0];
    		int nowY = now[1];
    		for(int i = 0 ; i < 4 ; i++) {
    			int moveXpos = nowX + moveX[i];
    			int moveYpos = nowY + moveY[i];
    			if(moveXpos >= 0 && moveYpos >= 0 && moveXpos < x && moveYpos < y && map[moveXpos][moveYpos] == 1) {
    				map[moveXpos][moveYpos] = 0;
    				queue.offer(new int[] {moveXpos , moveYpos});
    			}
    		}
    	}
    }
}
```

***

# **`[Î∞±Ï§Ä] BFS` [Ïó∞Í≤∞ ÏöîÏÜåÏùò Í∞úÏàò](https://www.acmicpc.net/problem/11724)**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

class Main {
    static boolean[] checked;
    static List<List<Integer>> list = new ArrayList<>();
    static int result = 0;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int vertex = Integer.parseInt(st.nextToken());
        int edge = Integer.parseInt(st.nextToken());
        checked = new boolean[vertex + 1];
        for(int i = 0 ; i <= vertex ; i++) list.add(new ArrayList<Integer>());
        for(int i = 0 ; i < edge ; i++){
            st = new StringTokenizer(br.readLine());
            int vertex1 = Integer.parseInt(st.nextToken());
            int vertex2 = Integer.parseInt(st.nextToken());
            list.get(vertex1).add(vertex2);
            list.get(vertex2).add(vertex1);
        }

        for(int i = 1 ; i <= vertex ; i++){
            if(!checked[i]){
                result++;
                bfs(i);
            }
        }

        System.out.println(result);
    }

    public static void bfs(int vertex){
        Queue<Integer> queue = new LinkedList<>();
        queue.offer(vertex);
        while(!queue.isEmpty()){
            int nowVertex = queue.poll();
            checked[nowVertex] = true;
            for(int linkVertex : list.get(nowVertex)){
                if(!checked[linkVertex]){
                    checked[linkVertex] = true;
                    queue.offer(linkVertex);
                }
            }
        }
    }
}
```

***

# **`[Î∞±Ï§Ä] BFS` [ÏÑ¨Ïùò Í∞úÏàò](https://www.acmicpc.net/problem/4963)**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

class Main {
    static int[] moveX = new int[] {-1 , -1 , 0 , 1 , 1 , 1 , 0 , -1};
    static int[] moveY = new int[] {0 , 1 , 1 , 1 , 0 , -1 , -1 , -1};
    static int[][] map;
    static int result;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;
        while(true){
            st = new StringTokenizer(br.readLine());
            int width = Integer.parseInt(st.nextToken());
            int height = Integer.parseInt(st.nextToken());
            if(width == 0 && height == 0){
                break;
            }
            result = 0;
            map = new int[height][width];
            for(int i = 0 ; i < height ; i++){
                String[] line = br.readLine().split(" ");
                for(int j = 0 ; j < width ; j++){
                    map[i][j] = Integer.parseInt(line[j]);
                }
            }
            for(int i = 0 ; i < height ; i++){
                for(int j = 0 ; j < width ; j++){
                    if(map[i][j] == 1){
                        result++;
                        bfs(i , j , height , width);
                    }
                }
            }
            System.out.println(result);
        }
    }
    public static void bfs(int x , int y , int height , int width){
        Queue<int[]> queue = new LinkedList<>();
        queue.offer(new int[] {x , y});
        while(!queue.isEmpty()){
            int[] now = queue.poll();
            int nowX = now[0];
            int nowY = now[1];
            for(int i = 0 ; i < 8 ; i++){
                int moveXpos = nowX + moveX[i];
                int moveYpos = nowY + moveY[i];
                if(moveXpos >= 0 && moveYpos >= 0 && moveXpos < height && moveYpos < width && map[moveXpos][moveYpos] == 1){
                    map[moveXpos][moveYpos] = 0;
                    queue.offer(new int[] {moveXpos , moveYpos});
                }
            }
        }
    }
}
```

***

# **`[Î∞±Ï§Ä] BFS` [ÌÜ†ÎßàÌÜ†](https://www.acmicpc.net/problem/7569)**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

class Position{
    int x;
    int y;
    int z;
    int count;
    public Position(int x, int y, int z , int count) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.count = count;
    }
}

class Main {
    static int[][][] map;
    static boolean[][][] checked;
    static int[] moveZ = {1 , 0 , 0 , 0 , 0 , -1};
    static int[] moveX = {0 , -1 , 0 , 1 , 0 , 0};
    static int[] moveY = {0 , 0 , 1 , 0 , -1 , 0};
    static int result = -1;
    static int x , y , z;
    static boolean flag = false;
    static Queue<Position> queue = new LinkedList<>();
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        y = Integer.parseInt(st.nextToken());
        x = Integer.parseInt(st.nextToken());
        z = Integer.parseInt(st.nextToken());
        map = new int[x][y][z];
        checked = new boolean[x][y][z];
        for(int i = 0 ; i < z ; i++){
            for(int j = 0 ; j < x ; j++){
                String[] line = br.readLine().split(" ");
                for(int k = 0 ; k < y ; k++){
                    int value = Integer.parseInt(line[k]);
                    if(value == 0) flag = true;
                    else if(value == 1){
                        queue.offer(new Position(j , k , i , 0));
                        checked[j][k][i] = true;
                    }
                    map[j][k][i] = value;
                }
            }
        }
        if(!flag){
            System.out.println(0);
        }
        else{
            bfs();
            for(int i = 0 ; i < z ; i++){
                for(int j = 0 ; j < x ; j++){
                    for(int k = 0 ; k < y ; k++){
                        if(map[j][k][i] == 0) {
                            System.out.println(-1);
                            System.exit(0);
                        }
                    }
                }
            }
            System.out.println(result);
        }
    }

    public static void bfs(){
        while(!queue.isEmpty()){
            Position now = queue.poll();
            for(int i = 0 ; i < 6 ; i++){
                int moveXpos = now.x + moveX[i];
                int moveYpos = now.y + moveY[i];
                int moveZpos = now.z + moveZ[i];
                if(moveXpos >= 0 && moveYpos >= 0 && moveZpos >= 0 && moveXpos < x && moveYpos < y && moveZpos < z){
                    if(map[moveXpos][moveYpos][moveZpos] == 0 && !checked[moveXpos][moveYpos][moveZpos]){
                        map[moveXpos][moveYpos][moveZpos] = 1;
                        checked[moveXpos][moveYpos][moveZpos] = true;
//                        System.out.println(moveXpos + " , " + moveYpos + " , " + moveZpos);
                        queue.offer(new Position(moveXpos , moveYpos , moveZpos , now.count + 1));
                        if(now.count + 1 > result) result = now.count + 1;
                    }
                }
            }
        }
    }
}
```

***

# **`[Î∞±Ï§Ä] DFS` [Ìä∏Î¶¨Ïùò Î∂ÄÎ™® Ï∞æÍ∏∞](https://www.acmicpc.net/problem/11725)**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

class Main {
    static int[] printArr;
    static List<ArrayList<Integer>> list = new ArrayList<>();
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int size = Integer.parseInt(br.readLine());
        printArr = new int[size + 1];
        for(int i = 0 ; i < size + 1 ; i++) list.add(new ArrayList<Integer>());
        for(int i = 0 ; i < size - 1 ; i++){
            StringTokenizer st = new StringTokenizer(br.readLine());
            int parent = Integer.parseInt(st.nextToken());
            int child = Integer.parseInt(st.nextToken());
            list.get(parent).add(child);
            list.get(child).add(parent);
        }

        dfs(1);
        for(int i = 2 ; i < printArr.length ; i++){
            System.out.println(printArr[i]);
        }
    }

    public static void dfs(int parent){
        for(int value : list.get(parent)){
//            System.out.println(value);
            if(printArr[value] == 0){
                printArr[value] = parent;
                dfs(value);
            }
        }
    }
}
```

***

# **`[Î∞±Ï§Ä] DFS` [ABCDE](https://www.acmicpc.net/problem/13023)**

```java
import java.io.*;
import java.util.*;

class Main {
    static List<ArrayList<Integer>> list = new ArrayList<>();
    static boolean[] checked;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int peopleCount = Integer.parseInt(st.nextToken());
        int relationCount = Integer.parseInt(st.nextToken());
        checked = new boolean[peopleCount];
        for(int i = 0 ; i < peopleCount ; i++) list.add(new ArrayList<Integer>());
        for(int i = 0 ; i < relationCount ; i++){
            st = new StringTokenizer(br.readLine());
            int first = Integer.parseInt(st.nextToken());
            int second = Integer.parseInt(st.nextToken());
            list.get(first).add(second);
            list.get(second).add(first);
        }
        for(int i = 0 ; i < list.size() ; i++){
            Arrays.fill(checked , false);
            checked[i] = true;
            dfs(i , 0);
        }
        System.out.println("0");
    }
    public static void dfs(int start , int depth){
        if(depth >= 4){
            System.out.println("1");
            System.exit(0);
        }
        else{
            for(int relationPeople : list.get(start)){
                if(!checked[relationPeople]){
                    checked[relationPeople] = true;
//                    System.out.println(start + " -> " + relationPeople + " : " + (depth + 1) );
                    dfs(relationPeople , depth + 1);
                    checked[relationPeople] = false;
                }
            }
        }
    }
}
```

***

# **`[Î∞±Ï§Ä] BFS` [Ïñë](https://www.acmicpc.net/problem/3184)**

```java
import java.io.*;
import java.util.*;

class Main {
    static int[] moveX = {-1 , 0 , 1 , 0};
    static int[] moveY = {0 , 1 , 0 , -1};
    static char[][] map;
    static boolean[][] checked;
    static List<int[]> wolfPos = new ArrayList<>();
    static int rows , cols;
    static int sheepCount = 0, wolfCount = 0;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        rows = Integer.parseInt(st.nextToken());
        cols = Integer.parseInt(st.nextToken());
        map = new char[rows][cols];
        checked = new boolean[rows][cols];
        for(int i = 0 ; i < rows ; i++){
            char[] line = br.readLine().toString().toCharArray();
            for(int j = 0 ; j < line.length ; j++){
                char ch = line[j];
                map[i][j] = ch;
                if(ch == 'o') sheepCount++;
                else if(ch == 'v') {
                    wolfPos.add(new int[] {i , j});
                    wolfCount++;
                }
            }
        }

        for(int[] pos : wolfPos){
            if(!checked[pos[0]][pos[1]]){
                bfs(pos);
            }
        }
        System.out.println(sheepCount + " " + wolfCount);
    }
    public static void bfs(int[] pos){
        Queue<int[]> queue = new LinkedList<int[]>();
        queue.offer(pos);
        int areaSheepCount = 0;
        int areaWolfCount = 0;
        checked[pos[0]][pos[1]] = true;
        while(!queue.isEmpty()){
            int[] now = queue.poll();
            if(map[now[0]][now[1]] == 'o') areaSheepCount++;
            else if(map[now[0]][now[1]] == 'v') areaWolfCount++;
            for(int i = 0 ; i < 4 ; i++){
                int moveXpos = now[0] + moveX[i];
                int moveYpos = now[1] + moveY[i];
                if(moveXpos >= 0 && moveYpos >= 0 && moveXpos < rows && moveYpos < cols){
                    if(!checked[moveXpos][moveYpos] && map[moveXpos][moveYpos] != '#'){
                        checked[moveXpos][moveYpos] = true;
                        queue.offer(new int[] {moveXpos , moveYpos});
                    }
                }
            }
        }
        if(areaSheepCount > areaWolfCount) wolfCount -= areaWolfCount;
        else sheepCount -= areaSheepCount;
    }
}
```

***

# **`[Î∞±Ï§Ä] DFS` [Îã§Ïùå ÏàúÏó¥](https://www.acmicpc.net/problem/10972) ‚ùå**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

class Main {
    static int[] numberArr;
    static int[] printArr;
    static int[] targetArr;
    static boolean[] checked;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int size = Integer.parseInt(br.readLine());
        StringTokenizer st = new StringTokenizer(br.readLine());
        numberArr = new int[size];
        printArr = new int[size];
        targetArr = new int[size];
        checked = new boolean[size];
        for(int i = 0 ; i < size ; i++){
            numberArr[i] = i + 1;
            targetArr[i] = Integer.parseInt(st.nextToken());
        }
        dfs();
        System.out.println(-1);
    }

    public static void dfs(){

    }
}
```

***

# **`[Î∞±Ï§Ä] DFS` [Î™®Îì† ÏàúÏó¥](https://www.acmicpc.net/problem/10974)**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

class Main {
    static int[] numberArr;
    static int[] printArr;
    static int[] targetArr;
    static boolean[] checked;
    static StringBuilder result = new StringBuilder();
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int size = Integer.parseInt(br.readLine());
        numberArr = new int[size];
        printArr = new int[size];
        targetArr = new int[size];
        checked = new boolean[size];
        for(int i = 0 ; i < size ; i++){
            numberArr[i] = i + 1;
        }
        dfs(0);
        System.out.println(result.toString());
    }

    public static void dfs(int depth){
        if(depth == numberArr.length){
            for(int value : printArr) result.append(value).append(" ");
            result.append("\n");
        }
        else if(depth < numberArr.length){
            for(int i = 0 ; i < numberArr.length ; i++){
                if(!checked[i]){
                    checked[i] = true;
                    printArr[depth] = numberArr[i];
                    dfs(depth + 1);
                    checked[i] = false;
                }
            }
        }
    }

}
```

***

# **`[Î∞±Ï§Ä] DP` [1Î°ú ÎßåÎì§Í∏∞](https://www.acmicpc.net/problem/1463) ‚ùå**

```java

```

***

# **`[Î∞±Ï§Ä] Î∂ÑÌï†Ï†ïÎ≥µ` [ÌûàÏä§ÌÜ†Í∑∏Îû®](https://www.acmicpc.net/problem/1725) ‚ùå**

- [Ï∞∏Í≥†](https://st-lab.tistory.com/255)
- [Segmant Tree](https://m.blog.naver.com/ndb796/221282210534)

```java

```

***

# **`[Î∞±Ï§Ä] Stack` [Í≤ÄÏó¥](https://www.acmicpc.net/problem/3111) <span style="color:red; font-weight:bold">Ï∂úÎ†•Ï¥àÍ≥º</span> ‚ùå**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;


class Main {
    static String removeStr;
    static String str;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        removeStr = br.readLine();
        str = br.readLine();
        if(removeStr.length() <= 0) System.out.println(str);
        else System.out.println(solution());
    }

    public static String solution(){
        StringBuilder resultString = new StringBuilder();
        Stack<Character> stack = new Stack<>();
        Stack<Character> revStack = new Stack<>();
        int leftIndex = 0 , rightIndex = str.length() - 1;
        boolean reverseFlag = false;
        while(leftIndex <= rightIndex){
            if(!reverseFlag && leftIndex < str.length()){
                stack.push(str.charAt(leftIndex++));
                if(stack.size() >= removeStr.length() && stack.peek() == removeStr.charAt(removeStr.length() - 1)){
                    if(duplCheck(stack)) reverseFlag = true;
                }
            }
            if(reverseFlag && leftIndex <= rightIndex){
                revStack.push(str.charAt(rightIndex--));
                if(revStack.size() >= removeStr.length() && revStack.peek() == removeStr.charAt(removeStr.length() - 1)){
                    if(duplCheck(revStack)) reverseFlag = false;
                }
            }
        }
        // Ï∂úÎ†• Ï¥àÍ≥º !!!
        for(char ch : stack) resultString.append(ch);
        for(int i = revStack.size() - 1 ; i >= 0 ; i--) resultString.append(revStack.get(i));
        while(true){
            int removeIndex = resultString.indexOf(removeStr);
            if(removeIndex < 0) break;
            resultString.delete(removeIndex , removeIndex + removeStr.length());
        }
        return resultString.toString();
    }

    public static boolean duplCheck(Stack<Character> stack){
        int removeStrLength = removeStr.length() - 1;
        boolean flag = true;
        for(int i = stack.size() - 1 ; i >= stack.size() - removeStr.length() ; i--){
            if(stack.get(i) != removeStr.charAt(removeStrLength--)){
                flag = false;
                break;
            }
        }
        if(flag) {
            for (int i = 0; i < removeStr.length(); i++) {
                stack.pop();
            }
        }
        return flag;
    }
}
```


***

# üî• **`[Î∞±Ï§Ä BFS]` [Ïà®Î∞îÍº≠Ïßà3](https://www.acmicpc.net/problem/13549)**

- ÏõêÎûò Ïù¥ Î¨∏Ï†úÎäî Îã®ÏàúÌïú BFSÎ•º ÏöîÍµ¨ÌïòÎäî Î¨∏Ï†úÍ∞Ä ÏïÑÎãôÎãàÎã§.
- ÏôúÎÉêÌïòÎ©¥, BFSÎ•º ÌïòÍ∏∞ ÏúÑÌï¥ÏÑúÎäî Î™®Îì† Í∞ÑÏÑ†Ïùò Í∞ÄÏ§ëÏπòÍ∞Ä ÎèôÏùºÌï¥Ïïº ÌïúÎã§Îäî Ï†ÑÏ†ú Ï°∞Í±¥Ïù¥ ÌïÑÏöîÌïòÍ∏∞ ÎïåÎ¨∏ÏûÖÎãàÎã§.
- Ïù¥ Î¨∏Ï†úÎäî Í∞ÄÏ§ëÏπòÍ∞Ä 0Ïù∏ Í∞ÑÏÑ†Ïù¥ ÏûàÍ∏∞ ÎïåÎ¨∏Ïóê ÏùºÎ∞òÏ†ÅÏúºÎ°úÎäî Îã®ÏàúÌïú BFSÎ•º Ïì∏ Ïàò ÏóÜÏúºÎÇò, Î¨∏Ï†úÏùò ÌäπÏÑ± ÎïåÎ¨∏Ïóê Î∞©Î¨∏ ÏàúÏÑúÏóê Îî∞ÎùºÏÑú Îã®Ïàú BFSÎ°úÎèÑ Ïö∞Ïó∞ÌûàÎèÑ Ìï≠ÏÉÅ Ï†ïÎãµÏùÑ Ï∞æÏùÑ Ïàò ÏûàÏùÑ ÎøêÏûÖÎãàÎã§.
- Ïôú ÌïòÌïÑ Ïù¥ ÏàúÏÑúÎ°ú ÌïòÎ©¥ Ìï≠ÏÉÅ Ï†ïÎãµÏù¥ ÎÇòÏò§ÎäîÍ∞ÄÎ•º Ï¶ùÎ™ÖÌïòÎäî Í±¥ Îß§Ïö∞ Î≥µÏû°Ìïú ÏùºÏûÖÎãàÎã§.

- Ïù¥ Î¨∏Ï†úÎ•º Î≥¥Îã§ ÏùºÎ∞òÌôîÎêú Í≤ΩÏö∞ (Í∞ÄÏ§ëÏπòÍ∞Ä 0Ïù∏ Í∞ÑÏÑ†Ïù¥ ÏûàÎäî Í≤ΩÏö∞)Ïóê ÎåÄÌï¥ Ìï¥Í≤∞ÌïòÎ†§Î©¥, Ï¶â, Ïù¥ Î¨∏Ï†úÏùò ÏùòÎèÑÎåÄÎ°ú ÌíÄÎ†§Î©¥ Îã§ÏùåÍ≥º Í∞ôÏùÄ Î∞©Î≤ïÎì§ÏùÑ ÏÇ¨Ïö©Ìï† Ïàò ÏûàÏäµÎãàÎã§.
	- **Îã§ÏùµÏä§Ìä∏Îùº ÏïåÍ≥†Î¶¨Ï¶ò**
	- **0-1 BFS** : Í∞ÄÏ§ëÏπòÍ∞Ä 0Ïù∏ Í∞ÑÏÑ†Ïóê Ïó∞Í≤∞Îêú Ï†ïÏ†êÏùÄ ÌÅêÏùò Îß® Îí§Í∞Ä ÏïÑÎãå Îß® ÏïûÏóê ÎÑ£Îäî Î∞©Î≤ï
	- `* 2`Î•º Î≥ÑÎèÑÏùò Í∞ÑÏÑ†ÏúºÎ°ú ÏÉùÍ∞ÅÌïòÏßÄ ÏïäÍ≥†, +1Ïù¥ÎÇò -1Ïóê ÏùòÌïú Ï¢åÌëúÎ•º ÌÅêÏóê ÎÑ£ÏùÑ Îïå Í∑∏ Ï¢åÌëúÏùò 2Ïùò Í±∞Îì≠Ï†úÍ≥± Î∞∞Ïù∏ Ï¢åÌëúÎì§ÏùÑ Ï†ÑÎ∂Ä ÌÅêÏóê ÎÑ£Îäî Î∞©Î≤ï
- [Ï∞∏Í≥†](https://www.acmicpc.net/board/view/38887#comment-69010)


```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

class Main {
    static int[] move = {1 , -1 , 2};
    static int[] distance;
    static int start , destination;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        start = Integer.parseInt(st.nextToken());
        destination = Integer.parseInt(st.nextToken());
        distance = new int[100002];
        Arrays.fill(distance , Integer.MAX_VALUE);
        bfs();
    }

    public static void bfs(){
        Queue<int[]> queue = new LinkedList<int[]>();
        queue.offer(new int[] {start , 0});
        distance[start] = 0;
        while(!queue.isEmpty()){
            int[] now = queue.poll();
            if(now[0] == destination){
                System.out.println(now[1]);
                System.exit(0);
            }
            for(int i = 2 ; i >= 0 ; i--){
                int movePos = i == 2 ? now[0] * move[i] : now[0] + move[i];
                int moveCnt = i == 2 ? now[1] : now[1] + 1;
                if(movePos >= 0 && movePos < 100002 && distance[movePos] >= moveCnt){
                    distance[movePos] = moveCnt;
                    queue.offer(new int[] {movePos , moveCnt});
                }
            }
        }
    }
}
```

***

# **`[Î∞±Ï§Ä BFS]` [Ïà®Î∞îÍº≠Ïßà4](https://www.acmicpc.net/problem/13913)**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

class Main {
    static int[] move = {1 , -1 , 2};
    static int[] moveDistance;
    static int[] distance;
    static int start , destination;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        start = Integer.parseInt(st.nextToken());
        destination = Integer.parseInt(st.nextToken());
        moveDistance = new int[100002];
        distance = new int[100002];
        Arrays.fill(distance , Integer.MAX_VALUE);
        bfs();
    }

    public static void bfs(){
        Queue<int[]> queue = new LinkedList<int[]>();
        queue.offer(new int[] {start , 0});
        while(!queue.isEmpty()){
            int[] now = queue.poll();
            if(now[0] == destination){
                System.out.println(now[1]);
                int footPrintIndex = destination;
                Deque<Integer> footPrint = new LinkedList<>();
                footPrint.addFirst(footPrintIndex);
                while(footPrintIndex != start){
                    footPrint.addFirst(moveDistance[footPrintIndex]);
//                    System.out.println(moveDistance[footPrintIndex] + " : " + footPrintIndex);
                    footPrintIndex = moveDistance[footPrintIndex];
                }
                while(!footPrint.isEmpty()){
                    System.out.print(footPrint.poll() + " ");
                }
                System.exit(0);
            }
            for(int i = 2 ; i >= 0 ; i--){
                int movePos = i == 2 ? now[0] * move[i] : now[0] + move[i];
                int moveCnt = now[1] + 1;
                if(movePos >= 0 && movePos < 100002 && distance[movePos] >= moveCnt){
                    distance[movePos] = moveCnt;
                    moveDistance[movePos] = now[0];
                    queue.offer(new int[] {movePos , moveCnt});
                }
            }
        }
    }
}
```

***

# **`[Î∞±Ï§Ä] BFS` [ÏïåÍ≥†Ïä§Ìåü](https://www.acmicpc.net/problem/1261) ‚ùå**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

class Position{
    int x;
    int y;
    int breakWall;
    public Position(int x, int y, int breakWall) {
        this.x = x;
        this.y = y;
        this.breakWall = breakWall;
    }
}

class Main {
    static int[] moveX = {-1 , 0 , 1 , 0};
    static int[] moveY = {0 , 1 , 0 , -1};
    static int[][] map;
    static boolean[][] visited;
    static List<Integer> resultList = new ArrayList<>();
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int y = Integer.parseInt(st.nextToken());
        int x = Integer.parseInt(st.nextToken());
        map = new int[x][y];
        visited = new boolean[x][y];
        for(int i = 0 ; i < x ; i++){
            String[] line = br.readLine().split("");
            for(int j = 0 ; j < y ; j++){
                map[i][j] = Integer.parseInt(line[j]);
            }
        }
        start(x - 1, y - 1);
        System.out.println(resultList);
    }

    public static void start(int targetX , int targetY){
        Queue<Position> queue = new LinkedList<>();
        queue.offer(new Position(0 , 0 ,0));
        while(!queue.isEmpty()){
            Position now = queue.poll();
            if(now.x == targetX && now.y == targetY){
                resultList.add(now.breakWall);
            }
            else {
                for (int i = 0; i < 4; i++) {
                    int moveXpos = now.x + moveX[i];
                    int moveYpos = now.y + moveY[i];
                    if (moveXpos >= 0 && moveYpos >= 0 && moveXpos <= targetX && moveYpos <= targetY && !visited[moveXpos][moveYpos]) {
                        if (map[moveXpos][moveYpos] == 1) {
                            queue.offer(new Position(moveXpos, moveYpos, now.breakWall + 1));
                        } else queue.offer(new Position(moveXpos, moveYpos, now.breakWall));
                        visited[moveXpos][moveYpos] = true;
                    }
                }
            }
        }
    }
}
```
