---
layout: default
title: 2021년8월
nav_order: 4
parent: 알고리즘
---
## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

# **`[백준] 분할정복` [히스토그램](https://www.acmicpc.net/problem/1725) ❌**

- [참고](https://st-lab.tistory.com/255)
- [Segmant Tree](https://m.blog.naver.com/ndb796/221282210534)

```java

```

***

# **`[백준] Deque` [덱 구현하기](https://www.acmicpc.net/problem/1725)**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

class Main {
    static int rear = 0;
    static final int INIT_SIZE = 11;
    static int[] intArr;
    static StringBuilder resultString = new StringBuilder();
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        intArr = new int[INIT_SIZE];
        int size = Integer.parseInt(br.readLine());
        for(int i = 0 ; i < size; i++){
            String command = br.readLine();
            if(0 == command.indexOf("push_f")) push_front(Integer.parseInt(command.split(" ")[1]));
            else if(0 == command.indexOf("push_b")) push_back(Integer.parseInt(command.split(" ")[1]));
            else if(0 == command.indexOf("pop_f")) pop_front();
            else if(0 == command.indexOf("pop_b")) pop_back();
            else if(0 == command.indexOf("s")) size();
            else if(0 == command.indexOf("e")) empty();
            else if(0 == command.indexOf("f")) front();
            else if(0 == command.indexOf("b")) back();
        }
        System.out.println(resultString.toString());
    }
    public static void pushArrayShift(){
        increaseArrSize();
        for(int i = rear ; i > 0; i--){
            intArr[i] = intArr[i - 1];
        }
    }
    public static void pullArrayShift(){
        for(int i = 0 ; i < rear ; i++){
            intArr[i] = intArr[i + 1];
        }
    }
    public static void increaseArrSize(){
        if(rear == intArr.length - 1) {
            int[] tmpArr = Arrays.copyOf(intArr , intArr.length);
            intArr = new int[intArr.length * 2];
            System.arraycopy(tmpArr, 0, intArr, 0, tmpArr.length);
        }
    }
    public static void push_front(int x){
        if(intArr[0] != 0) pushArrayShift();
        intArr[0] = x;
        rear++;
    }
    public static void push_back(int x){
        increaseArrSize();
        intArr[rear] = x;
        rear++;
    }
    public static void pop_front(){
        if(intArr[0] == 0) resultString.append("-1\n");
        else{
            resultString.append(intArr[0]).append("\n");
            pullArrayShift();
            rear--;
        }
    }
    public static void pop_back(){
        if(rear - 1 < 0 || intArr[rear - 1] == 0) resultString.append("-1\n");
        else{
            resultString.append(intArr[rear - 1]).append("\n");
            intArr[rear - 1] = 0;
            rear--;
        }
    }
    public static void size(){
        resultString.append(rear).append("\n");
    }
    public static void empty(){
        if(rear - 1 < 0) resultString.append("1\n");
        else resultString.append("0\n");
    }
    public static void front(){
        if(intArr[0] == 0) resultString.append("-1\n");
        else resultString.append(intArr[0]).append("\n");
    }
    public static void back(){
        if(rear - 1 < 0 || intArr[rear - 1] == 0) resultString.append("-1\n");
        else resultString.append(intArr[rear - 1]).append("\n");
    }

    public static void printArr(){
        for(int i : intArr){
            System.out.print(i + " ");
        }
        System.out.println(" - " + rear);
        System.out.println();
    }
}
```

***

# **`[백준] Heap` [최대,최소 힙 구현하기](https://www.acmicpc.net/problem/11279)**

## 배열로 구현 시 시간 초과

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

class implHeap{
    int[] arr;
    public implHeap(){
        arr = new int[100002];
    }

    public int get(){
        // 최대 노드를 반환 후 비운다.
        // 가장 마지막 노드를 루트노드로 옮긴 후
        // 자신보다 크고 왼쪽 , 오른쪽 자식 중 제일 큰 값과 바꿔나간다.
        int rootValue = arr[1];
        int lastChildIndex = findLastChild();
        arr[1] = arr[lastChildIndex];
        arr[lastChildIndex] = 0;
        moveBottom(1);

        return rootValue;
    }
    public void moveBottom(int rootIndex){
        int maxPos = 1;
        int rootValue = arr[rootIndex];
        int maxValue = 0;
        while(maxPos * 2 < arr.length){
            maxPos = maxPos * 2;
            if(maxPos + 1 < arr.length && arr[maxPos] < arr[maxPos + 1]){
                maxValue = arr[maxPos + 1];
                maxPos += 1;
            }
            if(rootValue > maxValue) break;
            swap(rootIndex , maxPos);
            rootIndex = maxPos;
        }
    }
    public int findLastChild(){
        int lastIndex = 1;
        for(int i = 1 ; i < arr.length ; i++){
            if(arr[i] != 0){
                lastIndex = i;
                break;
            }
        }
        return lastIndex;
    }

    public void push(int value){
        int pushIndex = 0;
        for(int i = 1 ; i < arr.length ; i++){
            if(arr[i] == 0) {
                arr[i] = value;
                pushIndex = i;
                break;
            }
        }
        moveTop(pushIndex);
    }

    public void moveTop(int pushIndex){
        // 2로 나눠 떨어진다면 왼쪽 자식 , 아니라면 오른쪽 자식
        int parentIndex = 0;
        while(true){
            if(pushIndex % 2 != 0) parentIndex = (pushIndex - 1) / 2;
            else parentIndex = pushIndex / 2;
            if(parentIndex > 0){
                if(arr[parentIndex] < arr[pushIndex]){
                    swap(parentIndex , pushIndex);
                }
                pushIndex = parentIndex;
            }
            else break;
        }
    }

    public void swap(int firstIndex , int secondIndex){
        int tmp = arr[firstIndex];
        arr[firstIndex] = arr[secondIndex];
        arr[secondIndex] = tmp;
    }
}


class Main {
    public static void main(String[] args) throws IOException {
        StringBuilder result = new StringBuilder();
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int size = Integer.parseInt(br.readLine());
        implHeap heap = new implHeap();
//        System.out.println("---------------------------------");
        for(int i = 0 ; i < size ; i++){
            int value = Integer.parseInt(br.readLine());
            if(value == 0) result.append(heap.get()).append("\n");
            else heap.push(value);
        }
        System.out.println(result.toString());
    }
}
```

## 통과

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

class implHeap{
    List<Integer> arr;
    public implHeap(){
        arr = new ArrayList<>();
        arr.add(999999);
    }

    public int get(){
        if(arr.size() - 1 < 1) return 0;

        int rootValue = arr.get(1);
        arr.set(1 , arr.get(arr.size() - 1));
        moveBottom();
        arr.remove(arr.size() - 1);
        return rootValue;
    }
    public void moveBottom(){
        int rootPos = 1 , rootValue = 0;
        int maxPos = 1 , maxValue = 0;
        while(maxPos * 2 < arr.size()){
            rootValue = arr.get(rootPos);
            maxPos *= 2;
//          최소 힙 - if(maxPos + 1 < arr.size() && arr.get(maxPos) > arr.get(maxPos + 1)) maxPos += 1;
            if(maxPos + 1 < arr.size() && arr.get(maxPos) < arr.get(maxPos + 1)) maxPos += 1;
            maxValue = arr.get(maxPos);
//          if(rootValue < maxValue) break;
            if(rootValue > maxValue) break;
            swap(rootPos , maxPos);
            rootPos = maxPos;
        }
    }

    public void push(int value){
        arr.add(value);
        moveTop();
    }

    public void moveTop(){
        int lastPos = arr.size() - 1;
//      최소 힙 - while(lastPos > 1 && arr.get(lastPos / 2) > arr.get(lastPos)){
        while(lastPos > 1 && arr.get(lastPos / 2) < arr.get(lastPos)){
            swap(lastPos / 2 , lastPos);
            lastPos = lastPos / 2;
        }
    }

    public void swap(int firstIndex , int secondIndex){
        int tmp = arr.get(firstIndex);
        arr.set(firstIndex , arr.get(secondIndex));
        arr.set(secondIndex , tmp);
    }
}


class Main {
    public static void main(String[] args) throws IOException {
        StringBuilder result = new StringBuilder();
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int size = Integer.parseInt(br.readLine());
        implHeap heap = new implHeap();
//        System.out.println("---------------------------------");
        for(int i = 0 ; i < size ; i++){
            int value = Integer.parseInt(br.readLine());
            if(value == 0) result.append(heap.get()).append("\n");
            else heap.push(value);
        }
        System.out.println(result.toString());
    }
}
```

***

# **`[백준] Stack` [검열](https://www.acmicpc.net/problem/3111) <span style="color:red; font-weight:bold">출력초과</span> ❌**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;


class Main {
    static String removeStr;
    static String str;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        removeStr = br.readLine();
        str = br.readLine();
        if(removeStr.length() <= 0) System.out.println(str);
        else System.out.println(solution());
    }

    public static String solution(){
        StringBuilder resultString = new StringBuilder();
        Stack<Character> stack = new Stack<>();
        Stack<Character> revStack = new Stack<>();
        int leftIndex = 0 , rightIndex = str.length() - 1;
        boolean reverseFlag = false;
        while(leftIndex <= rightIndex){
            if(!reverseFlag && leftIndex < str.length()){
                stack.push(str.charAt(leftIndex++));
                if(stack.size() >= removeStr.length() && stack.peek() == removeStr.charAt(removeStr.length() - 1)){
                    if(duplCheck(stack)) reverseFlag = true;
                }
            }
            if(reverseFlag && leftIndex <= rightIndex){
                revStack.push(str.charAt(rightIndex--));
                if(revStack.size() >= removeStr.length() && revStack.peek() == removeStr.charAt(removeStr.length() - 1)){
                    if(duplCheck(revStack)) reverseFlag = false;
                }
            }
        }
        // 출력 초과 !!!
        for(char ch : stack) resultString.append(ch);
        for(int i = revStack.size() - 1 ; i >= 0 ; i--) resultString.append(revStack.get(i));
        while(true){
            int removeIndex = resultString.indexOf(removeStr);
            if(removeIndex < 0) break;
            resultString.delete(removeIndex , removeIndex + removeStr.length());
        }
        return resultString.toString();
    }

    public static boolean duplCheck(Stack<Character> stack){
        int removeStrLength = removeStr.length() - 1;
        boolean flag = true;
        for(int i = stack.size() - 1 ; i >= stack.size() - removeStr.length() ; i--){
            if(stack.get(i) != removeStr.charAt(removeStrLength--)){
                flag = false;
                break;
            }
        }
        if(flag) {
            for (int i = 0; i < removeStr.length(); i++) {
                stack.pop();
            }
        }
        return flag;
    }
}
```

***

# **`[백준 BFS]` [숨바꼭질](https://www.acmicpc.net/problem/1697)**

## Moving 객체 사용 - 19468kb	188ms

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

class Moving{
    int position;
    int passedTime;
    public Moving(int position, int passedTime) {
        this.position = position;
        this.passedTime = passedTime;
    }
}

class Main {
    static int[] move = {1 , -1 , 2};
    static int minTime = 0;
    static boolean[] visited = new boolean[100001];
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int start = Integer.parseInt(st.nextToken());
        int destination = Integer.parseInt(st.nextToken());

        bfsSolution(start , destination);
        System.out.println(minTime);
    }

    public static void bfsSolution(int start , int destination){
        Queue<Moving> queue = new LinkedList<>();
        queue.offer(new Moving(start , 0));
        visited[start] = true;
        while(!queue.isEmpty()){
            Moving now = queue.poll();
            if(now.position == destination) {
                minTime = now.passedTime;
                break;
            }
            else{
                for(int i = 0 ; i < move.length ; i++){
                    int moving = i == 2 ? now.position * i : now.position + move[i];
                    if(moving >= 0 && moving < 100001 && !visited[moving]){
                        visited[moving] = true;
                        queue.offer(new Moving(moving , now.passedTime + 1));
                    }
                }
            }
        }
    }
}
```

## 객체 미사용 - 	19000kb	188ms

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

class Main {
    static int[] move = {1 , -1 , 2};
    static int minTime = 0;
    static int[] visited = new int[100001];
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int start = Integer.parseInt(st.nextToken());
        int destination = Integer.parseInt(st.nextToken());

        if(start == destination) System.out.println(0);
        else {
            bfsSolution(start , destination);
            System.out.println(minTime);
        }
    }

    public static void bfsSolution(int start , int destination){
        Queue<Integer> queue = new LinkedList<>();
        queue.offer(start);
        visited[start] = 0;
        while(!queue.isEmpty()){
            int now = queue.poll();
            if(now == destination) {
                minTime = visited[now];
                break;
            }
            for(int i = 0 ; i < move.length ; i++){
                int moving = i == 2 ? now * move[i] : now + move[i];
                if(moving >= 0 && moving < 100001 && visited[moving] == 0){
                    visited[moving] = visited[now] + 1;
                    queue.offer(moving);
                }
            }
        }
    }
}
```

***

# 🔥 **`[백준 DFS , BFS]` [숨바꼭질2](https://www.acmicpc.net/problem/12851)**

## 정리
- 경과 시간을 배열에 누적 시킨다.
- Queue에 담을 조건을 못 찾았었다.
  - [참고](https://bcp0109.tistory.com/154)
  - **(해당 인덱스를 처음 방문)하거나 (방문할 인덱스의 시간과 이전에 방문한 인덱스의 시간 + 1과 같다면) Queue에 담는다**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

class Main {
    static int[] move = {1 , -1 , 2};
    static int minTime = Integer.MAX_VALUE;
    static int minCount = 0;
    static int[] distance = new int[100001];
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int start = Integer.parseInt(st.nextToken());
        int destination = Integer.parseInt(st.nextToken());

        if(start == destination) {
            System.out.println(0);
            System.out.println(1);
        }
        else {
            bfsSolution(start , destination);
            System.out.println(minTime);
            System.out.println(minCount);
        }
    }

    public static void bfsSolution(int start , int destination){
        Queue<Integer> queue = new LinkedList<>();
        queue.offer(start);
        distance[start] = 0;
        while(!queue.isEmpty()){
            int now = queue.poll();
            if(minTime < distance[now]) continue;

            for(int i = 0 ; i < move.length ; i++){
                int moving = i == 2 ? now * move[i] : now + move[i];
                if (moving >= 0 && moving < 100001) {
                    if(moving == destination){
//                        System.out.println(moving + " : " + (distance[now] + 1));
                        if(minTime > distance[now] + 1){
                            minTime = distance[now] + 1;
                            minCount = 1;
                        }
                        else if(minTime == distance[now] + 1) minCount++;
                    }
                    else if(distance[moving] == 0 || distance[moving] == distance[now] + 1){
                        distance[moving] = distance[now] + 1;
                        queue.offer(moving);
                    }
                }
            }
        }
    }
}
```

# **`[백준 DFS , BFS]` [숨바꼭질4](https://www.acmicpc.net/problem/13913)**

```java

```
