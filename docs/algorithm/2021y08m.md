---
layout: default
title: 2021년8월
nav_order: 4
parent: 알고리즘
---
## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

# **`[백준] 분할정복` [히스토그램](https://www.acmicpc.net/problem/1725) ❌**

- [참고](https://st-lab.tistory.com/255)
- [Segmant Tree](https://m.blog.naver.com/ndb796/221282210534)

```java

```

***

# **`[백준] Deque` [덱 구현하기](https://www.acmicpc.net/problem/1725)**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

class Main {
    static int rear = 0;
    static final int INIT_SIZE = 11;
    static int[] intArr;
    static StringBuilder resultString = new StringBuilder();
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        intArr = new int[INIT_SIZE];
        int size = Integer.parseInt(br.readLine());
        for(int i = 0 ; i < size; i++){
            String command = br.readLine();
            if(0 == command.indexOf("push_f")) push_front(Integer.parseInt(command.split(" ")[1]));
            else if(0 == command.indexOf("push_b")) push_back(Integer.parseInt(command.split(" ")[1]));
            else if(0 == command.indexOf("pop_f")) pop_front();
            else if(0 == command.indexOf("pop_b")) pop_back();
            else if(0 == command.indexOf("s")) size();
            else if(0 == command.indexOf("e")) empty();
            else if(0 == command.indexOf("f")) front();
            else if(0 == command.indexOf("b")) back();
        }
        System.out.println(resultString.toString());
    }
    public static void pushArrayShift(){
        increaseArrSize();
        for(int i = rear ; i > 0; i--){
            intArr[i] = intArr[i - 1];
        }
    }
    public static void pullArrayShift(){
        for(int i = 0 ; i < rear ; i++){
            intArr[i] = intArr[i + 1];
        }
    }
    public static void increaseArrSize(){
        if(rear == intArr.length - 1) {
            int[] tmpArr = Arrays.copyOf(intArr , intArr.length);
            intArr = new int[intArr.length * 2];
            System.arraycopy(tmpArr, 0, intArr, 0, tmpArr.length);
        }
    }
    public static void push_front(int x){
        if(intArr[0] != 0) pushArrayShift();
        intArr[0] = x;
        rear++;
    }
    public static void push_back(int x){
        increaseArrSize();
        intArr[rear] = x;
        rear++;
    }
    public static void pop_front(){
        if(intArr[0] == 0) resultString.append("-1\n");
        else{
            resultString.append(intArr[0]).append("\n");
            pullArrayShift();
            rear--;
        }
    }
    public static void pop_back(){
        if(rear - 1 < 0 || intArr[rear - 1] == 0) resultString.append("-1\n");
        else{
            resultString.append(intArr[rear - 1]).append("\n");
            intArr[rear - 1] = 0;
            rear--;
        }
    }
    public static void size(){
        resultString.append(rear).append("\n");
    }
    public static void empty(){
        if(rear - 1 < 0) resultString.append("1\n");
        else resultString.append("0\n");
    }
    public static void front(){
        if(intArr[0] == 0) resultString.append("-1\n");
        else resultString.append(intArr[0]).append("\n");
    }
    public static void back(){
        if(rear - 1 < 0 || intArr[rear - 1] == 0) resultString.append("-1\n");
        else resultString.append(intArr[rear - 1]).append("\n");
    }

    public static void printArr(){
        for(int i : intArr){
            System.out.print(i + " ");
        }
        System.out.println(" - " + rear);
        System.out.println();
    }
}
```

***

# **`[백준] Heap` [최대 힙 구현하기](https://www.acmicpc.net/problem/11279)**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

class implHeap{
    int[] arr;

    public implHeap(){
        arr = new int[100001];
    }

    public int get(){
        // 최대 노드를 반환 후 비운다.
        // 가장 마지막 노드를 루트노드로 옮긴 후
        // 자신보다 크고 왼쪽 , 오른쪽 자식 중 제일 큰 값과 바꿔나간다.
        int rootValue = arr[1];
        int lastChildIndex = findLastChild();
        arr[1] = arr[lastChildIndex];
        moveBottom(1);
        return rootValue;
    }
    public void moveBottom(int rootIndex){
        int leftChild = 1, rightChild = 1;
        int rootValue = arr[rootIndex];
        while(true){
            leftChild = leftChild * 2;
            rightChild = rightChild * 2 + 1;
            if(arr[leftChild] > rootValue || arr[rightChild] > rootValue){

            }
            else break;
        }
    }
    public int findLastChild(){
        int lastIndex = 0;
        for(int i = 1 ; i < arr.length ; i++){
            if(arr[i] != 0){
                lastIndex = i;
                break;
            }
        }
        return lastIndex;
    }

    public void push(int value){
        int pushIndex = 0;
        for(int i = 1 ; i < arr.length ; i++){
            if(arr[i] == 0) {
                arr[i] = value;
                pushIndex = i;
                break;
            }
        }
        moveTop(pushIndex);
    }

    public void moveTop(int pushIndex){
        // 2로 나눠 떨어진다면 왼쪽 자식 , 아니라면 오른쪽 자식
        int parentIndex = 0;
        while(true){
            if(pushIndex % 2 != 0) parentIndex = (pushIndex - 1) / 2;
            else parentIndex = pushIndex / 2;
            if(parentIndex > 0 && arr[parentIndex] > arr[pushIndex]){
                int tmp = arr[parentIndex];
                arr[parentIndex] = arr[pushIndex];
                arr[pushIndex] = tmp;
            }
            else break;
        }
    }
}


class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int size = Integer.parseInt(br.readLine());

        for(int i = 0 ; i < size ; i++){

        }
    }

}
```
