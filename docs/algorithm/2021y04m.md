---
layout: default
title: 2021년4월
nav_order: 1
parent: 알고리즘
---
## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---


## **2021년 4월 5일 (프로그래머스 1단계 통과)**

```java
public static void main(String[] args) {
    solution("01033334444");

    // 두 개의 정수 n 과 m
    // 가로의 길이가 n , 세로의 길이가 m인 직사각 형태의 * 출력하기
    Scanner sc = new Scanner(System.in);
    int a = sc.nextInt();
    int b = sc.nextInt();

    for(int i = 0 ; i < b ; i++){
        for(int j = 0 ; j < a ; j++){
            System.out.print('*');
        }
        System.out.println();
    }
}

// 전화번호 뒤에서 부터 4자리 자르기
// 통과
public static String solution(String phone_number) {
    StringBuffer answer = new StringBuffer(phone_number.substring(phone_number.length() - 4));
    for(int i = 0 ; i < phone_number.length() - 4 ; i++){
        answer.insert(0 , '*');
    }
    return answer.toString();
}
```

## **2021년 4월 7일 (2단계 0점)**

```java
public static void main(String[] args) {
    String[] arr = {"N~F=0", "R~T>2"};
    solution(2 , arr);

    solution2(10,2);
}

//    Leo가 본 카펫에서 갈색 격자의 수 brown, 노란색 격자의 수 yellow가 매개변수로 주어질 때 카펫의 가로, 세로 크기를 순서대로 배열에 담아 return 하도록 solution 함수를 작성해주세요.
//
//    제한사항
//    갈색 격자의 수 brown은 8 이상 5,000 이하인 자연수입니다.
//    노란색 격자의 수 yellow는 1 이상 2,000,000 이하인 자연수입니다.
//    카펫의 가로 길이는 세로 길이와 같거나, 세로 길이보다 깁니다.
//    입출력 예
//          brown	yellow	return
//            10	2	    [4, 3]  -> 12 = 4 * 3
//            8	    1	    [3, 3]  -> 9 = 3 * 3
//            24	24	    [8, 6]  -> 48 = 8 * 6
//        0 1 2 3
//   0    1 1 1 1           1 1 1
//   1    1 0 0 1           1 0 1
//   2    1 1 1 1           1 1 1
    public static int[] solution2(int brown, int yellow) {
        int[] answer = new int[2];
        int total = brown + yellow;
        int x = 0, y = 0;
        int[][] test;
        for(int i = 0 ; i < brown ; i++){
            if(i >= 2 && total % i == 0){
                x = i;
                y = total / i;
                test = new int[x][y];
                if(x >= y && x >= 3 && y > 2){
                	for(int j = 0 ; j < x ; j++) {
                		for(int k = 0 ; k < y ; k++) {
                			if(j == 0 || j == x - 1 || k == 0 || k == y - 1) {
                				test[j][k] = 1;
                			}
                			else {
                				test[j][k] = 0;
                			}
                		}
                	}
                	if(test[0][0] == 1 && test[1][1] == 0) {
                    	answer[0] = x;
                    	answer[1] = y;
                    	break;
                	}
                }
            }
        }        
        return answer;
    }
//    단체 사진 찍기
//    1 <= n <= 100
//    data의 원소는 다섯 글자로 구성된 문자열이다. 각 원소의 조건은 다음과 같다.
//    첫 번째 글자와 세 번째 글자는 다음 8개 중 하나이다. {A, C, F, J, M, N, R, T} 각각 어피치, 콘, 프로도, 제이지, 무지, 네오, 라이언, 튜브를 의미한다.
//    첫 번째 글자는 조건을 제시한 프렌즈, 세 번째 글자는 상대방이다. 첫 번째 글자와 세 번째 글자는 항상 다르다.
//    두 번째 글자는 항상 ~이다.
//    네 번째 글자는 다음 3개 중 하나이다. {=, <, >} 각각 같음, 미만, 초과를 의미한다.
//    다섯 번째 글자는 0 이상 6 이하의 정수의 문자형이며, 조건에 제시되는 간격을 의미한다. 이때 간격은 두 프렌즈 사이에 있는 다른 프렌즈의 수이다.
//    n	    data	                       answer
//    2	    ["N~F=0", "R~T>2"]	   3648
//    2	    ["M~C<2", "C~M>1"]	 0
public static int solution(int n, String[] data) {
    int answer = 0;
    String[] kakao = {"A" , "C" , "F" , "J" , "M" , "N" , "R" , "T"};

    for(String condition : data){
        for(String friends : kakao){

        }
    }

    return answer;
}

```
