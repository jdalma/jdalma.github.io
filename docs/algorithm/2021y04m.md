---
layout: default
title: 2021년4월
nav_order: 1
parent: 알고리즘
---
## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---


# **2021년 4월**

## LEVEL1

### 사각형 출력하기 (완료)

```java
public static void main(String[] args) {
    // 두 개의 정수 n 과 m
    // 가로의 길이가 n , 세로의 길이가 m인 직사각 형태의 * 출력하기
    Scanner sc = new Scanner(System.in);
    int a = sc.nextInt();
    int b = sc.nextInt();

    for(int i = 0 ; i < b ; i++){
        for(int j = 0 ; j < a ; j++){
            System.out.print('*');
        }
        System.out.println();
    }
}
```

### 전화번호 뒤에서 부터 4자리 자르기 (완료)
```java
public static String solution(String phone_number) {
    StringBuffer answer = new StringBuffer(phone_number.substring(phone_number.length() - 4));
    for(int i = 0 ; i < phone_number.length() - 4 ; i++){
        answer.insert(0 , '*');
    }
    return answer.toString();
}
```


## LEVEL2

### Leo의 격자 카펫 (완료 - 도움)
- Leo가 본 카펫에서 갈색 격자의 수 brown, 노란색 격자의 수 yellow가 매개변수로 주어질 때 카펫의 가로, 세로 크기를 순서대로 배열에 담아 return

- 제한사항
  - 갈색 격자의 수 brown은 8 이상 5,000 이하인 자연수입니다.
  - 노란색 격자의 수 yellow는 1 이상 2,000,000 이하인 자연수입니다.
  - 카펫의 가로 길이는 세로 길이와 같거나, 세로 길이보다 깁니다.
  - 입출력 예

| brown  | yello | return |  |
|:--------|:--------|:--------|:----|
| 10      | 2  | `[4 , 3]`  | 12 = 4 * 3 |
| 8       |  1 | `[3 , 3]`  | 9 = 3 * 3 |
| 24      |  24 | `[8 , 6]` | 48 = 8 * 6 |

```java
public static int[] solution2(int brown, int yellow) {
    int[] answer = new int[2];
    int total = brown + yellow;
    int x = 0, y = 0;
    int[][] test;
    for(int i = 0 ; i < brown ; i++){
        if(i >= 2 && total % i == 0){
            x = i;
            y = total / i;
            // test = new int[x][y];
            // if(x >= y && x >= 3 && y > 2){
            // 	for(int j = 0 ; j < x ; j++) {
            // 		for(int k = 0 ; k < y ; k++) {
            // 			if(j == 0 || j == x - 1 || k == 0 || k == y - 1) {
            // 				test[j][k] = 1;
            // 			}
            // 			else {
            // 				test[j][k] = 0;
            // 			}
            // 		}
            // 	}
            //   if(test[0][0] == 1 && test[1][1] == 0 && test[x-1][y-1] == 1 && test[x-2][y-2] == 0) {
            //       answer[0] = x;
            //       answer[1] = y;
            //       break;
            //   }
            if((x - 2) * y - 2) == yellow){
                answer[0] = temp;
                answer[1] = i;

                return answer;
            }
        }
    }
    return answer;
}
```

### 단체 사진 찍기 (미완료)

- 단체 사진 찍기
- 1 <= n <= 100
- data의 원소는 다섯 글자로 구성된 문자열이다. 각 원소의 조건은 다음과 같다.
- 첫 번째 글자와 세 번째 글자는 다음 8개 중 하나이다.
- {A, C, F, J, M, N, R, T} 각각 어피치, 콘, 프로도, 제이지, 무지, 네오, 라이언, 튜브를 의미한다.
- 첫 번째 글자는 조건을 제시한 프렌즈, 세 번째 글자는 상대방이다. 첫 번째 글자와 세 번째 글자는 항상 다르다.
- 두 번째 글자는 항상 ~이다.
- 네 번째 글자는 다음 3개 중 하나이다. {=, <, >} 각각 같음, 미만, 초과를 의미한다.
- 다섯 번째 글자는 0 이상 6 이하의 정수의 문자형이며, 조건에 제시되는 간격을 의미한다.
  - 이때 간격은 두 프렌즈 사이에 있는 다른 프렌즈의 수이다.
- 입출력 예

| n  | data | return |  |
|:--------|:--------|:--------|:----|
| 2      | `["N~F=0", "R~T>2"]`  | 3648  | |
| 2       | `["M~C<2", "C~M>1"]` | 0  | |

```java
public static int solution(int n, String[] data) {
    int answer = 0;
    String[] kakao = {"A" , "C" , "F" , "J" , "M" , "N" , "R" , "T"};

    for(String condition : data){
        for(String friends : kakao){

        }
    }

    return answer;
}

```

### 스킬 트리 (완료)
- 스킬은 알파벳 대문자로 표기하며, 모든 문자열은 알파벳 대문자로만 이루어져 있습니다.
- 스킬 순서와 스킬트리는 문자열로 표기합니다.
  - 예를 들어, C → B → D 라면 "CBD"로 표기합니다
- 선행 스킬 순서 skill의 길이는 1 이상 26 이하이며, 스킬은 중복해 주어지지 않습니다.
- skill_trees는 길이 1 이상 20 이하인 배열입니다.
- skill_trees의 원소는 스킬을 나타내는 문자열입니다.
  - skill_trees의 원소는 길이가 2 이상 26 이하인 문자열이며, 스킬이 중복해 주어지지 않습니다.
- 입출력 예

| skill  | skill_trees | return |
|:--------|:--------|:--------|
| "CBD"      | `["BACDE", "CBADF", "AECB", "BDA"]` | 2 |

- 입출력 예 설명
  - "BACDE": B 스킬을 배우기 전에 C 스킬을 먼저 배워야 합니다. 불가능한 스킬트립니다.
  - "CBADF": 가능한 스킬트리입니다.
  - "AECB": 가능한 스킬트리입니다.
  - "BDA": B 스킬을 배우기 전에 C 스킬을 먼저 배워야 합니다. 불가능한 스킬트리입니다.

```java
public static int solution_0409_2(String skill, String[] skill_trees) {
    int answer = 0;
    char[] skill_char = skill.toCharArray();
    int[] skill_index;
    boolean count_status = true;

    for(String skill_step : skill_trees){
        count_status = true;
        skill_index = new int[skill.length()];
        for(int i = 0 ; i < skill_char.length ; i++){
            int indexOf = skill_step.indexOf(skill_char[i]);
            if(indexOf == -1){
                skill_index[i] = 999;
            }
            else{
                skill_index[i] = indexOf + 1;
            }
        }
        for(int k = 0 ; k < skill_index.length - 1 ; k++){
            if(skill_index[k] > skill_index[k + 1]) count_status = false;
        }
        if(count_status) answer++;
    }
    return answer;
}
```

#### 인기 해답
##### 📌indexOf의 기능 ,  replaceAll의 정규표현식 사용 가능!

```java
public static int solution_0409_3(String skill, String[] skill_trees) {

    System.out.println("ABCDEFGH".indexOf("AB"));   // 0
    System.out.println("ABCDEFGH".indexOf("EFG"));  // 4
    System.out.println("ABCDEFGH".indexOf("GH"));   // 6
    System.out.println("ABCDEFGH".indexOf("CDEF")); // 2

    int answer = 0;
    ArrayList<String> skillTrees = new ArrayList<String>(Arrays.asList(skill_trees));
    //ArrayList<String> skillTrees = new ArrayList<String>();
    Iterator<String> it = skillTrees.iterator();

    while (it.hasNext()) {
        if (skill.indexOf(it.next().replaceAll("[^" + skill + "]", "")) != 0) {
            it.remove();
        }
    }
    answer = skillTrees.size();
    return answer;
}
```

### 가장 큰 정사각형 찾기 (미완료)
- 표(board)는 2차원 배열로 주어집니다.
- 표(board)의 행(row)의 크기 : 1,000 이하의 자연수
- 표(board)의 열(column)의 크기 : 1,000 이하의 자연수
- 표(board)의 값은 1또는 0으로만 이루어져 있습니다.
- 입출력 예

| board  | return |
|:--------|:--------|
| `[[0,1,1,1],[1,1,1,1],[1,1,1,1],[0,0,1,0]]`	 | 9 |

```java
public static int solution_0409_1(int [][]board){
    int answer = 1234;
    int x = 0 , y = 0;
    int size;
    List<Integer> answerList = new ArrayList<Integer>();

    for(int i = 0 ; i < board.length ; i++){
        for(int j = 0 ; j < board[0].length ; j++){
            size = 0;
            if(i != j){
                if(board[i][j] == 1 && board[j][i] == 1){
                    for(int k = 0 ; k < i ; k++){
                        for(int q = 0 ; q < j ; q++){
                            if(board[k][q] == 1){
                                size++;
                            }
                            else{
                                break;
                            }
                        }
                    }
                }
            }
            answerList.add(size);
        }
    }
    System.out.println(answerList);
    return answer;
}
```
