---
layout: default
title: 2022년 8월
nav_order: 16
parent: 🐢 알고리즘
---
## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

# **[Algorithm Study 16주차 - `Recursion & Backtracking`](https://github.com/jdalma/Algorithm-Study/tree/main/%5BWeek16%20-%20Recursion%26Backtracking%5D)**

## [부등호](https://github.com/jdalma/Algorithm-Study/blob/main/%5BWeek16%20-%20Recursion%26Backtracking%5D/%EC%A0%95%ED%98%84%EC%A4%80/A_2529.java)
## 투에-모스 문자열 ❌
## 압축 ❌
## N-Queen ❌
## 가장 긴 증가하는 부분 수열 5 ❌

# **[Algorithm Study 17주차 - `Number Theory & Prime Number`]()**



# **[Codesoom Algorithm Study 1일차 08.22 - `Queue`](https://github.com/jdalma/algorithm-for-coding-test/tree/main/DAY-01)**

## [카드2](https://github.com/jdalma/algorithm-for-coding-test/blob/main/DAY-01/2164.java)

```
예를 들어 N=4인 경우를 생각해 보자. 
카드는 제일 위에서부터 1234 의 순서로 놓여있다. 
1을 버리면 234가 남는다. 여기서 2를 제일 아래로 옮기면 342가 된다. 
3을 버리면 42가 되고, 4를 밑으로 옮기면 24가 된다. 
마지막으로 2를 버리고 나면, 남는 카드는 4가 된다.
```
- 위의 지문을 읽고 큐에서 빼는거 1번 , 큐에서 다시 빼고 뒤로 넣는 것 1번
- 2번의 연산을 반복하면서 해결할 수 있었다

## [요세푸스 문제](https://github.com/jdalma/algorithm-for-coding-test/blob/main/DAY-01/1158.java)

- 카드2와 흡사했다
- `K - 1`만큼 큐에서 꺼내 뒤로 추가하고 `K - 1`만큼 반복문이 끝나면 결과에 담았다

## [프린터 큐](https://github.com/jdalma/algorithm-for-coding-test/blob/main/DAY-01/1966.java)

- **Document**클래스를 추가하여 우선순위 큐나 리스트에 담아서 **Document**자체를 정렬 해야하나 생각했다
- 하지만 우선순위에 밀리는 출력 번호들은 다시 뒤로 추가되어야 하고 그 추가된 횟수는 결과에 반영되면 안된다
- `PriorityQueue<Integer> priority`
- `Deque<Document> print`
- 우선순위 번호를 `priority` 에 담아 높은 값 부터 꺼내고 `print`에 담겨있는 문서들을 꺼내서 우선순위가 같은지 확인하였다
- 다르다면 `print`의 뒤에 추가하였고 같다면 출력 `count`를 증가시켰다

# **[Codesoom Algorithm Study 2일차 08.23 - `Stack`](https://github.com/jdalma/algorithm-for-coding-test/tree/main/DAY-02)**

## [괄호](https://github.com/jdalma/algorithm-for-coding-test/blob/main/DAY-02/9012.java)

- `(`는 스택에 항상 넣고 `)`는 stack의 가장 위를 확인하여 `(`가 아니라면 false다
- 반복문이 다 끝난 후에 stack이 비어있지 않다면 false다

## [단어 뒤집기 2](https://github.com/jdalma/algorithm-for-coding-test/blob/main/DAY-02/17413.java)

- `<` , `>` , `{공백}` 마다 분기 처리를 하였다
- 꺽새 안에 들어있는 문자열은 그대로 유지해야하니 flag값을 두어 처리하였다 

## [문자열 폭발](https://github.com/jdalma/algorithm-for-coding-test/blob/main/DAY-02/9935.java)

- 처음에는 큐를 계속 돌리면서 확인하면 되지 않을까 생각헀지만 시간초과가 날 것 같았다
- 풀었던 문제인데 생각이 잘 나지않아 전에 어떻게 풀었는지 참고해서 풀었다..
- 원래는 **Deque**을 사용하는데 인덱스로 접근하기 위해 **Stack**을 사용하였다
- 기존 문자열이 삭제 문자열의 길이보다 커지면 `stack.get(stack.size() - remove.length + j) != remove[j]` 이렇게 확인하였다
- 삭제 문자열과 동일하다면 스택에서 그만큼 pop하였다