---
layout: default
title: 2022년 8월
nav_order: 16
parent: 🐢 알고리즘
---
## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

# **[Algorithm Study 16주차 - `Recursion & Backtracking`](https://github.com/jdalma/Algorithm-Study/tree/main/%5BWeek16%20-%20Recursion%26Backtracking%5D)**

## [부등호](https://github.com/jdalma/Algorithm-Study/blob/main/%5BWeek16%20-%20Recursion%26Backtracking%5D/%EC%A0%95%ED%98%84%EC%A4%80/A_2529.java)
## 투에-모스 문자열 ❌
## 압축 ❌
## N-Queen ❌
## 가장 긴 증가하는 부분 수열 5 ❌

***

# **[Algorithm Study 17주차 - `Number Theory & Prime Number`]()**

***

# **[Codesoom Algorithm Study 1일차 08.22 - `Queue`](https://github.com/jdalma/algorithm-for-coding-test/tree/main/DAY-01)**

## [카드2](https://github.com/jdalma/algorithm-for-coding-test/blob/main/DAY-01/2164.java)

```
예를 들어 N=4인 경우를 생각해 보자. 
카드는 제일 위에서부터 1234 의 순서로 놓여있다. 
1을 버리면 234가 남는다. 여기서 2를 제일 아래로 옮기면 342가 된다. 
3을 버리면 42가 되고, 4를 밑으로 옮기면 24가 된다. 
마지막으로 2를 버리고 나면, 남는 카드는 4가 된다.
```
- 위의 지문을 읽고 큐에서 빼는거 1번 , 큐에서 다시 빼고 뒤로 넣는 것 1번
- 2번의 연산을 반복하면서 해결할 수 있었다

## [요세푸스 문제](https://github.com/jdalma/algorithm-for-coding-test/blob/main/DAY-01/1158.java)

- 카드2와 흡사했다
- `K - 1`만큼 큐에서 꺼내 뒤로 추가하고 `K - 1`만큼 반복문이 끝나면 결과에 담았다

## [프린터 큐](https://github.com/jdalma/algorithm-for-coding-test/blob/main/DAY-01/1966.java)

- **Document**클래스를 추가하여 우선순위 큐나 리스트에 담아서 **Document**자체를 정렬 해야하나 생각했다
- 하지만 우선순위에 밀리는 출력 번호들은 다시 뒤로 추가되어야 하고 그 추가된 횟수는 결과에 반영되면 안된다
- `PriorityQueue<Integer> priority`
- `Deque<Document> print`
- 우선순위 번호를 `priority` 에 담아 높은 값 부터 꺼내고 `print`에 담겨있는 문서들을 꺼내서 우선순위가 같은지 확인하였다
- 다르다면 `print`의 뒤에 추가하였고 같다면 출력 `count`를 증가시켰다

***

# **[Codesoom Algorithm Study 2일차 08.23 - `Stack`](https://github.com/jdalma/algorithm-for-coding-test/tree/main/DAY-02)**

## [괄호](https://github.com/jdalma/algorithm-for-coding-test/blob/main/DAY-02/9012.java)

- `(`는 스택에 항상 넣고 `)`는 stack의 가장 위를 확인하여 `(`가 아니라면 false다
- 반복문이 다 끝난 후에 stack이 비어있지 않다면 false다

## [단어 뒤집기 2](https://github.com/jdalma/algorithm-for-coding-test/blob/main/DAY-02/17413.java)

- `<` , `>` , `{공백}` 마다 분기 처리를 하였다
- 꺽새 안에 들어있는 문자열은 그대로 유지해야하니 flag값을 두어 처리하였다 

## [문자열 폭발](https://github.com/jdalma/algorithm-for-coding-test/blob/main/DAY-02/9935.java)

- 처음에는 큐를 계속 돌리면서 확인하면 되지 않을까 생각헀지만 시간초과가 날 것 같았다
- 풀었던 문제인데 생각이 잘 나지않아 전에 어떻게 풀었는지 참고해서 풀었다..
- 원래는 **Deque**을 사용하는데 인덱스로 접근하기 위해 **Stack**을 사용하였다
- 기존 문자열이 삭제 문자열의 길이보다 커지면 `stack.get(stack.size() - remove.length + j) != remove[j]` 이렇게 확인하였다
- 삭제 문자열과 동일하다면 스택에서 그만큼 pop하였다

***

# **[Codesoom Algorithm Study 3일차 08.24 - `Map`](https://github.com/jdalma/algorithm-for-coding-test/tree/main/DAY-03)**

## [숫자 카드2](https://github.com/jdalma/algorithm-for-coding-test/blob/main/DAY-03/10816.java)


## [듣보잡](https://github.com/jdalma/algorithm-for-coding-test/blob/main/DAY-03/1764.java)


## [패션왕 신해빈](https://github.com/jdalma/algorithm-for-coding-test/blob/main/DAY-03/9375.java)

```java
int multi = 1;
for(String key : items.keySet()) {
    multi *= items.get(key) + 1;
}        		
```

***

# **[Codesoom Algorithm Study 4일차 08.25 - `String`](https://github.com/jdalma/algorithm-for-coding-test/tree/main/DAY-04)**

## [균형잡힌 세상](https://github.com/jdalma/algorithm-for-coding-test/blob/main/DAY-04/4949.java)

- Stack 괄호문제와 비슷했다
- `짝을 이루는 두 괄호가 있을 때, 그 사이에 있는 문자열도 균형이 잡혀야 한다.` 이 지문 때문에 혼란스러웠다...

## [IOIOI](https://github.com/jdalma/algorithm-for-coding-test/blob/main/DAY-04/5525.java)

- 도저히 O(N)이 생각이 안나서 다른 분 코드를 보고 해결했다 ㅠㅠ
- 슬라이딩 윈도우 방식인 것 같다
- 아래와 같이 O(N<sup>M</sup>)으로 풀어서 실패했다...

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int oSize = Integer.parseInt(br.readLine());
        int lineSize = Integer.parseInt(br.readLine());
        char[] line = br.readLine().toCharArray();
        char[] compare = new char[oSize * 2 + 1];

        for(int i = 0 ; i < compare.length ; i++){
            if(i % 2 == 0){
                compare[i] = 'I';
                continue;
            }
            compare[i] = 'O';
        }

        int result = 0;
        for(int right = 0 ; right < line.length ; right++){
            if(right >= compare.length){
                boolean sameFlag = true;
                for(int i = 0 ; i < compare.length ; i++){
                    if(compare[i] != line[right - i]){
                        sameFlag = false;
                        break;
                    }
                }
                if(sameFlag){
                    result++;
                    right++;
                }
            }
        }
        System.out.println(result);
    }
}
```


## [AC](https://github.com/jdalma/algorithm-for-coding-test/blob/main/DAY-04/5430.java)

- **IOIOI**보다 쉬웠던 것 같다..
- 앞에서 빼낼지 뒤에서 빼낼지 `boolean`을 한 개 두고 처리했다
- 빼낼 때 데이터가 없다면 에외를 던져 잡아서 처리했다

***

# **[Codesoom Algorithm Study 5일차 08.26 - `Binary , Parametric Search`](https://github.com/jdalma/algorithm-for-coding-test/tree/main/DAY-05)**

## [수 찾기](https://github.com/jdalma/algorithm-for-coding-test/blob/main/DAY-05/1920.java)

- 이분탐색 문제

## [예산](https://github.com/jdalma/algorithm-for-coding-test/blob/main/DAY-05/2512.java)

- 파라메트릭서치 문제 : 정해진 총액 이하에서 **가능한 한 최대의 총 예산**
- **입력받는 예산들의 max값** 과 **Lower Bound로 구한 예산의 최대 금액**을 비교해서 최소값을 출력했다

## [랜선 자르기](https://github.com/jdalma/algorithm-for-coding-test/blob/main/DAY-05/1654.java)

- 파라메트릭서치 문제 : **N개보다 많이 만드는 것도 N개를 만드는 것에 포함된다**
- **Upper Bound**인 것 같다

***

# **[Codesoom Algorithm Study 6일차 08.29 - `Sorting`](https://github.com/jdalma/algorithm-for-coding-test/tree/main/DAY-06)**

## [베스트셀러](https://github.com/jdalma/algorithm-for-coding-test/blob/main/DAY-06/1302.java)

- 문자열 기준으로 정렬하고 O(N)으로 선회하며 이름별로 카운트 하여 , 가장 많이 카운트된 이름을 출력했다

## [좌표 압축](https://github.com/jdalma/algorithm-for-coding-test/blob/main/DAY-06/18870.java)

- *문제가 이해가 안갔다..*
- 입력받은 숫자별로 낮은 값에 높은 우선순위(0부터)를 매기는 것
- 출력은 그 입력받은 숫자 순서대로 우선순위를 출력하여야 한다

## [회의실 배정](https://github.com/jdalma/algorithm-for-coding-test/blob/main/DAY-06/1931.java)

- Room 클래스를 만들어서 `return this.end - o.end;` **끝나는 시간을 오름차순**으로 정렬하였다
  - 하지만 88%에서 실패..
- 끝나는 시간이 똑같다면 **시작 시간을 오름차순**으로 추가해주니 통과

```java
@Override
public int compareTo(Room o) {
    if(this.end == o.end){
        return this.start - o.start;
    }
    return this.end - o.end;
}
```

***

# **[Codesoom Algorithm Study 7일차 08.30 - `BruteForce`](https://github.com/jdalma/algorithm-for-coding-test/tree/main/DAY-07)**

## [체스판 다시 칠하기](https://github.com/jdalma/algorithm-for-coding-test/blob/main/DAY-07/1018.java)

- 탐색 시작 지점이 `B`라면 `W`일 때도 계산해줬어야 했다

## [문서 검색](https://github.com/jdalma/algorithm-for-coding-test/blob/main/DAY-07/1543.java)

- **기존 문자열**을 순회하면서 **비교 문자열**을 비교

## [리모컨](https://github.com/jdalma/algorithm-for-coding-test/blob/main/DAY-07/1107.java) ❌

- **어떻게 풀어야할지 아이디어가 떠오르지 않았다**
- DFS로 푼 분의 코드를 참고하였다
  1. `+` , `-` 버튼으로 움직일 때 횟수
  2. 중복이 허용되는 순열로 모든 횟수
