---
layout: default
title: 2021ë…„10ì›”
nav_order: 6
parent: ì•Œê³ ë¦¬ì¦˜
---
## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---


# **`[ë°±ì¤€] ë‹¤ìµìŠ¤íŠ¸ë¼ - ê¸°ì´ˆë¬¸ì œ` [ìµœë‹¨ê±°ë¦¬](https://www.acmicpc.net/problem/1753)**

## checked 2ì°¨ì› ë°°ì—´ë¡œ ì¸í•œ <span style="color:red; font-weight:bold">ë©”ëª¨ë¦¬ì´ˆê³¼</span>

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

class Main {
    static int[][] map;
    static boolean[][] checked;
    static int[] result;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int vertex = Integer.parseInt(st.nextToken());
        int edge = Integer.parseInt(st.nextToken());
        map = new int[vertex + 1][vertex + 1];
        checked = new boolean[vertex + 1][vertex + 1];
        result = new int[vertex + 1];
        Arrays.fill(result , Integer.MAX_VALUE);
        int stanVertex = Integer.parseInt(br.readLine());

        for(int i = 0 ; i < edge ; i++){
            st = new StringTokenizer(br.readLine());
            int sVertex = Integer.parseInt(st.nextToken());
            int eVertex = Integer.parseInt(st.nextToken());
            int cost = Integer.parseInt(st.nextToken());
            map[sVertex][eVertex] = cost;
        }

        bfs(stanVertex , vertex);

        for(int i = 1 ; i < result.length; i++){
            if(result[i] == Integer.MAX_VALUE) System.out.println("INF");
            else System.out.println(result[i]);
        }
    }

    public static void bfs(int stanVertex , int vertexSize){
        Queue<int[]> queue = new LinkedList<>();
        queue.offer(new int[]{stanVertex , 0});
        while(!queue.isEmpty()){
            int[] now = queue.poll();
            int nowVertex = now[0];
            int nowCost = now[1];
            result[nowVertex] = Math.min(result[nowVertex] , nowCost);
            for(int i = 1 ;  i <= vertexSize ; i++){
                if(!checked[nowVertex][i] && map[nowVertex][i] != 0){
                    checked[nowVertex][i] = true;
                    queue.offer(new int[]{i , map[nowVertex][i] + nowCost});
                }
            }
        }
    }
}
```

## **ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ - í†µê³¼**
- **ê°€ì¤‘ì¹˜ì— ìŒìˆ˜ê°€ ë‚˜ì˜¤ë©´ ì ìš©ì´ ë¶ˆê°€í•˜ë‹¤.**
- **ìš°ì„ ìˆœìœ„ íë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šê³  ì¼ë°˜ íë¥¼ ì‚¬ìš©í•˜ë©´ ì‹œê°„ì´ˆê³¼ê°€ ë‚œë‹¤.**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

class Edge implements Comparable<Edge>{
    int vertex;
    int cost;
    public Edge(int vertex, int cost) {
        this.vertex = vertex;
        this.cost = cost;
    }
    @Override
    public int compareTo(Edge o) {
        return cost - o.cost;
    }
}

class Main {
    static int[] result;
    static List<ArrayList<Edge>> list = new ArrayList<>();
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int vertex = Integer.parseInt(st.nextToken());
        int edge = Integer.parseInt(st.nextToken());
        result = new int[vertex + 1];
        Arrays.fill(result , Integer.MAX_VALUE);
        int stanVertex = Integer.parseInt(br.readLine());
        for(int i = 0 ; i <= vertex ; i++) list.add(new ArrayList<>());
        for(int i = 0 ; i < edge ; i++){
            st = new StringTokenizer(br.readLine());
            int sVertex = Integer.parseInt(st.nextToken());
            int eVertex = Integer.parseInt(st.nextToken());
            int cost = Integer.parseInt(st.nextToken());
            list.get(sVertex).add(new Edge(eVertex , cost));
        }
        bfs(stanVertex , vertex);
        StringBuilder resultString = new StringBuilder();
        for(int i = 1 ; i < result.length; i++){
            if(result[i] == Integer.MAX_VALUE) resultString.append("INF\n");
            else resultString.append(result[i]).append("\n");
        }
        System.out.println(resultString.toString());
    }

    public static void bfs(int stanVertex , int vertexSize){
        PriorityQueue<Edge> pq = new PriorityQueue<>();
        result[stanVertex] = 0;
        pq.offer(new Edge(stanVertex , 0));
        while(!pq.isEmpty()){
            Edge now = pq.poll();
            int nowVertex = now.vertex;
            int nowCost = now.cost;
            if(nowCost > result[nowVertex]) continue;
            for(Edge edges : list.get(nowVertex)){
                if(result[edges.vertex] > nowCost + edges.cost){
                    result[edges.vertex] = nowCost + edges.cost;
                    pq.offer(new Edge(edges.vertex , nowCost + edges.cost));
                }
            }
        }
    }
}
```


# **`[ë°±ì¤€] í”Œë¡œì´ë“œ ì™€ìƒ¬ - ëª¨ë“  ì •ì ì—ì„œ ëª¨ë“  ì •ì ìœ¼ë¡œì˜ ìµœë‹¨ ê²½ë¡œ` [ê²½ë¡œì°¾ê¸°](https://www.acmicpc.net/problem/11403)**

- [ì½ì–´ë³´ê¸°](https://steady-coding.tistory.com/94)

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

class Main {
    static int[][] map;
    static boolean[] checked;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int size = Integer.parseInt(br.readLine());
        map = new int[size][size];
        checked = new boolean[size];
        for(int i = 0 ; i < size ; i++){
            String[] line = br.readLine().split(" ");
            for(int j = 0 ; j < line.length ; j++){
                map[i][j] = Integer.parseInt(line[j]);
            }
        }
        for(int i = 0 ; i < size ; i++){
            for(int k = 0 ; k < size ; k++) checked[k] = false;
            for(int j = 0 ; j < size ; j++){
                if(map[i][j] == 1 && !checked[j]){
                    dfs(i , j , size);
                }
            }
        }

        for(int i = 0 ; i < size ; i++){
            for(int j = 0 ; j < size ; j++){
                System.out.print(map[i][j] + " ");
            }
            System.out.println();
        }
    }

    public static void dfs(int x , int y , int size){
        checked[y] = true;
        map[x][y] = 1;
        for(int i = 0 ; i < size ; i++){
            if(!checked[i] && map[y][i] == 1) {
//                System.out.println(map[y][i] + "  " + y + "  " +  i);
                dfs(x , i , size);
            }
        }
    }
}
```

***

# **`[ë°±ì¤€] BFS` [ì•Œê³ ìŠ¤íŒŸ](https://www.acmicpc.net/problem/1261) âŒ**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

class Position implements Comparable<Position>{
    int x;
    int y;
    int breakWall;
    public Position(int x, int y, int breakWall) {
        this.x = x;
        this.y = y;
        this.breakWall = breakWall;
    }

    @Override
    public int compareTo(Position o) {
        return breakWall - o.breakWall;
    }
}

class Main {
    static int[] moveX = {-1 , 0 , 1 , 0};
    static int[] moveY = {0 , 1 , 0 , -1};
    static int[][] map;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int y = Integer.parseInt(st.nextToken());
        int x = Integer.parseInt(st.nextToken());
        map = new int[x][y];
        for(int i = 0 ; i < x ; i++){
            String[] line = br.readLine().split("");
            for(int j = 0 ; j < y ; j++){
                map[i][j] = Integer.parseInt(line[j]);
            }
        }
        System.out.println(start(x - 1, y - 1));
    }

    public static int start(int targetX , int targetY){
        boolean[][] visited = new boolean[targetX + 1][targetY + 1];
        PriorityQueue<Position> queue = new PriorityQueue<>();
        queue.offer(new Position(0 , 0 ,0));
        visited[0][0] = true;

        while(!queue.isEmpty()){
            Position now = queue.poll();
            if(now.x == targetX && now.y == targetY){
                return now.breakWall;
            }
            for (int i = 0; i < 4; i++) {
                int moveXpos = now.x + moveX[i];
                int moveYpos = now.y + moveY[i];
                if (moveXpos >= 0 && moveYpos >= 0 && moveXpos <= targetX && moveYpos <= targetY && !visited[moveXpos][moveYpos]) {
                    visited[moveXpos][moveYpos] = true;
                    if (map[moveXpos][moveYpos] == 1) {
                        queue.offer(new Position(moveXpos, moveYpos, now.breakWall + 1));
                    }
                    else {
                        queue.offer(new Position(moveXpos, moveYpos, now.breakWall));
                    }
                }
            }
        }
        return 0;
    }
}
```

***

# **`[ë°±ì¤€ BFS]` [êµ¬ìŠ¬íƒˆì¶œ](https://www.acmicpc.net/problem/13459) âŒ**

- 4 ë°©í–¥ìœ¼ë¡œ ê¸°ìš¸ì´ë©° ë¹¨ê°„ êµ¬ìŠ¬ì„ êµ¬ë©ìœ¼ë¡œ ë¹¼ë‚´ëŠ” ë¬¸ì œ
  - ë²½ì„ ë§Œë‚  ë•Œ ê¹Œì§€ ì§„í–‰
- ë¹¨ê°„ êµ¬ìŠ¬ê³¼ íŒŒë€ êµ¬ìŠ¬ì€ ê°™ì€ ìœ„ì¹˜ì— ìˆì„ ìˆ˜ ì—†ìœ¼ë©° ë™ì‹œì— ì›€ì§ì¸ë‹¤.
- íŒŒë€ êµ¬ìŠ¬ì´ ë¹ ì§€ë©´ ì‹¤íŒ¨

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

class MarblePosition{
    Position red;
    Position blue;
    public MarblePosition(Position red, Position blue) {
        this.red = red;
        this.blue = blue;
    }
}

class Position{
    int x;
    int y;
    int moveCount;
    public Position(int x, int y, int moveCount) {
        this.x = x;
        this.y = y;
        this.moveCount = moveCount;
    }
    public Position(int x, int y) {
        this.x = x;
        this.y = y;
    }
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        Position position = (Position) o;

        if (x != position.x) return false;
        return (y == position.y);
    }
}

class Main {
    static int x , y;
    static char[][] arr;
    static boolean[][] visited;
    static Position red , blue , hole;
    static int[] moveX = {-1 , 0 , 1 , 0};
    static int[] moveY = {0 , 1 , 0 , -1};
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        x = Integer.parseInt(st.nextToken());
        y = Integer.parseInt(st.nextToken());
        arr = new char[x][y];
        visited = new boolean[x][y];
        for(int i = 0 ; i < x ; i++){
            char[] chArr = br.readLine().toCharArray();
            for(int j = 0 ; j < y ; j++){
                char ch = chArr[j];
                if(ch == 'R') red = new Position(i , j , 0);
                else if(ch == 'B') blue = new Position(i , j , 0);
                else if(ch == 'O') hole = new Position(i , j , 0);
                arr[i][j] = ch;
            }
        }
        bfs();
    }

    public static void bfs(){
        Queue<MarblePosition> queue = new LinkedList<>();
        boolean success = true;
        queue.offer(new MarblePosition(red , blue));
        while(!queue.isEmpty()){
            MarblePosition nowPos = queue.poll();
            // 4ë°© í™•ì¸
            for(int i = 0 ; i < 4 ; i++){
                int redXPos = nowPos.red.x + moveX[i];
                int redYPos = nowPos.red.y + moveY[i];
                int blueXPos = nowPos.blue.x + moveX[i];
                int blueYPos = nowPos.blue.y + moveY[i];
                Position movingRed = new Position(redXPos , redYPos);
                Position movingBlue = new Position(blueXPos , blueYPos);
                // ë°©í–¥ ì •í•´ì§€ë©´ ë²½ì„ ë§Œë‚  ë•Œ ê¹Œì§€
                while(arr[redXPos][redYPos] != '#'){
                    if(arr[redXPos][redYPos] == '.' && !visited[redXPos][redYPos]){
                        visited[redXPos][redYPos] = true;

                    }
                }
            }

        }
    }
}
```

***

# **ğŸ”¥ `[ë°±ì¤€] DFS` [ì‚¬ë‹¤ë¦¬ ì¡°ì‘](https://www.acmicpc.net/problem/15684) ğŸ“ âŒ**

- [ì°¸ê³ ](https://pangtrue.tistory.com/282)

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;


class Main {
    static boolean[] visited;
    static int[][] moveArr;
    static int N , M , H;
    public static void main(String[] args) throws IOException {
        Scanner sc = new Scanner(System.in);
        N = sc.nextInt(); // ì„¸ë¡œ ì„ 
        M = sc.nextInt(); // ê°€ë¡œ ì„ 
        H = sc.nextInt(); // ì„¸ë¡œì„  ë§ˆë‹¤ ë†“ì„ ìˆ˜ ìˆëŠ” ìœ„ì¹˜ì˜ ê°œìˆ˜
        moveArr = new int[M + 1][H + 1];
        for(int i = 0 ; i < M ; i++){
            int row = sc.nextInt();
            int col = sc.nextInt();
            moveArr[row][col] = 1;
            moveArr[row][col+1] = -1;
        }
//        for(int i = 0 ; i < M + 1 ; i++){
//            for(int j = 0 ; j < N + 1 ; j++){
//                System.out.print(moveArr[i][j] + " ");
//            }
//            System.out.println();
//        }

        for(int i = 1 ; i <= N ; i++){
            recursive( i , 0 , i , 0);
        }
    }

    public static void recursive(int start , int x , int y , int addRowCount){
        if(addRowCount > H){}
        else if(x >= H){
            System.out.println(y);
        }
        else{
            int moveY = y + moveArr[x][y];
            recursive(start , x + 1 , moveY , addRowCount);
        }
    }
}
```

***

# **`[ë°±ì¤€] BFS` [ì í”„ ê²Œì„](https://www.acmicpc.net/problem/15558)**

```java
package algorithm;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

class Position implements Comparable<Position>{
	int x;
	int y;
	int time;
	public Position(int x, int y , int time) {
		this.x = x;
		this.y = y;
		this.time = time;
	}
	@Override
	public int compareTo(Position o) {
		return o.y - this.y;
	}
	@Override
	public String toString() {
		return "Position [x=" + x + ", y=" + y + "]";
	}

}

class Main {
    static boolean[][] visited;
    static int[][] map;
    static int N , K;
    static boolean gameEnd = false;
    static int timeCount = 0;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        N = Integer.parseInt(st.nextToken()); // ì¹¸ ìˆ˜
        K = Integer.parseInt(st.nextToken()); // ì¤„ ë°”ê¿ˆ í›„ ì í”„ ì¹¸ ìˆ˜
        map = new int[2][N];
        visited = new boolean[2][N];
        for(int i = 0 ; i < 2 ; i++) {
        	String[] line = br.readLine().split("");
        	for(int j = 0 ; j < N ; j++) {
        		map[i][j] = Integer.parseInt(line[j]);
        	}
        }

//        for(int i = 0 ; i < 2 ; i++) {
//        	for(int j = 0 ; j < N ; j++) {
//        		System.out.print(map[i][j]);
//        	}
//        	System.out.println();
//        }
        if(bfs()) System.out.println("1");
        else System.out.println("0");
    }
    public static boolean bfs() {
//    	PriorityQueue<Position> pq = new PriorityQueue<Position>();
    	Queue<Position> pq = new LinkedList<Position>();
    	int[] moveDistance = {-1 , 1 , K};
    	pq.offer(new Position(0 , 0 , 0));
    	visited[0][0] = true;
    	while(!pq.isEmpty()) {
    		Position now = pq.poll();
//    		System.out.println(now);
			int moveX , moveY;
			for(int i = 0 ; i < 3 ; i++) {
				if(i == 2) moveX = now.x == 1 ? 0 : 1;
				else moveX = now.x;
				moveY = now.y + moveDistance[i];

				if((now.time > moveY)) continue;
				else if(moveY >= N) {
//					System.out.print(moveY + " ");
					return true;
				}
				else if(moveY >= 0 && map[moveX][moveY] == 1 && !visited[moveX][moveY]) {
    				pq.offer(new Position(moveX , moveY , now.time + 1));
    				visited[moveX][moveY] = true;
    			}
    		}
    	}
    	return false;
    }
}
```

***

# **`[ë°±ì¤€] ìˆ˜í•™` [ë‚˜ë¨¸ì§€](https://www.acmicpc.net/problem/10430)**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;


class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int A = Integer.parseInt(st.nextToken());
        int B = Integer.parseInt(st.nextToken());
        int C = Integer.parseInt(st.nextToken());

        StringBuilder result = new StringBuilder();
        result.append( (A + B) % C ).append("\n");
        result.append( ((A % C) + (B % C)) % C).append("\n");
        result.append( (A * B) % C ).append("\n");
        result.append( ((A % C) * (B % C)) % C).append("\n");
        System.out.println(result.toString());
    }
}
```

***

# **`[ë°±ì¤€] ìˆ˜í•™` [ìµœëŒ€ê³µì•½ìˆ˜ì™€ ìµœì†Œê³µë°°ìˆ˜](https://www.acmicpc.net/problem/2690)**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;


class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int A = Integer.parseInt(st.nextToken());
        int B = Integer.parseInt(st.nextToken());
        System.out.println(greatest(A , B));
        System.out.println(least(A , B));
    }

    public static int greatest(int A , int B){
        List<Integer> firstList = new ArrayList<Integer>();
        for(int i = 1 ; i <= A ; i++){
            if(A % i == 0) firstList.add(i);
        }
        List<Integer> secondList = new ArrayList<Integer>();
        for(int i = 1 ; i <= B ; i++){
            if(B % i == 0) secondList.add(i);
        }
        int firstIndex = 0;
        int secondIndex = 0;
        int result = 0;
        while(true){
            if(firstIndex >= firstList.size() || secondIndex >= secondList.size()) break;
            int first = firstList.get(firstIndex);
            int second = secondList.get(secondIndex);
            if(first == second) {
                result = first;
                firstIndex++;
                secondIndex++;
            }
            else if(first > second) secondIndex++;
            else if(second > first) firstIndex++;
        }
        return result;
    }

    public static int least(int A , int B){
        int multipleA = 1;
        int multipleB = 1;
        while(true){
            int tmpA = A * multipleA;
            int tmpB = B * multipleB;
            if(tmpA == tmpB) return tmpA;
            else if(tmpA > tmpB) multipleB++;
            else if(tmpB > tmpA) multipleA++;
        }
    }
}
```

***

# **`[ë°±ì¤€] ìˆ˜í•™` [ìµœì†Œê³µë°°ìˆ˜](https://www.acmicpc.net/problem/1934)**


```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;


class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int size = Integer.parseInt(br.readLine());
        for(int i = 0 ; i < size ; i++){
            StringTokenizer st = new StringTokenizer(br.readLine());
            int A = Integer.parseInt(st.nextToken());
            int B = Integer.parseInt(st.nextToken());
            System.out.println(least(A , B));
        }
    }

    public static int least(int A , int B){
        int multipleA = 1;
        int multipleB = 1;
        while(true){
            int tmpA = A * multipleA;
            int tmpB = B * multipleB;
            if(tmpA == tmpB) return tmpA;
            else if(tmpA > tmpB) multipleB++;
            else if(tmpB > tmpA) multipleA++;
        }
    }

}
```

***

# **`[ë°±ì¤€] ìˆ˜í•™ - ìœ í´ë¦¬ë“œ í˜¸ì œë²•` [GCD í•©](https://www.acmicpc.net/problem/9613) ğŸ“**

## **ìœ í´ë¦¬ë“œ í˜¸ì œë²•**
- **ìµœëŒ€ê³µì•½ìˆ˜ë¥¼ êµ¬í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ì˜ í•˜ë‚˜ì´ë‹¤.**
- í˜¸ì œë²•ì´ë€ ë§ì€ ë‘ ìˆ˜ê°€ ì„œë¡œ ìƒëŒ€ë°© ìˆ˜ë¥¼ ë‚˜ëˆ„ì–´ì„œ ê²°êµ­ ì›í•˜ëŠ” ìˆ˜ë¥¼ ì–»ëŠ” ì•Œê³ ë¦¬ì¦˜ì„ ë‚˜íƒ€ë‚¸ë‹¤.

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;


class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringBuilder sb = new StringBuilder();
        int size = Integer.parseInt(br.readLine());
        for(int i = 0 ; i < size ; i++){
            StringTokenizer st = new StringTokenizer(br.readLine());
            int numberCount = Integer.parseInt(st.nextToken());
            List<Integer> numbers = new ArrayList<Integer>();
            for(int j = 0 ; j < numberCount ; j++){
                numbers.add(Integer.parseInt(st.nextToken()));
            }
            sb.append(solve(numbers)).append("\n");
        }
        System.out.println(sb.toString());
    }

    public static long solve(List<Integer> numbers){
        long sum = 0;
        for(int i = 0 ; i < numbers.size() - 1; i++){
            for(int j = i + 1 ; j < numbers.size() ; j++){
                sum += GCD(numbers.get(i) , numbers.get(j));
            }
        }
        return sum;
    }

    public static int GCD(int a , int b){
        if(b == 0) return a;
        return GCD(b , a % b);
    }

}
```

***

# **`[ë°±ì¤€] ìˆ˜í•™` [ì†Œìˆ˜ ì°¾ê¸°](https://www.acmicpc.net/problem/1978)**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;


class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int count = 0;
        int size = Integer.parseInt(br.readLine());
        StringTokenizer st = new StringTokenizer(br.readLine());
        for(int i = 0 ; i < size ; i++){
            int number = Integer.parseInt(st.nextToken());
            if(isPrime(number)) count++;
        }
        System.out.println(count);
    }

    public static boolean isPrime(int num){
        if(num == 1) return false;
        for(int i = 2 ; i < num ; i++){
            if(num % i == 0) return false;
        }
        return true;
    }
}
```

***

# **`[ë°±ì¤€] ìˆ˜í•™` [ê³¨ë“œë°”íì˜ ì¶”ì¸¡](https://www.acmicpc.net/problem/6588)**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;


class Main {
    static StringBuilder resultString = new StringBuilder();
    static boolean[] memoization = new boolean[1000001];
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        while(true){
            int number = Integer.parseInt(br.readLine());
            if(number == 0) break;
            else{
                solve(number);
            }
        }
        System.out.println(resultString);
    }
    public static boolean solve(int number){
        for(int i = 3 ; i < number ; i++){
            if(number == (i + number - i) && isPrime(i) && isPrime(number - i)){
                resultString.append(number).append(" = ").append(i).append(" + ").append(number - i).append("\n");
                return true;
            }
        }
        resultString.append("Goldbach's conjecture is wrong.");
        return false;
    }
    public static boolean isPrime(int num){
        if(memoization[num]) return true;
        else if(num == 1) return false;
        for(int i = 2 ; i < num ; i++){
            if(num % i == 0) return false;
        }
        return memoization[num] = true;
    }
}
```

***

# **`[ë°±ì¤€] ë¸Œë£¨íŠ¸ í¬ìŠ¤` [ì¼ê³± ë‚œìŸì´](https://www.acmicpc.net/problem/2309)**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;


class Main {
    static int[] height = new int[9];
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int sumHeight = 0;
        for(int i = 0 ; i < 9 ; i++){
            int value = Integer.parseInt(br.readLine());
            sumHeight += value;
            height[i] = value;
        }

        int exceptIndex1 = 0 , exceptIndex2 = 0;
        Arrays.sort(height);
        Loop1:
        for(int i = 0 ; i < 9 ; i++){
            for(int j = 0 ; j < 9 ; j++){
                if(sumHeight - (height[i] + height[j]) == 100 && i != j){
                    exceptIndex1 = i;
                    exceptIndex2 = j;
                    break Loop1;
                }
            }
        }
        for(int i = 0 ; i < 9 ; i++){
            if(exceptIndex1 != i && exceptIndex2 != i){
                System.out.println(height[i]);
            }
        }
    }
}
```

***

# **`[ë°±ì¤€] ë¸Œë£¨íŠ¸ í¬ìŠ¤` [ë‚ ì§œ ê³„ì‚°](https://www.acmicpc.net/problem/1476)**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;


class Main {
    static int[] stan = {15 , 28 , 19};
    static int[] year = new int[3];
    static int[] now = new int[3];
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        year[0] = Integer.parseInt(st.nextToken());
        year[1] = Integer.parseInt(st.nextToken());
        year[2] = Integer.parseInt(st.nextToken());

        int count = 0;

        while(true){
            count++;
            for(int i = 0 ; i < 3 ; i++){
                now[i] += 1;
                if(now[i] > stan[i]) now[i] = 1;
            }
            if(isSame()){
                break;
            }
        }
        System.out.println(count);
    }
    public static boolean isSame(){
        boolean result = true;
        for(int i = 0 ; i < 3 ; i++){
            if(now[i] != year[i]) result = false;
        }
        return result;
    }
}
```

***

# **`[ë°±ì¤€] ë¸Œë£¨íŠ¸ í¬ìŠ¤` [ì—°ì‚°ì ë¼ì›Œë„£ê¸°2](https://www.acmicpc.net/problem/15658)**

```java
import java.util.*;
import java.io.*;

public class Main {
    static int[] symbolArr = new int[4];
    static int[] numArr;
    static int[] printArr;
    static int max = Integer.MIN_VALUE, min = Integer.MAX_VALUE;
    static int symbolCount = 0;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int size = Integer.parseInt(br.readLine());
        numArr = new int[size];
        printArr = new int[size];
        StringTokenizer st = new StringTokenizer(br.readLine());
        for(int i = 0 ; i < size ; i++) {
            numArr[i] = Integer.parseInt(st.nextToken());
        }
        st = new StringTokenizer(br.readLine());
        int index = 0;
        for(int i = 0 ; i < 4 ; i++){
            int count = Integer.parseInt(st.nextToken());
            symbolArr[i] = count;
            symbolCount += count;
        }

//        for(int value : symbolArr) System.out.print(value + " ");

        recursive(1 , numArr[0]);
        System.out.println(max + "\n" + min);
    }
    public static void recursive(int index, int number) {
        if(index == numArr.length) {
//            System.out.println("result = " + number);
            max = Math.max(number, max);
            min = Math.min(number, min);
        }
        else{
            for(int i = 0 ; i < 4 ; i++) {
                if(symbolArr[i] == 0) continue;
                symbolArr[i] -= 1;
                switch(i){
                    case 0:
                        recursive(index + 1 , number + numArr[index]);
//                            System.out.print("+");
                        break;
                    case 1:
                        recursive(index + 1 , number - numArr[index]);
//                            System.out.print("-");
                        break;
                    case 2:
                        recursive(index + 1 , number * numArr[index]);
//                            System.out.print("*");
                        break;
                    case 3:
                        recursive(index + 1 , number / numArr[index]);
//                            System.out.print("/");
                        break;
                }
                symbolArr[i] += 1;
            }
        }
    }
}
```

***

# **`[ë°±ì¤€] ë¸Œë£¨íŠ¸ í¬ìŠ¤` [ë¡œë˜](https://www.acmicpc.net/problem/6603)**

```java
import java.util.*;
import java.io.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        while(true){
            StringTokenizer st = new StringTokenizer(br.readLine());
            int count = Integer.parseInt(st.nextToken());
            if(count != 0){
                int[] numberArr = new int[count];
                int[] printArr = new int[6];
                boolean[] checked = new boolean[count];
                for(int i = 0 ; i < count ; i++){
                    numberArr[i] = Integer.parseInt(st.nextToken());
                }
                dfs(numberArr , printArr , checked ,0 , 0);
                System.out.println();
            }
            else break;
        }
    }
    public static void dfs(int[] numberArr , int[] printArr , boolean[] checked , int index , int numberIndex){
        if(index == 6){
            for(int value : printArr) System.out.print(value + " ");
            System.out.println();
        }
        else{
            for(int i = numberIndex ; i < numberArr.length; i++){
                if(!checked[i]){
                    checked[i] = true;
                    printArr[index] = numberArr[i];
                    dfs(numberArr , printArr , checked , index + 1 , i + 1);
                    checked[i] = false;
                }
            }
        }
    }
}
```

***

# **ğŸ”¥ `[ë°±ì¤€] ë¸Œë£¨íŠ¸ í¬ìŠ¤` [í‡´ì‚¬](https://www.acmicpc.net/problem/14501) ğŸ“**

- [ì°¸ê³ ](https://hidelookit.tistory.com/118)

```java
import java.util.*;
import java.io.*;

public class Main {
    static int[] time , cost , dp;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        int count = Integer.parseInt(br.readLine());

        time = new int[count];
        cost = new int[count];
        dp = new int[count + 1];

        for(int i = 0 ; i < count ; i++){
            StringTokenizer st = new StringTokenizer(br.readLine());
            time[i] = Integer.parseInt(st.nextToken());
            cost[i] = Integer.parseInt(st.nextToken());
        }

        // ì í™”ì‹
        // í˜„ì¬ ë‚ ì§œì—ì„œ ì†Œìš” ì‹œê°„ê³¼ ë¹„ìš©ì„ ë”í•´ dpì— ì €ì¥í•œë‹¤.
        // ì´í›„, ì¤‘ë³µë  ë•Œ ìµœëŒ€ê°’ì„ ë„£ëŠ”ë‹¤.

        for(int i = 0 ; i < count ; i++){
            if(i + time[i] <= count){
                // ë‚ ì§œê°€ ë²”ìœ„ë¥¼ ë„˜ì–´ê°€ì§€ ì•ŠëŠ” ê²½ìš°
                dp[i + time[i]] = Math.max(dp[i] + cost[i] , dp[i + time[i]]);
            }
            // í•´ë‹¹ ê²½ìš°ì˜ ìˆ˜ê°€ 0ì¼ ìˆ˜ ìˆê¸° ë•Œë¬¸ì— ì´ì „ì˜ ìµœëŒ€ê°’ì„ ë„£ì–´ì¤Œ
            // í•´ë‹¹ ë‚ ì§œì— ì¼í•  ìˆ˜ ì—†ë‹¤ë©´ , ì´ì „ê¹Œì§€ ì¼í•œ ìµœëŒ€ ìˆ˜ë‹¹ì„ ë„£ì–´ì£¼ì–´ì•¼ í•œë‹¤.
            dp[i + 1] = Math.max(dp[i] , dp[i + 1]);

//            for(int value : dp) System.out.print(value + " ");
//            System.out.println();
        }
        System.out.println(dp[count]);
    }
}
```

***

# **`[ë°±ì¤€] ê·¸ë˜í”„ ì´ë¡ ` [ìƒê·¼ì´ì˜ ì—¬í–‰](https://www.acmicpc.net/problem/9372)**

```java
package algorithm;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

class Main {
    static List<ArrayList<Integer>> list;
    static boolean[] checked;
    static StringBuilder resultString = new StringBuilder();
    static int result = 0;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int testCase = Integer.parseInt(br.readLine());
        for(int i = 0 ; i < testCase ; i++) {
        	result = -1;
            list = new ArrayList<>();
            StringTokenizer st = new StringTokenizer(br.readLine());
            int countryCount = Integer.parseInt(st.nextToken());
            int airplaneCount = Integer.parseInt(st.nextToken());
            checked = new boolean[countryCount + 1];
            for(int j = 0 ; j <= countryCount ; j++) list.add(new ArrayList<Integer>());
            for(int j = 0 ; j < airplaneCount ; j++) {
                st = new StringTokenizer(br.readLine());
                int start = Integer.parseInt(st.nextToken());
                int destination = Integer.parseInt(st.nextToken());
                list.get(start).add(destination);
                list.get(destination).add(start);
            }
            solve();
            resultString.append(result).append("\n");
        }
        System.out.println(resultString.toString());
    }

    public static void solve() {
        Queue<Integer> queue = new LinkedList<>();
        queue.offer(1);
        checked[1] = true;
        while(!queue.isEmpty()) {
        	int now = queue.poll();
        	result++;
        	for(int value : list.get(now)) {
        		if(!checked[value]) {
        			checked[value] = true;
        			queue.offer(value);	
        		}
        	}
        }
    }
}
```
