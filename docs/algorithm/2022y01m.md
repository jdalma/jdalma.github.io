---
layout: default
title: 2022년 1월
nav_order: 9
parent: 알고리즘
---
## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---


# **`[LeetCode] Binary Search` [Binary Search](https://leetcode.com/problems/binary-search/)**

```java
class Solution {
    public int search(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while(left <= right){
            int middle = (left + right) / 2;
            if(nums[middle] == target){
                return middle;
            }
            else if(nums[middle] < target) left = middle + 1;
            else right = middle - 1;
        }
        
        return -1;
    }
}
```

***

# **`[LeetCode] Binary Search` [Guess Number Higher or Lower](https://leetcode.com/problems/guess-number-higher-or-lower/)**

## Solve - Binary Search

```java
/** 
 * Forward declaration of guess API.
 * @param  num   your guess
 * @return 	     -1 if num is lower than the guess number
 *			      1 if num is higher than the guess number
 *               otherwise return 0
 * int guess(int num);
 */

public class Solution extends GuessGame {
    public int guessNumber(int n) {
        int left = 1;
        int right = n;
        while(left <= right){
            int middle = left + (right - left) / 2;
            int guess = guess(middle);
            if(guess == 0) return middle;
            else if(guess == 1) left = middle + 1;
            else right = middle - 1;
        }
        
        return -1;
    }
}
```

## Solution - Ternary Search

```java
/* The guess API is defined in the parent class GuessGame.
   @param num, your guess
   @return -1 if my number is lower, 1 if my number is higher, otherwise return 0
      int guess(int num); */

public class Solution extends GuessGame {
    public int guessNumber(int n) {
        int low = 1;
        int high = n;
        while (low <= high) {
            int mid1 = low + (high - low) / 3;
            int mid2 = high - (high - low) / 3;
            int res1 = guess(mid1);
            int res2 = guess(mid2);
            if (res1 == 0) return mid1;
            if (res2 == 0) return mid2;
            else if (res1 < 0) high = mid1 - 1;
            else if (res2 > 0) low = mid2 + 1;
            else {
                low = mid1 + 1;
                high = mid2 - 1;
            }
        }
        return -1;
    }
}
```


***

# **`[LeetCode] DP` [Climbing Stairs](https://leetcode.com/problems/climbing-stairs/)**

## Solve

```java
class Solution {
    public int climbStairs(int n) {
        if(n == 1) return 1;
        
        int value1 = 1;
        int value2 = 1;
        for(int i = 2 ; i <= n ; i++){
            int tmp = value1 + value2;
            value1 = value2;
            value2 = tmp;
        }
        return value2;
    }
}
```

## Solution

```java
public class Solution {
    public int climbStairs(int n) {
        if (n == 1) {
            return 1;
        }
        int[] dp = new int[n + 1];
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
}
```

***

# 🔥 **`[LeetCode] DP` [Min Cost Climbing Stairs](https://leetcode.com/problems/min-cost-climbing-stairs/)**

## Bottom-Up (Tabulation)

```java
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int[] min = new int[cost.length + 1];
        
        for(int i = 2 ; i < min.length ; i++){
            int oneStep = min[i - 2] + cost[i - 2];
            int twoStep = min[i - 1] + cost[i - 1];
            min[i] = Math.min(oneStep , twoStep);
        }
        
        return min[cost.length];
    }
}
```

## 👍 Bottom-Up (Constant Space)

```java
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int oneStep = 0;
        int twoStep = 0;
        for(int i = 2 ; i < cost.length + 1; i++){
            int tmp = oneStep;
            oneStep = Math.min(oneStep + cost[i - 1], twoStep + cost[i - 2]);
            twoStep = tmp;            
        }
        return oneStep;
    }
}
```

## Top-Down (Recursion + Memoization)

```java
class Solution {
    int[] memo;
    public int minCostClimbingStairs(int[] cost) {
        memo = new int[cost.length + 1];
        return minCost(cost , cost.length);
    }
    public int minCost(int[] cost , int target){
        if(target <= 1) return 0;
        else if(memo[target] != 0) return memo[target];
        
        int downOne = cost[target - 1] + minCost(cost , target - 1);
        int downTwo = cost[target - 2] + minCost(cost , target - 2);
        return memo[target] = Math.min(downOne , downTwo);
    }
}
```

***

# 🔥 **`[LeetCode] DP - Kadane's Algorithm` [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/)**

## Solve

```java
class Solution {
    public int maxSubArray(int[] nums) {
        if(nums.length == 1) return nums[0];
        
        int result = nums[0];
        for(int i = 1 ; i < nums.length ; i++){
            nums[i] = Math.max(nums[i] , nums[i] + nums[i - 1]);
            result = Math.max(result , nums[i]);
        }
        return result;
    }
}
```

## Solution - Divide and Conquer (Advanced)

```java
class Solution {
    private int[] numsArray;
    
    public int maxSubArray(int[] nums) {
        numsArray = nums;
        
        // Our helper function is designed to solve this problem for
        // any array - so just call it using the entire input!
        return findBestSubarray(0, numsArray.length - 1);
    }
    
    private int findBestSubarray(int left, int right) {
        // Base case - empty array.
        if (left > right) {
            return Integer.MIN_VALUE;
        }
        
        int mid = Math.floorDiv(left + right, 2);
        int curr = 0;
        int bestLeftSum = 0;
        int bestRightSum = 0;
        
        // Iterate from the middle to the beginning.
        for (int i = mid - 1; i >= left; i--) {
            curr += numsArray[i];
            bestLeftSum = Math.max(bestLeftSum, curr);
        }
        
        // Reset curr and iterate from the middle to the end.
        curr = 0;
        for (int i = mid + 1; i <= right; i++) {
            curr += numsArray[i];
            bestRightSum = Math.max(bestRightSum, curr);
        }
        
        // The bestCombinedSum uses the middle element and the best
        // possible sum from each half.
        int bestCombinedSum = numsArray[mid] + bestLeftSum + bestRightSum;
        
        // Find the best subarray possible from both halves.
        int leftHalf = findBestSubarray(left, mid - 1);
        int rightHalf = findBestSubarray(mid + 1, right);
        
        // The largest of the 3 is the answer for any given input array.
        return Math.max(bestCombinedSum, Math.max(leftHalf, rightHalf));
    }
}
```

***

# **`[LeetCode] DP` [House Robber](https://leetcode.com/problems/house-robber/)** ❌

***

# **`[LeetCode] DP` [House Robber II](https://leetcode.com/problems/house-robber-ii/)** ❌

***

# **`[LeetCode] DP` [Paint House](https://leetcode.com/problems/paint-house/)** 📝

## First Approach, Brute force with a Recursive Tree ➜ <span class="text-red-300">Time Limit Exceeded</span>

```java
    class Solution {
        int[][] costs;
        public int minCost(int[][] costs) {
            this.costs = costs;
            return Math.min(paintCost(0 , 0) , Math.min(paintCost(0 , 1) , paintCost(0 , 2)));
        }
        
        public int paintCost(int house , int color){
            if(house < costs.length){
                int cost = costs[house][color];
                if(color == 0){
                    cost += Math.min(paintCost(house + 1 , 1) , paintCost(house + 1 , 2));
                }
                else if(color == 1){
                    cost += Math.min(paintCost(house + 1 , 0) , paintCost(house + 1 , 2));
                }
                else if(color == 2){
                    cost += Math.min(paintCost(house + 1 , 0) , paintCost(house + 1 , 1));
                }
                return cost;
            }
            else return 0;
            
        }
    }
```

## Second Approach, Memoization ➜ `24ms` <span class="text-green-300">Success</span>

```java
class Solution {
    int[][] costs;
    Map<String , Integer> memo;
    public int minCost(int[][] costs) {
        this.costs = costs;
        this.memo = new HashMap<>();
        
        return Math.min(paintCost(0 , 0) , Math.min(paintCost(0 , 1) , paintCost(0 , 2)));
    }
    
    public int paintCost(int house , int color){
        if(house < costs.length){
            String key = getKey(house , color);
            if(memo.containsKey(key)){
                return memo.get(key);
            }
            
            int cost = costs[house][color];
            if(color == 0){
                cost += Math.min(paintCost(house + 1 , 1) , paintCost(house + 1 , 2));
            }
            else if(color == 1){
                cost += Math.min(paintCost(house + 1 , 0) , paintCost(house + 1 , 2));
            }
            else if(color == 2){
                cost += Math.min(paintCost(house + 1 , 0) , paintCost(house + 1 , 1));
            }
            memo.put(key , cost);
            return cost;
        }
        else return 0;
        
    }
    
    public String getKey(int house , int color){
        return house + "-" + color;
    }
}
```

## Third Approach, Dynamic Programming ➜ `1ms` <span class="text-green-300">Success</span>

```java
class Solution {
    public int minCost(int[][] costs) {
        for(int i = costs.length - 2 ; i >= 0 ; i--){
            costs[i][0] += Math.min(costs[i + 1][1] , costs[i + 1][2]);
            costs[i][1] += Math.min(costs[i + 1][0] , costs[i + 1][2]);
            costs[i][2] += Math.min(costs[i + 1][0] , costs[i + 1][1]);
        }
        return Math.min(costs[0][0] , Math.min(costs[0][1] , costs[0][2]));
    }
}
```

***

# **`[LeetCode] DP` [Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)**

## Brute Force ➜ <span class="text-red-300">Time Limit Exceeded</span>

```java
class Solution {
    public int maxProfit(int[] prices) {
        int diff = Integer.MIN_VALUE;
        for(int i = 0 ; i < prices.length ; i++){
            for(int j = i ; j < prices.length ; j++){
                diff = Math.max(diff , prices[j] - prices[i]);
            }
        }
        return diff;
    }
}
```

## One Pass ➜ <span class="text-green-300">Success</span>

```java
class Solution {
    public int maxProfit(int[] prices) {
        int minPrice = Integer.MAX_VALUE;
        int maxProfit = 0;
        for(int i = 0 ; i < prices.length ; i++){
            minPrice = Math.min(prices[i] , minPrice);
            maxProfit = Math.max(prices[i] - minPrice , maxProfit);
        }
        return maxProfit;
    }
}
```

***

# **`[LeetCode] DP` [Paint House II](https://leetcode.com/problems/paint-house-ii/)** 진행중

![](../../../assets/images/books/../../../jdalma.github.io/assets/images/algorithm/2022y01m/paintHouse2.png)


```java
class Solution {
    int[][] memo , costs;
    int houseCnt , colorCnt;
    public int minCostII(int[][] costs) {
        this.costs = costs;
        this.houseCnt = costs.length;
        this.colorCnt = costs[0].length;
        int minCost = Integer.MAX_VALUE;
        
        // memo 배열 MAX_VALUE로 초기화 
        memo = new int[houseCnt][colorCnt];
        for(int i = 0 ; i < houseCnt ; i++) Arrays.fill(memo[i] , Integer.MAX_VALUE);
        
        for(int i = 0 ; i < colorCnt ; i++){
            // 배열[집][색깔] 재귀 호출
            minCost = Math.min(minCost , paintCost(0 , i));
        }
        
        return Arrays.stream(costs[0]).min().getAsInt();
    }
    
    public int paintCost(int houseNumber , int colorNumber){
        if(houseNumber == houseCnt - 1)
            return memo[houseNumber][colorNumber] = costs[houseNumber][colorNumber];
        else if(memo[houseNumber][colorNumber] != Integer.MAX_VALUE) 
            return memo[houseNumber][colorNumber];
        
        int minCost = Integer.MAX_VALUE;
        for(int otherColor = 0 ; otherColor < colorCnt ; otherColor++){
            if(otherColor == colorNumber) continue;
            
            int currentRemainingCost = paintCost(houseNumber + 1 , otherColor);
            minCost = Math.min(currentRemainingCost , minCost);
        }
        memo[houseNumber][colorNumber] = memo[houseNumber][colorNumber] + minCost;
        
        return memo[houseNumber][colorNumber];
    }
}
```

***

# **`[카카오 2021]` [합승 택시 요금](https://programmers.co.kr/learn/courses/30/lessons/72413)**

- [참고 링크](https://lovelyunsh.tistory.com/157)

## `Dijkstra`

```java
import java.util.*;

class Node implements Comparable<Node>{
    int vertex;
    int cost;
    public Node(int vertex , int cost){
        this.vertex = vertex;
        this.cost = cost;
    }

    @Override
    public int compareTo(Node o) {
        return this.cost - o.cost;
    }

    @Override
    public String toString() {
        return "Node{" +
                "vertex=" + vertex +
                ", cost=" + cost +
                '}';
    }
}

class Solution {
    private List<List<Node>> list = new ArrayList<>();
    private int n;
    public static void main(String[] args) {
        Solution test = new Solution();
        test.solution(6 , 4 , 6 , 2 , new int[][]{
                {4, 1, 10},
                {3, 5, 24},
                {5, 6, 2},
                {3, 1, 41},
                {5, 1, 24},
                {4, 6, 50},
                {2, 4, 66},
                {2, 3, 22},
                {1, 6, 25}
        });
    }

    public int solution(int n, int s, int a, int b, int[][] fares) {
        this.n = n;
        int answer = Integer.MAX_VALUE;
        for(int i = 0 ; i <= n ; i++) list.add(new ArrayList<>());
        for(int i = 0 ; i < fares.length ; i++){
            int node1 = fares[i][0];
            int node2 = fares[i][1];
            int cost = fares[i][2];
            list.get(node1).add(new Node(node2 , cost));
            list.get(node2).add(new Node(node1 , cost));
        }
        int[] costArr1 = new int[n + 1];
        int[] costArr2 = new int[n + 1];
        int[] costArr3 = new int[n + 1];
        dijkstra(costArr1 , a);
        dijkstra(costArr2 , b);
        dijkstra(costArr3 , s);
        Arrays.stream(costArr1).forEach(e -> System.out.print(e + " "));
        System.out.println();
        Arrays.stream(costArr2).forEach(e -> System.out.print(e + " "));
        System.out.println();
        Arrays.stream(costArr3).forEach(e -> System.out.print(e + " "));
        System.out.println();
        for(int i = 1; i <= n ; i ++) answer = Math.min(answer, costArr1[i] + costArr2[i] + costArr3[i]);
        return answer;
    }

    public void dijkstra(int[] costArr , int start){
        Arrays.fill(costArr , Integer.MAX_VALUE);
        costArr[start] = 0;
        PriorityQueue<Node> pq = new PriorityQueue<Node>();
        pq.offer(new Node(start , 0));
        while(!pq.isEmpty()){
            Node now = pq.poll();
            int nowVertex = now.vertex;
            int nowCost = now.cost;
            for(Node moveNode : list.get(nowVertex)){
                int sumCost = nowCost + moveNode.cost;
                if(costArr[moveNode.vertex] < sumCost) continue;
                costArr[moveNode.vertex] = sumCost;
                pq.offer(new Node(moveNode.vertex, sumCost));
            }
        }
    }
}

```

## `Floyd Warshall`

```java
import java.util.*;


class Solution {
    public static void main(String[] args) {
        Solution test = new Solution();
        test.solution(6 , 4 , 6 , 2 , new int[][]{
                {4, 1, 10},
                {3, 5, 24},
                {5, 6, 2},
                {3, 1, 41},
                {5, 1, 24},
                {4, 6, 50},
                {2, 4, 66},
                {2, 3, 22},
                {1, 6, 25}
        });
    }

    public int solution(int n, int s, int a, int b, int[][] fares) {
        int[][] node = new int[n + 1][n + 1];
        for(int i = 1; i < n + 1; i++) {
            for(int j = 1; j < n + 1; j++) {
                node[i][j] = Integer.MAX_VALUE;
            }
            node[i][i] = 0;
        }

        for(int i = 0; i < fares.length; i++) {
            node[fares[i][0]][fares[i][1]] = fares[i][2];
            node[fares[i][1]][fares[i][0]] = fares[i][2];
        }

        for(int k = 1; k < n + 1; k++) {
            for(int i = 1; i < n + 1; i++) {
                for(int j = 1; j < n + 1; j++) {
                    if(node[i][j] > node[i][k] + node[k][j]) {
                        node[i][j] = node[i][k] + node[k][j];
                    }
                }
            }
        }

        int min = Integer.MAX_VALUE;
        for(int i = 1; i < n + 1; i++) {
            min = Math.min(min, node[s][i] + node[i][a] + node[i][b]);
        }
        return min;
    }
}
```

***

# **`[백준] Dijkstra` [녹색 옷 입은 애가 젤다지?](https://www.acmicpc.net/problem/4485)**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

class Position implements Comparable<Position>{
    int x , y , cost;
    public Position(int x, int y, int cost) {
        this.x = x;
        this.y = y;
        this.cost = cost;
    }

    @Override
    public int compareTo(Position o) {
        return this.cost - o.cost;
    }
}

class Main {
    static int size;
    static int[][] map , memo;
    static int[] moveX = {-1 , 0 , 1 , 0};
    static int[] moveY = {0 , 1 , 0 , -1};
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringBuilder result = new StringBuilder();
        int count = 0;
        while(true){
            size = Integer.parseInt(br.readLine());
            if(size == 0) break;
            map = new int[size][size];
            memo = new int[size][size];
            for(int i = 0 ; i < size ; i++){
                String[] line = br.readLine().split(" ");
                for(int j = 0 ; j < line.length ; j++){
                    map[i][j] = Integer.parseInt(line[j]);
                    memo[i][j] = Integer.MAX_VALUE;
                }
            }
            result.append("Problem ").append(++count).append(": ").append(dijkstra()).append("\n");
        }
        System.out.println(result.toString());
    }

    public static int dijkstra(){
    	memo[0][0] = map[0][0];
        PriorityQueue<Position> pq = new PriorityQueue<>();
        pq.offer(new Position(0 , 0 , map[0][0]));
        while(!pq.isEmpty()){
            Position now = pq.poll();
            for(int i = 0 ; i < 4 ; i++){
                int moveXpos = now.x + moveX[i];
                int moveYpos = now.y + moveY[i];
                if(moveXpos >= 0 && moveXpos < size && moveYpos >= 0 && moveYpos < size){
                	if(memo[moveXpos][moveYpos] > now.cost + map[moveXpos][moveYpos]) {
                		memo[moveXpos][moveYpos] = now.cost + map[moveXpos][moveYpos];
                		pq.offer(new Position(moveXpos , moveYpos , now.cost + map[moveXpos][moveYpos]));	
                	}
                }
            }
        }
        return memo[size - 1][size - 1];
    }
}
```

***

# **`[백준] Dijkstra` [파티](https://www.acmicpc.net/problem/1238)**

## <span class="text-red-300">시간초과</span>

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

class Edge implements Comparable<Edge>{
    int city;
    int cost;
    public Edge(int city, int cost) {
        super();
        this.city = city;
        this.cost = cost;
    }
    @Override
    public int compareTo(Edge o) {
        return o.cost - this.cost;
    }

    @Override
    public String toString() {
        return "Edge{" +
                "city=" + city +
                ", cost=" + cost +
                '}';
    }
}

class Main {
    static List<List<Edge>> list = new ArrayList<>();
    static int city , edge, destination;
    static int[][] memo;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        city = Integer.parseInt(st.nextToken());
        edge = Integer.parseInt(st.nextToken());
        destination = Integer.parseInt(st.nextToken());
        memo = new int[city + 1][city + 1];
        for(int i = 0 ; i <= city ; i++) {
            Arrays.fill(memo[i] , Integer.MAX_VALUE);
            list.add(new ArrayList<Edge>());
        }
        for(int i = 0 ; i < edge ; i++) {
            st = new StringTokenizer(br.readLine());
            int node1 = Integer.parseInt(st.nextToken());
            int node2 = Integer.parseInt(st.nextToken());
            int cost = Integer.parseInt(st.nextToken());
            list.get(node1).add(new Edge(node2 , cost));
        }

        // 모든 도시
        for(int i = 1 ; i <= city ; i++){
            dijkstra(i);
        }

        int maxCostToGoToCome = Integer.MIN_VALUE;

        for(int i = 1 ; i <= city ; i++){
            if(memo[i][destination] != Integer.MAX_VALUE && memo[destination][i] != Integer.MAX_VALUE){
                maxCostToGoToCome = Math.max(maxCostToGoToCome , memo[i][destination] + memo[destination][i]);
            }
        }

        System.out.println(maxCostToGoToCome);
    }

    public static void dijkstra(int startCity){
        memo[startCity][startCity] = 0;
        PriorityQueue<Edge> pq = new PriorityQueue<>();
        pq.offer(new Edge(startCity , 0));

        while(!pq.isEmpty()){
            Edge now = pq.poll();
            int city = now.city;
            int cost = now.cost;
            for(Edge nearEdge : list.get(city)){
                int sumCost = cost + nearEdge.cost;
                if(memo[startCity][nearEdge.city] > sumCost){
                    memo[startCity][nearEdge.city] = sumCost;
                    pq.offer(new Edge(nearEdge.city , sumCost));
                }
            }
        }
    }
}
```

## 📌 **간선 뒤집기**

- `단일 출발(single-source) 최단경로` 와 `단일 도착(single-destination) 최단경로` 구분하는 문제

- `int[] result1 = dijkstra(destination , list);` ➜ `단일 출발(single-source) 최단경로`
- `int[] result2 = dijkstra(destination , reverseList);` ➜ `단일 도착(single-destination) 최단경로`

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

class Edge implements Comparable<Edge>{
    int city;
    int cost;
    public Edge(int city, int cost) {
        super();
        this.city = city;
        this.cost = cost;
    }
    @Override
    public int compareTo(Edge o) {
        return o.cost - this.cost;
    }

    @Override
    public String toString() {
        return "Edge{" +
                "city=" + city +
                ", cost=" + cost +
                '}';
    }
}

class Main {
    static int city , edge, destination;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        List<List<Edge>> list = new ArrayList<>();
        List<List<Edge>> reverseList = new ArrayList<>();        
        city = Integer.parseInt(st.nextToken());
        edge = Integer.parseInt(st.nextToken());
        destination = Integer.parseInt(st.nextToken());
        for(int i = 0 ; i <= city ; i++) {
            list.add(new ArrayList<Edge>());
            reverseList.add(new ArrayList<Edge>());
        }
        for(int i = 0 ; i < edge ; i++) {
            st = new StringTokenizer(br.readLine());
            int node1 = Integer.parseInt(st.nextToken());
            int node2 = Integer.parseInt(st.nextToken());
            int cost = Integer.parseInt(st.nextToken());
            list.get(node1).add(new Edge(node2 , cost));
            reverseList.get(node2).add(new Edge(node1 , cost));
        }

        // 모든 도시
        int[] result1 = dijkstra(destination , list);
        int[] result2 = dijkstra(destination , reverseList);

        int maxCostToGoToCome = Integer.MIN_VALUE;

        for(int i = 1 ; i <= city ; i++){
            if(result1[i] != Integer.MAX_VALUE && result2[i] != Integer.MAX_VALUE){
                maxCostToGoToCome = Math.max(maxCostToGoToCome , result1[i]+ result2[i]);
            }
        }

        System.out.println(maxCostToGoToCome);
    }

    public static int[] dijkstra(int startCity ,  List<List<Edge>> list){
        int[] costArr = new int[city + 1];
        Arrays.fill(costArr, Integer.MAX_VALUE);
        PriorityQueue<Edge> pq = new PriorityQueue<>();
        pq.offer(new Edge(startCity , 0));
        costArr[startCity] = 0;

        while(!pq.isEmpty()){
            Edge now = pq.poll();
            int city = now.city;
            int cost = now.cost;
            for(Edge nearEdge : list.get(city)){
                int sumCost = cost + nearEdge.cost;
                if(costArr[nearEdge.city] > sumCost){
                	costArr[nearEdge.city] = sumCost;
                    pq.offer(new Edge(nearEdge.city , sumCost));
                }
            }
        }
        return costArr;
    }
}
```

***

# **`[백준] Dijkstra` [인간 대포](https://www.acmicpc.net/problem/10473)**

## 그래프를 직접 만드는 것이 문제 📌
- `x` , `y` 의 위치를 입력받아 해당 `Position`간의 거리를 계산하여 그래프를 형성

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

class Position{
    float x;
    float y;
    public Position(String x, String y) {
        this.x = Float.parseFloat(x);
        this.y = Float.parseFloat(y);
    }
}

class Edge implements Comparable<Edge>{
    int node;
    float wasteTime;
    public Edge(int node, float wasteTime) {
        this.node = node;
        this.wasteTime = wasteTime;
    }
    @Override
    public int compareTo(Edge o) {
        return (int) (this.wasteTime - o.wasteTime);
    }

    @Override
    public String toString() {
        return "Edge{" +
                "node=" + node +
                ", wasteTime=" + wasteTime +
                '}';
    }
}

class Main {
    static List<Position> positions = new ArrayList<Position>(102);
    static List<List<Edge>> edges = new ArrayList<>();
    static float[] timeArr;
    static Position start , end;
    static final float WALK = 5f;  // 5 m/s
    static final float FLY_WASTE_TIME = 2f; // 2초
    static final float FLY = 50f; // 대포에 올라타고 발사하고 착륙까지 2초 , 50m
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] line = br.readLine().split(" ");
        start = new Position(line[0] , line[1]);
        line = br.readLine().split(" ");
        end = new Position(line[0], line[1]);

        int count = Integer.parseInt(br.readLine());

        // 시간 배열
        timeArr = new float[count + 2];

        // 시작점
        edges.add(new ArrayList<Edge>());
        timeArr[0] = Float.MAX_VALUE;
        positions.add(start);

        // 대포
        for(int i = 0 ; i < count ; i++) {
            line = br.readLine().split(" ");
            edges.add(new ArrayList<Edge>());
            timeArr[i + 1] = Float.MAX_VALUE;
            positions.add(new Position(line[0] , line[1]));
        }

        //끝점
        edges.add(new ArrayList<Edge>());
        timeArr[count + 1] = Float.MAX_VALUE;
        positions.add(end);

        // 그래프를 어떻게 형성할지??
        // 1. 시작점에서 각 대포와 끝점 까지 걸어가는 가중치
        for(int i = 1 ; i < count + 2 ; i++){
            edges.get(0).add(new Edge(i , (float) getDistance(positions.get(0) , positions.get(i)) / WALK));
        }
        // 2. 각 대포끼리와 끝점 까지의 가중치
        for(int i = 1 ; i < count + 2 ; i++){
            for(int j = 1 ; j < count + 2 ; j++){
                Position startPosition = positions.get(i);
                Position endPosition = positions.get(j);
                float distance = getDistance(startPosition , endPosition);
                float walk = distance / WALK;
                float fly = Math.abs(distance - FLY) / WALK + FLY_WASTE_TIME;
                float wasteTime = Math.min(walk , fly);
                edges.get(i).add(new Edge(j , wasteTime));
            }
        }

        dijkstra(0);
        System.out.println(timeArr[count + 1]);
    }

    public static void dijkstra(int start) {
        PriorityQueue<Edge> pq = new PriorityQueue<>();
        pq.offer(new Edge(start , 0));
        while(!pq.isEmpty()){
            Edge now = pq.poll();
            int nowNode = now.node;
            float nowWasteTime = now.wasteTime;
            for(Edge nearEdge : edges.get(nowNode)){
                float sumWasteTime = nearEdge.wasteTime + nowWasteTime;
                if(timeArr[nearEdge.node] > sumWasteTime){
                    timeArr[nearEdge.node] = sumWasteTime;
                    pq.offer(new Edge(nearEdge.node , sumWasteTime));
                }
            }
        }
    }

    public static float getDistance(Position obj1 , Position obj2) {
        float diffX = obj1.x - obj2.x;
        float diffY = obj1.y - obj2.y;
        return (float) Math.sqrt(Math.pow(diffX, 2) + Math.pow(diffY, 2));
    }
}
```

***
