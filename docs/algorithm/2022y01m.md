---
layout: default
title: 2022년 1월
nav_order: 9
parent: 알고리즘
---
## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

***

# **`[백준] 부분 합` [부분 합](https://www.acmicpc.net/problem/1806) 진행 중**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;


class Main {

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int size = Integer.parseInt(st.nextToken());
        long target = Long.parseLong(st.nextToken());
        long sum = 0L;
        int result = 0;
        Map<Long , Long> occurrenceMap = new HashMap<Long , Long>();
        st = new StringTokenizer(br.readLine());
        for(int i = 0 ; i < size ; i++) {
        	int value = Integer.parseInt(st.nextToken());
        	sum += value;

        	if(sum == target) result++;
        	result += occurrenceMap.getOrDefault(sum - target, 0L);

        	occurrenceMap.put(sum , occurrenceMap.getOrDefault(sum , 0L) + 1);
//        	System.out.println(sum - target + " -> " + occurrenceMap.getOrDefault(sum - target, 0L) + " | " + occurrenceMap);
        }
        System.out.println(result);
    }

}
```


# **`[LeetCode] DP` [Min Cost Climbing Stairs](https://leetcode.com/problems/min-cost-climbing-stairs/)**

## Bottom-Up (Tabulation)

```java
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int[] min = new int[cost.length + 1];
        
        for(int i = 2 ; i < min.length ; i++){
            int oneStep = min[i - 2] + cost[i - 2];
            int twoStep = min[i - 1] + cost[i - 1];
            min[i] = Math.min(oneStep , twoStep);
        }
        
        return min[cost.length];
    }
}
```

## 👍 Bottom-Up (Constant Space)

```java
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int oneStep = 0;
        int twoStep = 0;
        for(int i = 2 ; i < cost.length + 1; i++){
            int tmp = oneStep;
            oneStep = Math.min(oneStep + cost[i - 1], twoStep + cost[i - 2]);
            twoStep = tmp;            
        }
        return oneStep;
    }
}
```

## Top-Down (Recursion + Memoization)

```java
class Solution {
    int[] memo;
    public int minCostClimbingStairs(int[] cost) {
        memo = new int[cost.length + 1];
        return minCost(cost , cost.length);
    }
    public int minCost(int[] cost , int target){
        if(target <= 1) return 0;
        else if(memo[target] != 0) return memo[target];
        
        int downOne = cost[target - 1] + minCost(cost , target - 1);
        int downTwo = cost[target - 2] + minCost(cost , target - 2);
        return memo[target] = Math.min(downOne , downTwo);
    }
}
```