---
layout: default
title: 2022ÎÖÑ 1Ïõî
nav_order: 9
parent: ÏïåÍ≥†Î¶¨Ï¶ò
---
## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---


# **`[LeetCode] Ïù¥Î∂Ñ Í≤ÄÏÉâ` [Binary Search](https://leetcode.com/problems/binary-search/)**

```java
class Solution {
    public int search(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while(left <= right){
            int middle = (left + right) / 2;
            if(nums[middle] == target){
                return middle;
            }
            else if(nums[middle] < target) left = middle + 1;
            else right = middle - 1;
        }
        
        return -1;
    }
}
```

***

# **`[LeetCode] Ïù¥Î∂Ñ Í≤ÄÏÉâ` [Guess Number Higher or Lower](https://leetcode.com/problems/guess-number-higher-or-lower/)**

## Solve - Binary Search

```java
/** 
 * Forward declaration of guess API.
 * @param  num   your guess
 * @return 	     -1 if num is lower than the guess number
 *			      1 if num is higher than the guess number
 *               otherwise return 0
 * int guess(int num);
 */

public class Solution extends GuessGame {
    public int guessNumber(int n) {
        int left = 1;
        int right = n;
        while(left <= right){
            int middle = left + (right - left) / 2;
            int guess = guess(middle);
            if(guess == 0) return middle;
            else if(guess == 1) left = middle + 1;
            else right = middle - 1;
        }
        
        return -1;
    }
}
```

## Solution - Ternary Search

```java
/* The guess API is defined in the parent class GuessGame.
   @param num, your guess
   @return -1 if my number is lower, 1 if my number is higher, otherwise return 0
      int guess(int num); */

public class Solution extends GuessGame {
    public int guessNumber(int n) {
        int low = 1;
        int high = n;
        while (low <= high) {
            int mid1 = low + (high - low) / 3;
            int mid2 = high - (high - low) / 3;
            int res1 = guess(mid1);
            int res2 = guess(mid2);
            if (res1 == 0) return mid1;
            if (res2 == 0) return mid2;
            else if (res1 < 0) high = mid1 - 1;
            else if (res2 > 0) low = mid2 + 1;
            else {
                low = mid1 + 1;
                high = mid2 - 1;
            }
        }
        return -1;
    }
}
```


***

# **`[LeetCode] DP` [Climbing Stairs](https://leetcode.com/problems/climbing-stairs/)**

## Solve

```java
class Solution {
    public int climbStairs(int n) {
        if(n == 1) return 1;
        
        int value1 = 1;
        int value2 = 1;
        for(int i = 2 ; i <= n ; i++){
            int tmp = value1 + value2;
            value1 = value2;
            value2 = tmp;
        }
        return value2;
    }
}
```

## Solution

```java
public class Solution {
    public int climbStairs(int n) {
        if (n == 1) {
            return 1;
        }
        int[] dp = new int[n + 1];
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
}
```

***

# üî• **`[LeetCode] DP` [Min Cost Climbing Stairs](https://leetcode.com/problems/min-cost-climbing-stairs/)**

## Bottom-Up (Tabulation)

```java
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int[] min = new int[cost.length + 1];
        
        for(int i = 2 ; i < min.length ; i++){
            int oneStep = min[i - 2] + cost[i - 2];
            int twoStep = min[i - 1] + cost[i - 1];
            min[i] = Math.min(oneStep , twoStep);
        }
        
        return min[cost.length];
    }
}
```

## üëç Bottom-Up (Constant Space)

```java
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int oneStep = 0;
        int twoStep = 0;
        for(int i = 2 ; i < cost.length + 1; i++){
            int tmp = oneStep;
            oneStep = Math.min(oneStep + cost[i - 1], twoStep + cost[i - 2]);
            twoStep = tmp;            
        }
        return oneStep;
    }
}
```

## Top-Down (Recursion + Memoization)

```java
class Solution {
    int[] memo;
    public int minCostClimbingStairs(int[] cost) {
        memo = new int[cost.length + 1];
        return minCost(cost , cost.length);
    }
    public int minCost(int[] cost , int target){
        if(target <= 1) return 0;
        else if(memo[target] != 0) return memo[target];
        
        int downOne = cost[target - 1] + minCost(cost , target - 1);
        int downTwo = cost[target - 2] + minCost(cost , target - 2);
        return memo[target] = Math.min(downOne , downTwo);
    }
}
```

***

# üî• **`[LeetCode] DP - Kadane's Algorithm` [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/)**

## Solve

```java
class Solution {
    public int maxSubArray(int[] nums) {
        if(nums.length == 1) return nums[0];
        
        int result = nums[0];
        for(int i = 1 ; i < nums.length ; i++){
            nums[i] = Math.max(nums[i] , nums[i] + nums[i - 1]);
            result = Math.max(result , nums[i]);
        }
        return result;
    }
}
```

## Solution - Divide and Conquer (Advanced)

```java
class Solution {
    private int[] numsArray;
    
    public int maxSubArray(int[] nums) {
        numsArray = nums;
        
        // Our helper function is designed to solve this problem for
        // any array - so just call it using the entire input!
        return findBestSubarray(0, numsArray.length - 1);
    }
    
    private int findBestSubarray(int left, int right) {
        // Base case - empty array.
        if (left > right) {
            return Integer.MIN_VALUE;
        }
        
        int mid = Math.floorDiv(left + right, 2);
        int curr = 0;
        int bestLeftSum = 0;
        int bestRightSum = 0;
        
        // Iterate from the middle to the beginning.
        for (int i = mid - 1; i >= left; i--) {
            curr += numsArray[i];
            bestLeftSum = Math.max(bestLeftSum, curr);
        }
        
        // Reset curr and iterate from the middle to the end.
        curr = 0;
        for (int i = mid + 1; i <= right; i++) {
            curr += numsArray[i];
            bestRightSum = Math.max(bestRightSum, curr);
        }
        
        // The bestCombinedSum uses the middle element and the best
        // possible sum from each half.
        int bestCombinedSum = numsArray[mid] + bestLeftSum + bestRightSum;
        
        // Find the best subarray possible from both halves.
        int leftHalf = findBestSubarray(left, mid - 1);
        int rightHalf = findBestSubarray(mid + 1, right);
        
        // The largest of the 3 is the answer for any given input array.
        return Math.max(bestCombinedSum, Math.max(leftHalf, rightHalf));
    }
}
```

***

# **`[LeetCode] DP` [House Robber](https://leetcode.com/problems/house-robber/)** ‚ùå

***

# **`[LeetCode] DP` [House Robber II](https://leetcode.com/problems/house-robber-ii/)** ‚ùå

***

# **`[LeetCode] DP` [Paint House](https://leetcode.com/problems/paint-house/)** üìù

## First Approach, Brute force with a Recursive Tree ‚ûú <span class="text-red-300">Time Limit Exceeded</span>

```java
    class Solution {
        int[][] costs;
        public int minCost(int[][] costs) {
            this.costs = costs;
            return Math.min(paintCost(0 , 0) , Math.min(paintCost(0 , 1) , paintCost(0 , 2)));
        }
        
        public int paintCost(int house , int color){
            if(house < costs.length){
                int cost = costs[house][color];
                if(color == 0){
                    cost += Math.min(paintCost(house + 1 , 1) , paintCost(house + 1 , 2));
                }
                else if(color == 1){
                    cost += Math.min(paintCost(house + 1 , 0) , paintCost(house + 1 , 2));
                }
                else if(color == 2){
                    cost += Math.min(paintCost(house + 1 , 0) , paintCost(house + 1 , 1));
                }
                return cost;
            }
            else return 0;
            
        }
    }
```

## Second Approach, Memoization ‚ûú `24ms` <span class="text-green-300">Success</span>

```java
class Solution {
    int[][] costs;
    Map<String , Integer> memo;
    public int minCost(int[][] costs) {
        this.costs = costs;
        this.memo = new HashMap<>();
        
        return Math.min(paintCost(0 , 0) , Math.min(paintCost(0 , 1) , paintCost(0 , 2)));
    }
    
    public int paintCost(int house , int color){
        if(house < costs.length){
            String key = getKey(house , color);
            if(memo.containsKey(key)){
                return memo.get(key);
            }
            
            int cost = costs[house][color];
            if(color == 0){
                cost += Math.min(paintCost(house + 1 , 1) , paintCost(house + 1 , 2));
            }
            else if(color == 1){
                cost += Math.min(paintCost(house + 1 , 0) , paintCost(house + 1 , 2));
            }
            else if(color == 2){
                cost += Math.min(paintCost(house + 1 , 0) , paintCost(house + 1 , 1));
            }
            memo.put(key , cost);
            return cost;
        }
        else return 0;
        
    }
    
    public String getKey(int house , int color){
        return house + "-" + color;
    }
}
```

## Third Approach, Dynamic Programming ‚ûú `1ms` <span class="text-green-300">Success</span>

```java
class Solution {
    public int minCost(int[][] costs) {
        for(int i = costs.length - 2 ; i >= 0 ; i--){
            costs[i][0] += Math.min(costs[i + 1][1] , costs[i + 1][2]);
            costs[i][1] += Math.min(costs[i + 1][0] , costs[i + 1][2]);
            costs[i][2] += Math.min(costs[i + 1][0] , costs[i + 1][1]);
        }
        return Math.min(costs[0][0] , Math.min(costs[0][1] , costs[0][2]));
    }
}
```

***

# **`[LeetCode] DP` [Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)**

## Brute Force ‚ûú <span class="text-red-300">Time Limit Exceeded</span>

```java
class Solution {
    public int maxProfit(int[] prices) {
        int diff = Integer.MIN_VALUE;
        for(int i = 0 ; i < prices.length ; i++){
            for(int j = i ; j < prices.length ; j++){
                diff = Math.max(diff , prices[j] - prices[i]);
            }
        }
        return diff;
    }
}
```

## One Pass ‚ûú <span class="text-green-300">Success</span>

```java
class Solution {
    public int maxProfit(int[] prices) {
        int minPrice = Integer.MAX_VALUE;
        int maxProfit = 0;
        for(int i = 0 ; i < prices.length ; i++){
            minPrice = Math.min(prices[i] , minPrice);
            maxProfit = Math.max(prices[i] - minPrice , maxProfit);
        }
        return maxProfit;
    }
}
```

***

# **`[LeetCode] DP` [Paint House II](https://leetcode.com/problems/paint-house-ii/)** ÏßÑÌñâÏ§ë

![](../../../assets/images/books/../../../jeongcode.github.io/assets/images/algorithm/2022y01m/paintHouse2.png)


```java
class Solution {
    int[][] memo , costs;
    int houseCnt , colorCnt;
    public int minCostII(int[][] costs) {
        this.costs = costs;
        this.houseCnt = costs.length;
        this.colorCnt = costs[0].length;
        int minCost = Integer.MAX_VALUE;
        
        // memo Î∞∞Ïó¥ MAX_VALUEÎ°ú Ï¥àÍ∏∞Ìôî 
        memo = new int[houseCnt][colorCnt];
        for(int i = 0 ; i < houseCnt ; i++) Arrays.fill(memo[i] , Integer.MAX_VALUE);
        
        for(int i = 0 ; i < colorCnt ; i++){
            // Î∞∞Ïó¥[Ïßë][ÏÉâÍπî] Ïû¨Í∑Ä Ìò∏Ï∂ú
            minCost = Math.min(minCost , paintCost(0 , i));
        }
        
        return Arrays.stream(costs[0]).min().getAsInt();
    }
    
    public int paintCost(int houseNumber , int colorNumber){
        if(houseNumber == houseCnt - 1)
            return memo[houseNumber][colorNumber] = costs[houseNumber][colorNumber];
        else if(memo[houseNumber][colorNumber] != Integer.MAX_VALUE) 
            return memo[houseNumber][colorNumber];
        
        int minCost = Integer.MAX_VALUE;
        for(int otherColor = 0 ; otherColor < colorCnt ; otherColor++){
            if(otherColor == colorNumber) continue;
            
            int currentRemainingCost = paintCost(houseNumber + 1 , otherColor);
            minCost = Math.min(currentRemainingCost , minCost);
        }
        memo[houseNumber][colorNumber] = memo[houseNumber][colorNumber] + minCost;
        
        return memo[houseNumber][colorNumber];
    }
}
```

***

# **`[Ïπ¥Ïπ¥Ïò§ 2021]` [Ìï©Ïäπ ÌÉùÏãú ÏöîÍ∏à](https://programmers.co.kr/learn/courses/30/lessons/72413)**

- [Ï∞∏Í≥† ÎßÅÌÅ¨](https://lovelyunsh.tistory.com/157)

## `Îã§ÏùµÏä§Ìä∏Îùº`

```java
import java.util.*;

class Node implements Comparable<Node>{
    int vertex;
    int cost;
    public Node(int vertex , int cost){
        this.vertex = vertex;
        this.cost = cost;
    }

    @Override
    public int compareTo(Node o) {
        return this.cost - o.cost;
    }

    @Override
    public String toString() {
        return "Node{" +
                "vertex=" + vertex +
                ", cost=" + cost +
                '}';
    }
}

class Solution {
    private List<List<Node>> list = new ArrayList<>();
    private int n;
    public static void main(String[] args) {
        Solution test = new Solution();
        test.solution(6 , 4 , 6 , 2 , new int[][]{
                {4, 1, 10},
                {3, 5, 24},
                {5, 6, 2},
                {3, 1, 41},
                {5, 1, 24},
                {4, 6, 50},
                {2, 4, 66},
                {2, 3, 22},
                {1, 6, 25}
        });
    }

    public int solution(int n, int s, int a, int b, int[][] fares) {
        this.n = n;
        int answer = Integer.MAX_VALUE;
        for(int i = 0 ; i <= n ; i++) list.add(new ArrayList<>());
        for(int i = 0 ; i < fares.length ; i++){
            int node1 = fares[i][0];
            int node2 = fares[i][1];
            int cost = fares[i][2];
            list.get(node1).add(new Node(node2 , cost));
            list.get(node2).add(new Node(node1 , cost));
        }
        int[] costArr1 = new int[n + 1];
        int[] costArr2 = new int[n + 1];
        int[] costArr3 = new int[n + 1];
        dijkstra(costArr1 , a);
        dijkstra(costArr2 , b);
        dijkstra(costArr3 , s);
        Arrays.stream(costArr1).forEach(e -> System.out.print(e + " "));
        System.out.println();
        Arrays.stream(costArr2).forEach(e -> System.out.print(e + " "));
        System.out.println();
        Arrays.stream(costArr3).forEach(e -> System.out.print(e + " "));
        System.out.println();
        for(int i = 1; i <= n ; i ++) answer = Math.min(answer, costArr1[i] + costArr2[i] + costArr3[i]);
        return answer;
    }

    public void dijkstra(int[] costArr , int start){
        Arrays.fill(costArr , Integer.MAX_VALUE);
        costArr[start] = 0;
        PriorityQueue<Node> pq = new PriorityQueue<Node>();
        pq.offer(new Node(start , 0));
        while(!pq.isEmpty()){
            Node now = pq.poll();
            int nowVertex = now.vertex;
            int nowCost = now.cost;
            for(Node moveNode : list.get(nowVertex)){
                int sumCost = nowCost + moveNode.cost;
                if(costArr[moveNode.vertex] < sumCost) continue;
                costArr[moveNode.vertex] = sumCost;
                pq.offer(new Node(moveNode.vertex, sumCost));
            }
        }
    }
}

```

## `ÌîåÎ°úÏù¥Îìú ÏôÄÏÉ¨`

```java
import java.util.*;


class Solution {
    public static void main(String[] args) {
        Solution test = new Solution();
        test.solution(6 , 4 , 6 , 2 , new int[][]{
                {4, 1, 10},
                {3, 5, 24},
                {5, 6, 2},
                {3, 1, 41},
                {5, 1, 24},
                {4, 6, 50},
                {2, 4, 66},
                {2, 3, 22},
                {1, 6, 25}
        });
    }

    public int solution(int n, int s, int a, int b, int[][] fares) {
        int[][] node = new int[n + 1][n + 1];
        for(int i = 1; i < n + 1; i++) {
            for(int j = 1; j < n + 1; j++) {
                node[i][j] = Integer.MAX_VALUE;
            }
            node[i][i] = 0;
        }

        for(int i = 0; i < fares.length; i++) {
            node[fares[i][0]][fares[i][1]] = fares[i][2];
            node[fares[i][1]][fares[i][0]] = fares[i][2];
        }

        for(int k = 1; k < n + 1; k++) {
            for(int i = 1; i < n + 1; i++) {
                for(int j = 1; j < n + 1; j++) {
                    if(node[i][j] > node[i][k] + node[k][j]) {
                        node[i][j] = node[i][k] + node[k][j];
                    }
                }
            }
        }

        int min = Integer.MAX_VALUE;
        for(int i = 1; i < n + 1; i++) {
            min = Math.min(min, node[s][i] + node[i][a] + node[i][b]);
        }
        return min;
    }
}
```

***

# **`[Î∞±Ï§Ä] Îã§ÏùµÏä§Ìä∏Îùº` [ÎÖπÏÉâ Ïò∑ ÏûÖÏùÄ Ïï†Í∞Ä Ï†§Îã§ÏßÄ?](https://www.acmicpc.net/problem/4485)**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

class Position implements Comparable<Position>{
    int x , y , cost;
    public Position(int x, int y, int cost) {
        this.x = x;
        this.y = y;
        this.cost = cost;
    }

    @Override
    public int compareTo(Position o) {
        return this.cost - o.cost;
    }
}

class Main {
    static int size;
    static int[][] map , memo;
    static int[] moveX = {-1 , 0 , 1 , 0};
    static int[] moveY = {0 , 1 , 0 , -1};
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringBuilder result = new StringBuilder();
        int count = 0;
        while(true){
            size = Integer.parseInt(br.readLine());
            if(size == 0) break;
            map = new int[size][size];
            memo = new int[size][size];
            for(int i = 0 ; i < size ; i++){
                String[] line = br.readLine().split(" ");
                for(int j = 0 ; j < line.length ; j++){
                    map[i][j] = Integer.parseInt(line[j]);
                    memo[i][j] = Integer.MAX_VALUE;
                }
            }
            result.append("Problem ").append(++count).append(": ").append(dijkstra()).append("\n");
        }
        System.out.println(result.toString());
    }

    public static int dijkstra(){
    	memo[0][0] = map[0][0];
        PriorityQueue<Position> pq = new PriorityQueue<>();
        pq.offer(new Position(0 , 0 , map[0][0]));
        while(!pq.isEmpty()){
            Position now = pq.poll();
            for(int i = 0 ; i < 4 ; i++){
                int moveXpos = now.x + moveX[i];
                int moveYpos = now.y + moveY[i];
                if(moveXpos >= 0 && moveXpos < size && moveYpos >= 0 && moveYpos < size){
                	if(memo[moveXpos][moveYpos] > now.cost + map[moveXpos][moveYpos]) {
                		memo[moveXpos][moveYpos] = now.cost + map[moveXpos][moveYpos];
                		pq.offer(new Position(moveXpos , moveYpos , now.cost + map[moveXpos][moveYpos]));	
                	}
                }
            }
        }
        return memo[size - 1][size - 1];
    }
}
```

***

# **`[Î∞±Ï§Ä] Îã§ÏùµÏä§Ìä∏Îùº` [ÌååÌã∞](https://www.acmicpc.net/problem/1238)**

## <span class="text-red-300">ÏãúÍ∞ÑÏ¥àÍ≥º</span>

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

class Edge implements Comparable<Edge>{
    int city;
    int cost;
    public Edge(int city, int cost) {
        super();
        this.city = city;
        this.cost = cost;
    }
    @Override
    public int compareTo(Edge o) {
        return o.cost - this.cost;
    }

    @Override
    public String toString() {
        return "Edge{" +
                "city=" + city +
                ", cost=" + cost +
                '}';
    }
}

class Main {
    static List<List<Edge>> list = new ArrayList<>();
    static int city , edge, destination;
    static int[][] memo;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        city = Integer.parseInt(st.nextToken());
        edge = Integer.parseInt(st.nextToken());
        destination = Integer.parseInt(st.nextToken());
        memo = new int[city + 1][city + 1];
        for(int i = 0 ; i <= city ; i++) {
            Arrays.fill(memo[i] , Integer.MAX_VALUE);
            list.add(new ArrayList<Edge>());
        }
        for(int i = 0 ; i < edge ; i++) {
            st = new StringTokenizer(br.readLine());
            int node1 = Integer.parseInt(st.nextToken());
            int node2 = Integer.parseInt(st.nextToken());
            int cost = Integer.parseInt(st.nextToken());
            list.get(node1).add(new Edge(node2 , cost));
        }

        // Î™®Îì† ÎèÑÏãú
        for(int i = 1 ; i <= city ; i++){
            dijkstra(i);
        }

        int maxCostToGoToCome = Integer.MIN_VALUE;

        for(int i = 1 ; i <= city ; i++){
            if(memo[i][destination] != Integer.MAX_VALUE && memo[destination][i] != Integer.MAX_VALUE){
                maxCostToGoToCome = Math.max(maxCostToGoToCome , memo[i][destination] + memo[destination][i]);
            }
        }

        System.out.println(maxCostToGoToCome);
    }

    public static void dijkstra(int startCity){
        memo[startCity][startCity] = 0;
        PriorityQueue<Edge> pq = new PriorityQueue<>();
        pq.offer(new Edge(startCity , 0));

        while(!pq.isEmpty()){
            Edge now = pq.poll();
            int city = now.city;
            int cost = now.cost;
            for(Edge nearEdge : list.get(city)){
                int sumCost = cost + nearEdge.cost;
                if(memo[startCity][nearEdge.city] > sumCost){
                    memo[startCity][nearEdge.city] = sumCost;
                    pq.offer(new Edge(nearEdge.city , sumCost));
                }
            }
        }
    }
}
```

## üìå **Í∞ÑÏÑ† Îí§ÏßëÍ∏∞**

- `Îã®Ïùº Ï∂úÎ∞ú(single-source) ÏµúÎã®Í≤ΩÎ°ú` ÏôÄ `Îã®Ïùº ÎèÑÏ∞©(single-destination) ÏµúÎã®Í≤ΩÎ°ú` Íµ¨Î∂ÑÌïòÎäî Î¨∏Ï†ú

- `int[] result1 = dijkstra(destination , list);` ‚ûú `Îã®Ïùº Ï∂úÎ∞ú(single-source) ÏµúÎã®Í≤ΩÎ°ú`
- `int[] result2 = dijkstra(destination , reverseList);` ‚ûú `Îã®Ïùº ÎèÑÏ∞©(single-destination) ÏµúÎã®Í≤ΩÎ°ú`

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

class Edge implements Comparable<Edge>{
    int city;
    int cost;
    public Edge(int city, int cost) {
        super();
        this.city = city;
        this.cost = cost;
    }
    @Override
    public int compareTo(Edge o) {
        return o.cost - this.cost;
    }

    @Override
    public String toString() {
        return "Edge{" +
                "city=" + city +
                ", cost=" + cost +
                '}';
    }
}

class Main {
    static int city , edge, destination;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        List<List<Edge>> list = new ArrayList<>();
        List<List<Edge>> reverseList = new ArrayList<>();        
        city = Integer.parseInt(st.nextToken());
        edge = Integer.parseInt(st.nextToken());
        destination = Integer.parseInt(st.nextToken());
        for(int i = 0 ; i <= city ; i++) {
            list.add(new ArrayList<Edge>());
            reverseList.add(new ArrayList<Edge>());
        }
        for(int i = 0 ; i < edge ; i++) {
            st = new StringTokenizer(br.readLine());
            int node1 = Integer.parseInt(st.nextToken());
            int node2 = Integer.parseInt(st.nextToken());
            int cost = Integer.parseInt(st.nextToken());
            list.get(node1).add(new Edge(node2 , cost));
            reverseList.get(node2).add(new Edge(node1 , cost));
        }

        // Î™®Îì† ÎèÑÏãú
        int[] result1 = dijkstra(destination , list);
        int[] result2 = dijkstra(destination , reverseList);

        int maxCostToGoToCome = Integer.MIN_VALUE;

        for(int i = 1 ; i <= city ; i++){
            if(result1[i] != Integer.MAX_VALUE && result2[i] != Integer.MAX_VALUE){
                maxCostToGoToCome = Math.max(maxCostToGoToCome , result1[i]+ result2[i]);
            }
        }

        System.out.println(maxCostToGoToCome);
    }

    public static int[] dijkstra(int startCity ,  List<List<Edge>> list){
        int[] costArr = new int[city + 1];
        Arrays.fill(costArr, Integer.MAX_VALUE);
        PriorityQueue<Edge> pq = new PriorityQueue<>();
        pq.offer(new Edge(startCity , 0));
        costArr[startCity] = 0;

        while(!pq.isEmpty()){
            Edge now = pq.poll();
            int city = now.city;
            int cost = now.cost;
            for(Edge nearEdge : list.get(city)){
                int sumCost = cost + nearEdge.cost;
                if(costArr[nearEdge.city] > sumCost){
                	costArr[nearEdge.city] = sumCost;
                    pq.offer(new Edge(nearEdge.city , sumCost));
                }
            }
        }
        return costArr;
    }
}
```

***

# **`[Î∞±Ï§Ä] Î∂ÄÎ∂Ñ Ìï©` [Î∂ÄÎ∂Ñ Ìï©](https://www.acmicpc.net/problem/1806)** ÎØ∏ÏôÑÎ£å

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;


class Main {

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int size = Integer.parseInt(st.nextToken());
        long target = Long.parseLong(st.nextToken());
        long sum = 0L;
        int result = 0;
        Map<Long , Long> occurrenceMap = new HashMap<Long , Long>();
        st = new StringTokenizer(br.readLine());
        for(int i = 0 ; i < size ; i++) {
        	int value = Integer.parseInt(st.nextToken());
        	sum += value;

        	if(sum == target) result++;
        	result += occurrenceMap.getOrDefault(sum - target, 0L);

        	occurrenceMap.put(sum , occurrenceMap.getOrDefault(sum , 0L) + 1);
//        	System.out.println(sum - target + " -> " + occurrenceMap.getOrDefault(sum - target, 0L) + " | " + occurrenceMap);
        }
        System.out.println(result);
    }

}
```

***

# **`[Î∞±Ï§Ä]` [Ïù∏Í∞Ñ ÎåÄÌè¨](https://www.acmicpc.net/problem/10473)** ÎØ∏ÏôÑÎ£å

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

class Position{
	float x;
	float y;
	
	public Position(String x, String y) {
		this.x = Float.parseFloat(x);
		this.y = Float.parseFloat(y);
	}	
	public boolean equals(Position obj) {
		return this.x == obj.x && this.y == obj.y;
	}
	public float getDistance(Position obj) {
		float diffX = Math.abs(this.x - obj.x);
		float diffY = Math.abs(this.y - obj.y);
		return (float) Math.sqrt(Math.pow(diffX, 2) + Math.pow(diffY, 2));
	}
}

class Edge implements Comparable<Edge>{
	int node;
	float wasteTime;
	@Override
	public int compareTo(Edge o) {
		return (int) (this.wasteTime - o.wasteTime);
	}
}

class Main {
	static Map<String , Double> memo = new HashMap<String , Double>();
	static List<Position> positions = new ArrayList<Position>(102);
	static Position start , end;
	static final double RUN = 5;  // 5 m/s
	static final double FLY = 25; // ÎåÄÌè¨Ïóê Ïò¨ÎùºÌÉÄÍ≥† Î∞úÏÇ¨ÌïòÍ≥† Ï∞©Î•ôÍπåÏßÄ 2Ï¥à , 50m
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] line = br.readLine().split(" ");
        start = new Position(line[0] , line[1]);
        line = br.readLine().split(" ");
        end = new Position(line[0], line[1]);

        int count = Integer.parseInt(br.readLine());
        line = br.readLine().split(" ");
        
        // ÏãúÏûëÏ†ê
        positions.add(start);
        
        // ÎåÄÌè¨
        for(int i = 0 ; i < count ; i++) positions.add(new Position(line[0] , line[1]));
        
        //ÎÅùÏ†ê
        positions.add(end);
        
    	// Í∑∏ÎûòÌîÑÎ•º Ïñ¥ÎñªÍ≤å ÌòïÏÑ±Ìï†ÏßÄ??
    	// 1. ÏãúÏûëÏ†êÏóêÏÑú Í∞Å ÎåÄÌè¨Î°úÏùò Í∞ÄÏ§ëÏπò
    	// 2. Í∞Å ÎåÄÌè¨ÎÅºÎ¶¨Ïùò Í∞ÄÏ§ëÏπò
    	// 3. Í∞Å ÎåÄÌè¨ÏóêÏÑú ÎÅùÏ†ê ÍπåÏßÄÏùò Í∞ÄÏ§ëÏπò
    	// 4. ÏãúÏûëÏ†êÏóêÏÑú ÎÅùÏ†ê ÍπåÏßÄÏùò Í∞ÄÏ§ëÏπò
    	// Í∞Å Í∞ÄÏ§ëÏπòÎ•º ÌòïÏÑ±Ìï† Îïå Í±∏ÏùÑÏßÄ ÎåÄÌè¨Î•º ÏÇ¨Ïö©ÌïòÎäîÏßÄ?        
        
        
    }
    
    public static void dijkstra() {
    	
    }
}
```