---
layout: default
title: 2022ÎÖÑ 1Ïõî
nav_order: 9
parent: ÏïåÍ≥†Î¶¨Ï¶ò
---
## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

***

# **`[Î∞±Ï§Ä] Î∂ÄÎ∂Ñ Ìï©` [Î∂ÄÎ∂Ñ Ìï©](https://www.acmicpc.net/problem/1806) ÏßÑÌñâ Ï§ë**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;


class Main {

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int size = Integer.parseInt(st.nextToken());
        long target = Long.parseLong(st.nextToken());
        long sum = 0L;
        int result = 0;
        Map<Long , Long> occurrenceMap = new HashMap<Long , Long>();
        st = new StringTokenizer(br.readLine());
        for(int i = 0 ; i < size ; i++) {
        	int value = Integer.parseInt(st.nextToken());
        	sum += value;

        	if(sum == target) result++;
        	result += occurrenceMap.getOrDefault(sum - target, 0L);

        	occurrenceMap.put(sum , occurrenceMap.getOrDefault(sum , 0L) + 1);
//        	System.out.println(sum - target + " -> " + occurrenceMap.getOrDefault(sum - target, 0L) + " | " + occurrenceMap);
        }
        System.out.println(result);
    }

}
```

***

# **`[LeetCode] Ïù¥Î∂Ñ Í≤ÄÏÉâ` [Binary Search](https://leetcode.com/problems/binary-search/)**

```java
class Solution {
    public int search(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while(left <= right){
            int middle = (left + right) / 2;
            if(nums[middle] == target){
                return middle;
            }
            else if(nums[middle] < target) left = middle + 1;
            else right = middle - 1;
        }
        
        return -1;
    }
}
```

***

# **`[LeetCode] Ïù¥Î∂Ñ Í≤ÄÏÉâ` [Guess Number Higher or Lower](https://leetcode.com/problems/guess-number-higher-or-lower/)**

## Solve - Binary Search

```java
/** 
 * Forward declaration of guess API.
 * @param  num   your guess
 * @return 	     -1 if num is lower than the guess number
 *			      1 if num is higher than the guess number
 *               otherwise return 0
 * int guess(int num);
 */

public class Solution extends GuessGame {
    public int guessNumber(int n) {
        int left = 1;
        int right = n;
        while(left <= right){
            int middle = left + (right - left) / 2;
            int guess = guess(middle);
            if(guess == 0) return middle;
            else if(guess == 1) left = middle + 1;
            else right = middle - 1;
        }
        
        return -1;
    }
}
```

## Solution - Ternary Search

```java
/* The guess API is defined in the parent class GuessGame.
   @param num, your guess
   @return -1 if my number is lower, 1 if my number is higher, otherwise return 0
      int guess(int num); */

public class Solution extends GuessGame {
    public int guessNumber(int n) {
        int low = 1;
        int high = n;
        while (low <= high) {
            int mid1 = low + (high - low) / 3;
            int mid2 = high - (high - low) / 3;
            int res1 = guess(mid1);
            int res2 = guess(mid2);
            if (res1 == 0) return mid1;
            if (res2 == 0) return mid2;
            else if (res1 < 0) high = mid1 - 1;
            else if (res2 > 0) low = mid2 + 1;
            else {
                low = mid1 + 1;
                high = mid2 - 1;
            }
        }
        return -1;
    }
}
```


***

# **`[LeetCode] DP` [Climbing Stairs](https://leetcode.com/problems/climbing-stairs/)**

## Solve

```java
class Solution {
    public int climbStairs(int n) {
        if(n == 1) return 1;
        
        int value1 = 1;
        int value2 = 1;
        for(int i = 2 ; i <= n ; i++){
            int tmp = value1 + value2;
            value1 = value2;
            value2 = tmp;
        }
        return value2;
    }
}
```

## Solution

```java
public class Solution {
    public int climbStairs(int n) {
        if (n == 1) {
            return 1;
        }
        int[] dp = new int[n + 1];
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
}
```

***

# üî• **`[LeetCode] DP` [Min Cost Climbing Stairs](https://leetcode.com/problems/min-cost-climbing-stairs/)**

## Bottom-Up (Tabulation)

```java
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int[] min = new int[cost.length + 1];
        
        for(int i = 2 ; i < min.length ; i++){
            int oneStep = min[i - 2] + cost[i - 2];
            int twoStep = min[i - 1] + cost[i - 1];
            min[i] = Math.min(oneStep , twoStep);
        }
        
        return min[cost.length];
    }
}
```

## üëç Bottom-Up (Constant Space)

```java
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int oneStep = 0;
        int twoStep = 0;
        for(int i = 2 ; i < cost.length + 1; i++){
            int tmp = oneStep;
            oneStep = Math.min(oneStep + cost[i - 1], twoStep + cost[i - 2]);
            twoStep = tmp;            
        }
        return oneStep;
    }
}
```

## Top-Down (Recursion + Memoization)

```java
class Solution {
    int[] memo;
    public int minCostClimbingStairs(int[] cost) {
        memo = new int[cost.length + 1];
        return minCost(cost , cost.length);
    }
    public int minCost(int[] cost , int target){
        if(target <= 1) return 0;
        else if(memo[target] != 0) return memo[target];
        
        int downOne = cost[target - 1] + minCost(cost , target - 1);
        int downTwo = cost[target - 2] + minCost(cost , target - 2);
        return memo[target] = Math.min(downOne , downTwo);
    }
}
```

***

# üî• **`[LeetCode] DP - Kadane's Algorithm` [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/)**

## Solve

```java
class Solution {
    public int maxSubArray(int[] nums) {
        if(nums.length == 1) return nums[0];
        
        int result = nums[0];
        for(int i = 1 ; i < nums.length ; i++){
            nums[i] = Math.max(nums[i] , nums[i] + nums[i - 1]);
            result = Math.max(result , nums[i]);
        }
        return result;
    }
}
```

## Solution - Divide and Conquer (Advanced)

```java
class Solution {
    private int[] numsArray;
    
    public int maxSubArray(int[] nums) {
        numsArray = nums;
        
        // Our helper function is designed to solve this problem for
        // any array - so just call it using the entire input!
        return findBestSubarray(0, numsArray.length - 1);
    }
    
    private int findBestSubarray(int left, int right) {
        // Base case - empty array.
        if (left > right) {
            return Integer.MIN_VALUE;
        }
        
        int mid = Math.floorDiv(left + right, 2);
        int curr = 0;
        int bestLeftSum = 0;
        int bestRightSum = 0;
        
        // Iterate from the middle to the beginning.
        for (int i = mid - 1; i >= left; i--) {
            curr += numsArray[i];
            bestLeftSum = Math.max(bestLeftSum, curr);
        }
        
        // Reset curr and iterate from the middle to the end.
        curr = 0;
        for (int i = mid + 1; i <= right; i++) {
            curr += numsArray[i];
            bestRightSum = Math.max(bestRightSum, curr);
        }
        
        // The bestCombinedSum uses the middle element and the best
        // possible sum from each half.
        int bestCombinedSum = numsArray[mid] + bestLeftSum + bestRightSum;
        
        // Find the best subarray possible from both halves.
        int leftHalf = findBestSubarray(left, mid - 1);
        int rightHalf = findBestSubarray(mid + 1, right);
        
        // The largest of the 3 is the answer for any given input array.
        return Math.max(bestCombinedSum, Math.max(leftHalf, rightHalf));
    }
}
```

***

# **`[LeetCode] DP` [House Robber](https://leetcode.com/problems/house-robber/)** ‚ùå

***

# **`[LeetCode] DP` [House Robber II](https://leetcode.com/problems/house-robber-ii/)** ‚ùå

***

# **`[LeetCode] DP` [Paint House](https://leetcode.com/problems/paint-house/)** üìù

## First Approach, Brute force with a Recursive Tree ‚ûú <span class="text-red-300">Time Limit Exceeded</span>

```java
    class Solution {
        int[][] costs;
        public int minCost(int[][] costs) {
            this.costs = costs;
            return Math.min(paintCost(0 , 0) , Math.min(paintCost(0 , 1) , paintCost(0 , 2)));
        }
        
        public int paintCost(int house , int color){
            if(house < costs.length){
                int cost = costs[house][color];
                if(color == 0){
                    cost += Math.min(paintCost(house + 1 , 1) , paintCost(house + 1 , 2));
                }
                else if(color == 1){
                    cost += Math.min(paintCost(house + 1 , 0) , paintCost(house + 1 , 2));
                }
                else if(color == 2){
                    cost += Math.min(paintCost(house + 1 , 0) , paintCost(house + 1 , 1));
                }
                return cost;
            }
            else return 0;
            
        }
    }
```

## Second Approach, Memoization ‚ûú `24ms` <span class="text-green-300">Success</span>

```java
class Solution {
    int[][] costs;
    Map<String , Integer> memo;
    public int minCost(int[][] costs) {
        this.costs = costs;
        this.memo = new HashMap<>();
        
        return Math.min(paintCost(0 , 0) , Math.min(paintCost(0 , 1) , paintCost(0 , 2)));
    }
    
    public int paintCost(int house , int color){
        if(house < costs.length){
            String key = getKey(house , color);
            if(memo.containsKey(key)){
                return memo.get(key);
            }
            
            int cost = costs[house][color];
            if(color == 0){
                cost += Math.min(paintCost(house + 1 , 1) , paintCost(house + 1 , 2));
            }
            else if(color == 1){
                cost += Math.min(paintCost(house + 1 , 0) , paintCost(house + 1 , 2));
            }
            else if(color == 2){
                cost += Math.min(paintCost(house + 1 , 0) , paintCost(house + 1 , 1));
            }
            memo.put(key , cost);
            return cost;
        }
        else return 0;
        
    }
    
    public String getKey(int house , int color){
        return house + "-" + color;
    }
}
```

## Third Approach, Dynamic Programming ‚ûú `1ms` <span class="text-green-300">Success</span>

```java
class Solution {
    public int minCost(int[][] costs) {
        for(int i = costs.length - 2 ; i >= 0 ; i--){
            costs[i][0] += Math.min(costs[i + 1][1] , costs[i + 1][2]);
            costs[i][1] += Math.min(costs[i + 1][0] , costs[i + 1][2]);
            costs[i][2] += Math.min(costs[i + 1][0] , costs[i + 1][1]);
        }
        return Math.min(costs[0][0] , Math.min(costs[0][1] , costs[0][2]));
    }
}
```

***

# **`[LeetCode] DP` [Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)**

## Brute Force ‚ûú <span class="text-red-300">Time Limit Exceeded</span>

```java
class Solution {
    public int maxProfit(int[] prices) {
        int diff = Integer.MIN_VALUE;
        for(int i = 0 ; i < prices.length ; i++){
            for(int j = i ; j < prices.length ; j++){
                diff = Math.max(diff , prices[j] - prices[i]);
            }
        }
        return diff;
    }
}
```

## One Pass ‚ûú <span class="text-green-300">Success</span>

```java
class Solution {
    public int maxProfit(int[] prices) {
        int minPrice = Integer.MAX_VALUE;
        int maxProfit = 0;
        for(int i = 0 ; i < prices.length ; i++){
            minPrice = Math.min(prices[i] , minPrice);
            maxProfit = Math.max(prices[i] - minPrice , maxProfit);
        }
        return maxProfit;
    }
}
```

***

# **`[LeetCode] DP` [Paint House II](https://leetcode.com/problems/paint-house-ii/)**

![](../../../assets/images/books/../../../jeongcode.github.io/assets/images/algorithm/2022y01m/paintHouse2.png)


```java
```

***

# **`[2021Ïπ¥Ïπ¥Ïò§] Îã§ÏùµÏä§Ìä∏Îùº` [Ìï©Ïäπ ÌÉùÏãú ÏöîÍ∏à](https://programmers.co.kr/learn/courses/30/lessons/72413)**

```java
import java.util.*;

class Node{
    int vertex;
    int cost;
    public Node(int vertex , int cost){
        this.vertex = vertex;
        this.cost = cost;
    }
}

class Solution {
    static int[] costArr;
    static List<List<Node>> list = new ArrayList<>();
    public int solution(int n, int s, int a, int b, int[][] fares) {
        int answer = 0;
        for(int i = 0 ; i <= n ; i++) list.add(new ArrayList<>());
        for(int i = i ; i < fares.length ; i++){
            int node1 = fares[i][0];
            int node2 = fares[i][1];
            int cost = fares[i][2];
            list.get(node1).add(new Node(node2 , cost));
            list.get(node2).add(new Node(node1 , cost));
        }
        
        int result1 = dijkstra(s , a);
        int result2 = dijkstra(s , b);
        
        return answer;
    }
}
```