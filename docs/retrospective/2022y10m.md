---
layout: default
title: 2022년 10월
nav_order: 40
parent: ⏪ 회고
---
{: .no_toc }

<details open markdown="block">
  <summary>
    Table of contents
  </summary>
  {: .text-delta }
1. TOC
{:toc}
</details>

---

# **10월 첫째 주 회고** `코드숨 끝`

벌써 코드숨이 끝났다<br>
개발도 많이 배웠지만 공부하는 방법이나 방향성에 대해서도 많이 배운 것 같다<br>
혼자 TDD와 테스트 코드를 배웠다면 이렇게 못 배웠을것이다..<br>
다른 사람이 보기에는 고작 8주 가지고 뭐 대단하게 바뀌겠냐 라고 말 하겠지만, 이 교육을 듣기 전과 후로 나뉘는 것 같다.<br>

1. 테스트 코드를 왜 짜는지?
2. 테스트 주도 개발이 무엇인지?
3. 통합 테스트와 단위 테스트가 무엇인지?
4. 생각을 하면서 개발하는 것 (개발에 정답은 없지만 이렇게 작성한 이유를 설명할 수 있게)
5. 객체 지향 프로그래밍이 무엇인지?
6. DTO와 불변 클래스를 왜 쓰는지? 등등

정말 소중한 경험이었다.<br>
**8주 동안 아낌없이 조언을 해주신 리뷰어분들과 윤석님에게 감사하다.**<br>

<br>

아래의 3개에서 선택해야 했다 <br>
1. 우테캠프로 사전 과제
   - 사전 과제는 객체지향설계 능력을 많이 보는 과제들이다
2. 코드숨 포트폴리오반
   - 협업 경험, 데브옵스 경험이 가능하다
3. 하고 싶은 것
   - 북마크 토이 프로젝트 하기
   - JPA 공부
   - 캐싱 , Redis 사용해보기
   - 스프링 시큐리티 컨텍스 홀더 분석해보기
   - 토프링 읽기 모임, 오브젝트 스터디 진도 따라가기

<br>
항상 우테캠을 듣고 싶었어서 사전과제를 선택했다. (시간남으면 하고 싶은 것 하기)<br>
일단 사전 과제에 집중하자<br>


**뭔가를 공부할 때 한 개만 선택해서 한 개에만 몰두하는 단점이 있다**<br>
1. 여러 개를 해보면서 버리는 것은 문제가 안된다
2. 스스로 뭐가 중요한지 고민을 잘 하고 최선의 선택을 하기
3. 최소의 노력으로 최대의 결과 만들기

***

## 코드숨 8주차 과제 `Spring REST Docs 적용, Docker로 빌드 및 배포`

**Spring REST Docs**와 **Docker**, **Gradle 명령어**를 처음 사용해 보았다<br>
**Spring REST Docs**를 사용하면서 테스트 코드를 짜야하는 이유가 한 개 더 생겼다<br>
- `@Nested`를 사용한 계층 테스트 코드를 작성하고 `document()`를 사용하면 예외가 발생한다.
- 계층형 내부 클래스에 어노테이션들을 반복적으로 작성해줘야 한다.
- 이번 과제에서 REST Docs와 관련된 테스트 코드는 `given-when-then`으로 작성했다.
<br>

**Docker**를 사용하면서 로컬에 깔려있는 디비를 지우고 컨테이너로 사용하는 방법을 배우고 설정 정보도 분리 할 수 있다는 것을 배웠다
- *토비의 스프링 읽기모임 예제 레포도 토비님이 도커를 넣어놓으신걸 이번 과제를 배우고 깨달았다 ㅎㅎ*
- 따로 강의를 사서 듣고 싶다
<br>
   
**특정 도메인 서비스를 위한 한 가지의 기능만 가진 인터페이스**
- 컨트롤러와 서비스를 한 개의 책임만 가지게 세세한게 분리해 보았다
- 테스트 코드를 짜거나 수정할 때 편리하다는 것을 느꼇다
- 이렇게 까지 분리할 수 있구나 싶었다

***

## 면접 경험

Seed 스타트업 회사 면접을 볼 기회가 있었다<br>
기대하는 만큼 깊은 기술 질문은 없었어서 아쉬웠다..<br>

**질문 준비를 했는데 못한 질문들**<br>

1. **OAuth2.0**을 사용한다고 돼있는데 토큰이 어떤식으로 관리되고 있는지?
   1. AccessToken , RefreshToken에 대해 물어보고 싶었다
   2. 토큰 만료 시간은 얼마로 설정되어 있고 그렇게 설정한 이유는?
2. 현재까지 개발하면서 만난 장애물이 무엇인지?
3. 제가 실무에 투입된다면 어떤 역량과 역할을 기대하는지? 업무적으로 무슨 경험을 할 수 있는지?
4. 세션이나 캐싱은 어떻게 처리되고 있는지?


**느낀 점**<br>

1. 대답할 때 `어..` , `음` , `좀` 등 이상한 말 갖다붙이지 말자
2. 대답을 천천히 해도 문제 없으니까 **정리를 잘하고, 하고 싶은 말을 간단명료하게** 말하자
3. 스스로 느끼기에는 말을 조금 빨리하는 것 같다
4. 궁금한 것을 질문하는거에 부담을 느끼지 말자
   1. 궁금한게 있다면 바로바로 물어보자
5. 면접 흐름
   1. 이력서 위주로 물어봄
   2. TDD에 대한 얘기
   3. 관심있는,사용하고 싶은 기술

***

# **10월 둘째 주 회고** 

코드숨과 우테캠프로 사전과제를 다 끝내고 되돌아보면 SI에서 2년 4개월 다니면서 나쁜 습관과 무지성으로 프로그래밍 했다는 생각이 많이 든다. <br>
이런 문제는 **스스로 개선을 할 수 있는 영역인데 OOP, 좋은 코드에 관심은 있지만 스스로 노력하지 않은 문제다.** <br> 


## 우테캠프로 사전 과제

사전 과제를 다 제출했다.<br>
참고 - [우테캠프로 사전과제](https://jdalma.github.io/docs/retrospective/woowahan/)<br>
사전과제로 주어진 과제 자체는 간단한 문제다.<br>
숫자 야구 게임, 자동차 경주 게임을 구현하는 것은 쉬웠다.<br>
하지만 신경써야 할게 많다.<br>
1. TDD로 도메인 먼저 개발하기
2. 객체지향적 객체간 협력과 책임, 관심사 분리하기
3. 컨벤션을 지키면서 개발하기

내가 개발할 기능이 **협력**이라고 생각하고 도메인을 TDD로 개발하면 **책임**이 쉽게 분리되는 것 같았다.<br>
- `RacingCars`를 작성하다가 `Car`를 작성하고, `Car`를 작성해야지 하면서 `CarName`과 `Forward`를 작성한 것

하지만 마냥 쉽지 않았다.<br>
1. 각 객체의 내부,외부를 구분하여 **캡슐화**를 어느정도까지 할지?
2. 메시지를 어떻게 전달할지?
3. 불필요한 메소드를 작성하고 그 메소드의 테스트 코드를 작성하여 리팩토링할 때 삭제하는것이 많았다.

스스로 객체의 책임과 협력을 결정하며 개발하는 것이 처음인 것 같다..<br>
재밌엇다. 다들 사전과제만 해도 많이 배운다고 하시던데 사실이다.<br>
`"내 개발 능력이 굉장히 낮다. 내가 이때까지 작성한 코드들은 완벽한 절차지향적이었고, 되기만하는 코드를 작성했구나."` 반성하게 되는 계기도 되었다

## 자비스앤빌런즈 과제 테스트 통과

자비스앤빌런즈 과제 테스트 통과 메일을 받았다<br>
- *메일을 10번 정도 읽었던 것 같다..*
- *결과가 안나오길래 떨어진 줄 알았는데 과제 테스트라서 시간이 많이 걸렸던 모양이다*

내가 작성한 과제 화면 공유하면서 **코드 리뷰 형식으로 기술 면접을 본다고 전달받았다** <br>
- 내가 그렇게 개발한 이유나 스프링에 대해 이야기가 많이 나오지 않을까 싶다
- 내가 작성한 과제를 다시 메일로 주신다고 하니 받으면 복기하고 **그렇게 개발한 이유와 더 좋은 방법을 고민하는 회고를 작성해야겠다**
  - 과제에서 제공된 테스트를 다 통과 하지 못했어서 찝찝했었는데 테스트를 다 통과하게 만들어봐야겠다
<br>

## 차주 목표

1. 구름 먼데이 챌린지 2주차 풀기
2. 코딩 인터뷰 대비 관련 문제 LeetCode에 정리되어 있는 문제 풀기
3. 토프링 AOP까지 읽는 것
 
***

# **10월 셋째 주 회고** 

1. [Iterator 정리](https://jdalma.github.io/docs/lab/iterator_vs_enumeration/) 게시글 작성
2.  has a 디자인
3. 이 [리뷰](https://github.com/CodeSoom/spring-week5-assignment-1/pull/79#discussion_r994574114)를 보고 삼쩜삼 과제에는 정보를 삭제하는 API가 없다는 걸 느꼇다
4. 이 [리뷰](https://github.com/CodeSoom/spring-week5-assignment-1/pull/79#discussion_r995706395)보고 DTO가 꼭 요청/응답에만 사용되기 보다는 데이터 전송 객체라는 말에 걸맞게 계층간에도 필요하다면 추가할 수 있다는 것을 알게 되었다
5. [손상 방지 계층 패턴](https://learn.microsoft.com/ko-kr/azure/architecture/patterns/anti-corruption-layer)
6. [Mock은 Stub이 아니다(Mocks Aren't Stubs)](https://jaime-note.tistory.com/330)
 
## 6장 AOP 읽기

- AOP 절반 정도 읽었다. 어려운데 꽤 재밌다.
- 이번 주 읽은 내용의 목표는 `@Transactional`과 같이 트랜잭션 경계설정 부분을 편리하게 작성하기 위함이다
  1. 트랜잭션 동기화 저장소를 통해 커넥션은 파라미터로 전달해주지 않아도 된다
  2. 부가기능을 프록시로 적용하여 부가기능과 핵심기능을 확실히 분리하였다
  3. 프록시 패턴을 리플렉션과 `InvocationHandler`를 사용하여 다이나믹 프록시 패턴으로 개선하였다
  4. 일반적인 스프링 빈 등록이 아니라 `FactoryBean`을 구현하여 다이나믹 프록시를 빈으로 등록해 보았다.
  5. 트랜잭션 경계설정 프록시를 `Factory Bean`을 사용하여 스프링 빈으로 등록하여 완벽하게 부가기능과 핵심기능을 분리해냈다.
- 엄청 집요하게 추상화하는게 인상깊었다
  - "이 정도면 엄청 깔끔한데?"라고 생각했지만 책에서는 더 나아간다

## 6주차 토프링 읽기 모임 

- 리플렉션은 메타프로그래밍을 하기위한 방법으로 나왔다
  - **메타프로그래밍** : 프로그래밍하면서 작성되었던 코드를 데이터로 취급할 수 있다
  - 리플렉션 패키지는 tool을 사용할 떄 많이 사용했다
- `CGLIB`는 코드 제네레이션 라이브러리이다
  - **인터페이스를 구현하지 않은 클래스에 대해 프록시를 만들어야 할 떄**
  - (JDK에서는 불가하기 때문에) CGLIB는 상속을 통해 프록시를 만드는 기법을 사용한다
  - 오버라이드 할 수 있는 모든 메소드를 프록시로 만든다
  - 스프링에서는 두 가지 다 쓰인다
  - **상속을 통해 프록시를 만들면 단점이 있다**
    - `final`클래스로 만들 수 없다
    - 기본 생성자가 두 번 호출되는 점, 자바5부터 없어졌다
  - 인스턴스를 만들 때 생성자를 호출하지 않고 만드는 트릭을 쓰는 라이브러리가 등장했다
- 프록시의 의미를 잘 이해해야 한다
  - 프록시 패턴의 프록시
  - 일반적으로 말하는 프록시
- **Q** : 다이나믹 프록시를 생성할 때 애플리케이션 클래스로더를 넘기게 되는데, 이 클래스 로더로 무슨 일이 일어나는지?
- **A** : **다이나믹 프록시는 새로운 클래스를 런타임에 동적으로 생성하여 만들고 연결 시키기 위해 클래스 로더를 필요로 한다.**
  - 클래스 로더를 간단하게 스프링이 제공하는 방법도 있다 
  - 클래스 로더 관련해서
    - 도진님이 [링크](https://tecoble.techcourse.co.kr/post/2021-07-15-jvm-classloader/)를 공유해 주셨다
    - Kevin Lee님이 [링크](https://javacan.tistory.com/m/entry/1)를 공유해 주셨다
- JPA에서는 프록시를 어떻게 사용하는지
  - `@Entity`가 대표적이다
  - 인터페이스가 있다면 CGLIB을 사용하지 않지만 인터페이스가 없다면 CGLIB을 사용한다
- 스프링 6
  - 그랄VM
  - 네이티브 컴파일
  - 스프링에서 CGLIB을 없애야 된다. (충돌이 많이 나서)
- AspectJ
  - AOP를 가장 깊이 있게 만들어낸 라이브러리
  - [@AspectJ 기반 AOP with Spring](https://www.tutorialspoint.com/spring/aspectj_based_aop_appoach.htm)
- 코드위빙?
- **JSON을 인코딩하고 디코딩하는게 CPU를 제일 많이 먹는다**
- `Mock`도 성능에 큰 문제를 준다

## 구름 먼데이 챌린지

- 1회차 문제 풀이를 하였다
- 2회차 챌린지 성공

<!-- ## 모의면접

**감사하게도 종립님과 윤석님이 모의면접을 진행해주셨다**<br>
 - 따로 시간을 내주셔서 진행해주셨는데 그에 맞는 보답을 못 해드린 것 같다..
 - 면접준비가 굉장히 안되어있고, 질문의도 파악을 못한 것 같다
 - 밤 늦게 진행해서 그런지 힘이 많이 없었다
 - 내가 부족한 부분은 빠르게 인정하고 이것을 채우기 위해 어떤 노력을 했는지 설명해야한다
 - 설명을 덕지덕지 붙이지 말고 기술에 대한 질문이 들어온다면 **간단명료**하게 대답하자
   - 설명을 여러 차례 반복하는 말을하는 버릇
   - REST에 대해 이야기하고 싶어하는데 핵심적인 설명이 아니라 주변부에 대한 설명을 갖다 붙인다
   - 그 질문에 대한 시간을 넘어가길 원하는 모습이 많이 보였다
 - 시키는 일만하는 것이 아니라 전체를 조망하는 개발자가 되고 싶다
   - 그러기 위해 무엇을 공부하고 무엇을 노력하고 있다 라는 설명
 - 실제 면접관들은 매일 면접을 진행하니 많이 지쳐있을 것이다
 - 좋은 에너지를 보이려고 노력하고 적극적인 소통을 하자
 - 문제점을 지적받았을 때 급격히 어두워지거나 답변을 피하거나 실수를 회피하려는 모습을 보이면 같이 일하기 힘든 인상을 심어줄 수 있다
   - 말투나 텐션이 자신감이 많이 떨어져보인다
   - **단점처럼 말하면 진짜 단점이 된다**
 - 더 나은 방향으로 작업할 수 있다는 자신감을 보이자
 - 칭찬을 하거나 꼬투리를 잡아 나의 반응을 볼 확률이 높다
 - 면접을 유리한 방향으로 이끌어가야한다 -->

## 차주목표

- 과제 통과하지 못한 테스트 케이스 통과하도록 개발
- 계좌와 계좌기록 N + 1 문제 분석
- (스프링 6장을 읽다가) 정리가 필요한 패턴 정리
   - 프록시 패턴
   - 데코레이터 패턴
- 스프링 6장 AOP 나머지 다 읽기
- 구름 챌린지 2주차 풀이, 3주차 진행

***

# **10월 넷째 주 회고**

- [마이크로서비스 패턴: 핵심패턴만 빠르게 이해하기](https://happycloud-lee.tistory.com/m/154?category=902418)
- [이벤트 소싱 event-sourcing 패턴 정리](https://edykim.com/ko/post/eventsourcing-pattern-cleanup/)
- [대용량 처리를 위한 서비스 구성](https://jistol.github.io/architecture/2017/02/14/architecture-traffic-issue/)
- [REST API는 어떻게 만들어야 하는가?](https://codesoom.github.io/wiki/api-design/03/)
- [`aws` RESTful API란 무엇입니까?](https://aws.amazon.com/ko/what-is/restful-api/)
- "RestTemplate보다 최신 API가 있고 동기화, 비동기 및 스트리밍 시나리오를 지원하는 `org.springframework.web.reactive.client.WebClient` 를 사용하는 것을 고려하십시오"
  - `RestTemplate`과 `WebClient`의 차이는 블럭과 넌블럭의 차이이다
  - [동기와 비동기, 그리고 블럭과 넌블럭](https://musma.github.io/2019/04/17/blocking-and-synchronous.html)

## 토프링 6장 AOP

지난 주에는 프록시를 사용하여 부가기능과 핵심기능을 분리하였지만, 이번 주는 프록시를 더 편하고 정밀하게 사용하는 방법을 공부하였다<br>
1. `ProxyFactoryBean`을 적용하여 타깃에 의존하지 않는 프록시 생성
2. 어드바이스, 포인트컷, 어드바이저에 대한 이해
3. 빈 후처리기를 이용하여 자동 프록시 생성
   - `DefaultAdvisorAutoProxyCreator`
4. 포인트 컷 클래스,메소드 적용 대상 선정 방법 이해
5. 트랜잭션 속성

## 토프링 읽기모임 7주차

- `readOnly = true`를 설정하게 되면 읽기 외의 작업에 필요한 준비를 하지 않게되어 성능이 향상 될 수 있다
  - 다른 개발자에게 다른 작업을 하지 않는다고 알려줄 수도 있다
- [`woowahan` 응? 이게 왜 롤백되는거지?](https://techblog.woowahan.com/2606/)
- [refactoring guru](https://refactoring.guru/ko)
- [`mysql 8.0` 트랜잭션 격리 수준](https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html)
- [최범균 트랜잭션 조금 이해하기](https://www.youtube.com/watch?v=urpF7jwVNWs&list=RDLVpoyjLx-LOEU&index=2&ab_channel=%EC%B5%9C%EB%B2%94%EA%B7%A0)

## 자비스앤빌런즈 과제 개선 작업

**DTO는 `Controller`에서만 사용**<br>
- `Entity` → `DTO` 변환은 팩토리 메소드 `of`추가
- `DTO` → `Entity` 변환은 `toXXX()`추가

**입출금 기록 동시성 문제**<br>
- 입금일 때, 출금일 때 둘 다 동시성을 걸기보다는 출금일 때만 걸어줬다
- 그 이유는 누적 잔액을 관리하는 것이 아니라 입출금 금액만 저장되기 때문에 입금에 대한 동시성 문제는 없다고 판단했다
- `@Transactional` + `synchronized`를 하면 절대 해결되지 않는다
  - `@Transactional`의 작동방식을 알면 이해할 것이다
- 금액과 관련한 중요한 작업이라서 비효울적이더라도 비관적 락을 사용했다
- 추가적인 해결방법은 디비에 부하를 주지않고 `Redis`의 `Redisson`이나 `Lettuce`를 사용하여 해결하는 방법도 존재한다.

**N + 1문제**<br>
- 이 과제에서는 계좌와 입출금기록 `outer join`만 필요했으므로 `@EntityGraph`로 해결했다
- `@NamedEntityGraph`는 엔티티에도 작성하고 레포지토리에서도 작성해야 해서.. 굳이 두 곳에 작성해야하나 싶어서 사용하지 않았다
  - 쿼리가 복잡해지거나 탐색해야할 객체가 많아진다면 고려해볼 수 있겠다

**엔티티에 `@Transient` 필드 추가**<br>
- 계좌 엔티티에 단순 데이터 저장용 필드가 필요했다. (잔액과 이자)
- `@Id`의 작성 위치에 따라 **엔티티에 대한 접근 방식이 달라지므로**, 해당 어노테이션은 유의해서 써야한다.
- [`@Transient`관련 글](https://gmoon92.github.io/jpa/2019/09/29/what-is-the-transient-annotation-used-for-in-jpa.html)

**추가적인 문제**<br>
1. 동기화 테이블의 해당 계좌의 입출금 기록 마지막 정보를 가져와서 잔액을 계산하는 것이 효율적이지 않을까?
  - 해당 계좌의 모든 입출금기록을 순회하며 계산하는 것은 비효율적이다.
2. 동시성 문제를 비관적 락으로 해결하였는데, 트랜잭션이 락을 잡고 있으면 조회도 같이 막혀버린다
  - 계좌 조회 테이블과 입출금 기록 조작을 위한 계좌 테이블이 따로 있어야 할 것 같다

**만났던 예외**<br>
- `Request processing failed; nested exception is org.hibernate.LazyInitializationException: failed to lazily initialize a collection of role` 예외
  - `accounts`를 조회하고 `mappedBy`로 연결된 `getTransactions()`호출 시 발생
  - 이유는 영속성 컨테스트에서 관리되지 않는 **준영속 상태**인 **프록시**를 (`Lazy`하게) `getTransactions()`를 호출했기 때문이다

**스스로 코드를 작성하는게 달라졌다고 느꼈다**<br>
- service에서 `account`한테`transactions`를 달라고해서 잔액을 구하다가
- `account` 내부에서 잔액을 구하도록 바꾸고
- 이자율 전략패턴을 추가하여 service에서 전략을 지정하여 `account`한테 전달해서 이자금액을 돌려받도록 리팩토링 했다

## 차주목표

이번 주는 과제 개선 작업에 집중했다.<br>
토프링 6장은 다 읽지 못했지만.. 과제 개선 작업을 하며 `N+1 문제`, `동시성 문제`에 대해 고민하고 여러가지 해결방법을 찾아보고 장,단점을 비교해보았다 <br>
<br>
다음 주는
1. 토프링 6,7장 읽기
2. 구름 챌린지하기
3. 기술면접 두 개보기

***

1. [Back to the Essence - Java 컴파일에서 실행까지 - (2)](https://homoefficio.github.io/2019/01/31/Back-to-the-Essence-Java-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EC%97%90%EC%84%9C-%EC%8B%A4%ED%96%89%EA%B9%8C%EC%A7%80-2/)
2. DB 원자적 연산 기능

# 10.25(화)

1. RestTemplate, HttpClient 분석하기
   - 왜 RestTemplate에는 관대 했을까
   - 왜 스스로 제일 싫어하는 짓을 했지??
2. 내가 정리한 글을 기억 못했다
   - 글을 그냥 아무생각 없이 작성하는 것이 아닐까?
   - 죽은 문서를 적어내는것이 아닐까?
3. 대답 못 한것에 후회하지 말고 조사를 해보자
   - index가 잘 타는지 확인하는 방법
   - 쿼리 실행계획