---
layout: default
title: 2022년 9월 - 코드숨
nav_order: 3
parent: ⏪ 회고
---
{: .no_toc }

<details open markdown="block">
  <summary>
    Table of contents
  </summary>
  {: .text-delta }
1. TOC
{:toc}
</details>

---

## **09.01 (목)**
1. 코드숨 알고리즘 9일차 완료
2. 과제 주석 작성 및 수정
3. MVC 테스트 코드 작성
4. 스프링 1.1

## **9월 첫 째주 회고** - 코드숨 5주차 과제 `고양이 장난감 가게 만들기`

**배운 것**
{: .fh-default .fs-6 }

1. 코드숨 알고리즘
   - Sorting , BruteForce , Greedy , Heap , DynamicProgramming
2. [`docs oracle` Using Bean Validation Constraints](https://docs.oracle.com/javaee/7/tutorial/bean-validation001.htm)
3. [**`Dozer Mapper` Getting Started**](https://dozermapper.github.io/gitbook/documentation/gettingstarted.html)
   - DozerMapper의 문제점 조사하기 🚩 [리뷰](https://github.com/CodeSoom/spring-week5-assignment-1/pull/75#discussion_r961656565)
4. JSON 직렬화 , 역직렬화에서 특정 필드 무시하기
   - 자원 생성 , 수정 각 상황에 맞는 DTO 추가
5. JavaDoc을 작성하는 방법
   - 자바 빌트인 클래스들을 참조 `String.class`
   - [`johngrib` JavaDoc 작성하기](https://johngrib.github.io/wiki/java/javadoc/)
     - **목표는 특정 코드 덩어리의 대략적인 역할을 3초 안에 파악할 수 있도록 도와주는 것이다.**
     - **메소드가 무엇을 입력받아서 무엇을 리턴하는지를 반드시 설명한다.**
     - **구현과 주석이 커플링이 생기지 않도록 한다.**
     - **주석 상속 규칙**
6. [`@AllArgsConstructor`, `@RequiredArgsConstructor` 주의](https://jdalma.github.io/docs/algorithmTheory/lombok/#allargsconstructor-requiredargsconstructor-%EC%82%AC%EC%9A%A9%EA%B8%88%EC%A7%80) 정리 
7. [`@Builder`를 클래스 , 생성자에 작성 차이](https://jdalma.github.io/docs/algorithmTheory/lombok/#builder-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%97%90-%EC%9E%91%EC%84%B1%ED%95%98%EB%8A%94-%EA%B2%83%EA%B3%BC-%EB%A9%94%EC%84%9C%EB%93%9C%EC%97%90-%EC%9E%91%EC%84%B1%ED%95%98%EB%8A%94-%EA%B2%83%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90) 정리
8. 모킹을 제거하고 **Controller 통합 테스트**
9. **Serivce** 목적에 맞게 분리 [리뷰](https://github.com/CodeSoom/spring-week5-assignment-1/pull/75#discussion_r958434890)
   - `QueryService`
   - `CommandService`

**느낀 것**
{: .fh-default .fs-6 }

코드숨 과제를 통해 배우고 정리했던 내용 덕분에 토프링 읽기모임에서 나왔던 내용들이 금방 이해됐다. <br>
**JavaDoc** , 주석의 필요성을 느꼇다 <br>
**주석은 구현에 의존되게 작성하지 말자** <br>
테스트 코드를 작성할 때 모킹을 쓰지 않는 환경에 적응하자 <br>
미리 테스트를 만들어 두는 경우에는 까먹지 않게 일부러 테스트를 실패하게 하자<br>

**교훈**
{: .fh-default .fs-6 }

간편해서 막 쓰는 어노테이션들을 세심하게 살펴보자 <br>
생성자 어노테이션을 막 작성한것이 그 예다 <br>
한 번에 알아볼 수 있도록 **주석**을 작성하려 노력하자 <br>
[JLS](https://docs.oracle.com/javase/specs/)를 애용하자

***

## 09.05 (월)
1. 알고리즘 3문제 BFS , 1문제 DP
2. 5주차 과제 풀의 영상 시청
3. 6주차 과제 주석 작성
4. [`johngrib` 테스트 코드와 반증가능성에 대한 메모](https://johngrib.github.io/wiki/article/test-code-and-falsifiability/)
5. 과제를 진행하면서 이해 안가는 상황이 있다..
   - **Jpa Repository**가 **Repository Interface**와 **CrudRepository Interface**를 확장하고 있다
   - **Service**클래스가 **Repository Interface**를 주입받고 사용하고 있다
   - Spring Data JPA에서 제공하는 interface를 확장하면 제공되는 쿼리를 쓸 수 있다는 것만 알았는데..
   - 그러면 **Jpa Repository**를 주입받아서 사용해야 하지 않나..?
   - 어떻게 **Repository Interface** 쓸 수 있는 것일까?
6. Spring Data JPA에서 제공하는 interface의 메서드만 확장해서 사용할 수 있는 줄 알았는데..
   - `UserRepository.existsByEmail()`이라는 메서드는 어떻게 실행되는걸까??


```
알고리즘 스터디에서 합분해를 주현님이 조합으로 푸시다가 메모이제이션을 활용했다고 하셨다
근데 조합 중 동일한 파라미터가 들어오는 경우가 있어서 자연스럽게 메모이제이션을 떠올리셨다고 한다

"DP의 중요한 포인트는 완전탐색이다!!!"
```

## 09.06 (화)
1. 코드숨 알고리즘 12일차 완료
1. 거스름돈 같은 문제는 그리디로 풀었었는데 [동전 2](https://www.acmicpc.net/problem/2294)같은 문제는 그리디로 풀 수 없다고 한다. 왜?
   - 화폐의 가치가 배수가 아니라서 그렇다
   - 그리디로 풀면 동전 개수 최소값을 구할 수 없다
   - DP배열을 초기화하는 아이디어가 부족했다
   - 화페의 인덱스에 `1`을 표시만 하려고 했지 배수로 그 금액을 만들 수 있는 화폐의 개수는 카운트 할려고 하지 않았다...

```java
Arrays.fill(dp , MAX);
dp[0] = 0;

for(int i = 1 ; i <= N ; i++){
    int coin = Integer.parseInt(br.readLine());
    for(int j = coin ; j <= K ; j++){
        dp[j] = Math.min(dp[j] , dp[j - coin] + 1);
    }
}
```

2. [포도주 시식](https://www.acmicpc.net/problem/2156)을 시도했지만 실패.. 점화식을 세우기가 어렵다

## 09.07 (수)

1. 코드숨 알고리즘 13일차 완료
2. 01BFS 정리
3. [벽 타기](https://www.acmicpc.net/problem/23563) 실패...

## 09.08 (목)
1. DP 문제 어렵다
2. [벽 타기](https://www.acmicpc.net/problem/23563) 실패...

## 09.09 (금)
1. [`johngrib` SOLID](https://johngrib.github.io/wiki/jargon/solid/)
2. 스프링 읽기

## 09.10 (토)
1. 분할 정복 1문제 완료
2. 백준 - Z 문제
   - 4분면으로 나누어 모든 경우를 다 확인하면 시간초과가 난다.
   - 분할 구역을 선택해서 나눈다.

## 09.15 (목)
1. 문자열 압축 완료
   - 문자열 단위를 나누어서 압축이 가장 짧게 된 것을 리턴

## 09.16 (금)

3. ExceptionHandler 테스트 코드 추가
4. 오브젝트 읽기
   - Getter도 염려하면서 사용하자

## 09.17 (토)

![](../../assets/images/retrospective/20220917.jpg)

- 늦게 일어나서 많이는 못 했다..
- 오브젝트 읽기
   1. 템플릿 메소드 패턴 🚩
- 6주차 과제 인증 부분 인터셉터 적용
   1. `product` 경로에만 적용

## **9월 셋 째주 회고**

1. 스프링 읽기 모임, 오브젝트 읽기 모임, 알고리즘 스터디, 코딩 인터뷰 완전 분석 스터디... 읽어야 할 책들도 너무 많고 풀어야 할 문제도 너무 많아서 과제에 집중을 못한 것 같다
2. 과제도 재밌고 읽기 모임도 재밌어서 알고리즘 스터디를 한 달정도 쉬어야 할 것 같다
3. 자비스앤빌런즈 코테 5문제를 다 풀어서 기대된다!!

### 코드숨 6주차 과제 `JWT를 활용한 인증 구현하기`

1. **JJWT** 라이브러리를 사용하여 인코딩, 디코딩을 통해 사용자 인증하기
2. 로그인 실패 시 
   - UserNotFoundException
   - WrongPasswordException
3. 인터셉터를 추가하여 `product`경로 `GET`메서드를 제외하고 JWT 인증을 적용 시켰다
4. `@Value("${jwt.secret}") String secret`
   - application.yml에 있는 속성 정보 사용하기
5. Request에서 **헤더** Authorization  토큰 값만 꺼내기
6. [빈 검증 실패 시 에러 메세지 커스텀하기](https://github.com/CodeSoom/spring-week6-assignment-1/pull/70/commits/042eaaacc88f0ac16f0095e227c2463294421f0a)
   1. 위의 방법도 있고 **Advice**에 예외`ConstraintViolationException.class`를 정의해서 잡는 방법도 있다
7. JwtUtil 단위 테스트에서는 디코딩이 잘 되는데 왜 Product 통합 테스트에서는 예외가 발생할까..?
   - **테스트 코드에서 사용한 Secret 과 서버에서 사용한 Secret키가 달랐다....**

<br>

**느낀 것**
{: .fh-default .fs-5 }

1. JWT의 **Header** , **Payload** , **Signature** 에 대해 확실하게 알게 되었다
2. 이번 주 [과제 마지막 리뷰](https://github.com/CodeSoom/spring-week6-assignment-1/pull/70#issuecomment-1250417164)에서 `특정 도메인 서비스를 위한 한 가지의 기능만 가진 인터페이스` 얘기를 해주셨다
   1. 함수형 인터페이스 얘기도 해주셨는데 자바 8을 겉핥기 식으로 읽어서 다음 과제에서도 이어서 얘기하고 싶다 

<br>

1. [Java-JWT](https://github.com/jwtk/jjwt)
2. [`mozilla` Authorization](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization)
3. **JWT** [RFC7519](https://www.rfc-editor.org/rfc/rfc7519)
   - [`velopert` [JWT] JSON Web Token 소개 및 구조](https://velopert.com/2389)
   - [`Awdsd` JWT 저장소에 대한 고민(feat. XSS, CSRF)](https://cjw-awdsd.tistory.com/48)
   - [`baeldung` SRF With Stateless REST API](https://www.baeldung.com/csrf-stateless-rest-api#1-credentials-are-not-persisted)
   - [세션 기반 인증과 토큰 기반 인증 (feat. 인증과 인가)](https://hudi.blog/session-based-auth-vs-token-based-auth/)
   - [토근 기반 인증에서 bearer는 무엇일까?](https://velog.io/@cada/%ED%86%A0%EA%B7%BC-%EA%B8%B0%EB%B0%98-%EC%9D%B8%EC%A6%9D%EC%97%90%EC%84%9C-bearer%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C) 
   - [JWT (JSON Web Token) 간단히 훑어보기](https://www.youtube.com/watch?v=7abbNwuCXbg&ab_channel=Taehoon)
   - [JSON Web Token이 가진 한계점들](https://www.youtube.com/watch?v=THFmV5LPE6Y&ab_channel=Taehoon)
     - **Token Expired Issue** : 순수하게 JWT만 사용하여 인증을 처리하게 된다면 다중 로그인 상황을 구분할 수가 없다
     - **When JWT is stolen..** : JWT가 유출되면 위험하다
4. [`baeldung` Custom Error Message Handling for REST API](https://www.baeldung.com/global-error-handler-in-a-spring-rest-api)
5. [REST-assured](https://github.com/rest-assured/rest-assured)

### [토프링 읽기 모임 2주차](https://github.com/jdalma/tobyspringin5/wiki/%ED%86%A0%ED%94%84%EB%A7%81-%EC%9D%BD%EA%B8%B0-%EB%AA%A8%EC%9E%84#2%EC%A3%BC%EC%B0%A8-%EB%AA%A8%EC%9E%84-%ED%85%8C%EC%8A%A4%ED%8A%B8)

### [오브젝트 읽기 모임 1주차](https://github.com/jdalma/book-object/wiki/%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8#1%EC%A3%BC%EC%B0%A8-%EC%8A%A4%ED%84%B0%EB%94%94-%EC%A7%88%EB%AC%B8)

***

## 09.19 (월)

**6주차 과제에서 인증을 인터셉터를 사용해서 했는데 이번엔 `스프링 시큐리티`에서 해보자**<br>

- 스프링 시큐리티 의존성을 추가하면 웹 접속 시 자동으로 로그인 화면이 생성된다
   - 우리는 필요 없으니 제거하자
- 스프링 시큐리티를 직접 구현하기는 힘드니 제공하고 있는 추상화 클래스[(`WebSecurityConfigurerAdapter`)](https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/config/annotation/web/configuration/WebSecurityConfigurerAdapter.html)를 사용하자
- [`MDN` CSRF](https://developer.mozilla.org/en-US/docs/Glossary/CSRF) , [`Wikipedia` CSRF](https://en.wikipedia.org/wiki/Cross-site_request_forgery)
   - **신뢰할 수 있는 사용자를 가장하여 웹사이트에 원치 않는 명령을 보내는 공격**

<br>

- **JWT 인증 필터**를 구현하여 스프링 시큐리티에 등록하자
- 필터를 처음부터 구현하지 않고 `BasicAuthenticationFilter`를 상속받아 사용했다 
  - `BasicAuthenticationFilter` : HTTP 요청의 Authorization 헤더를 처리하여 SecurityContextHolder에 처리한 결과를 담습니다.
  - `AuthenticationManager` : AuthenticationManager는 Spring Security의 인증 필터를 정의할 수 있는 API입니다.
- **필터는 서블릿 단에서 처리되기 때문에 스프링 어드바이스에서 잡을 수 없다.**
  - 아래와 같이 `authenticationFilter`에서 토큰을 분석하는데 해당 필터에서 **InvalidTokenException**이 발생할 수 있기 때문에 해당 예외를 잡아주는 필터가 더 필요하다.
  - `authenticationErrorFilter`라는 전처리기 필터를 추가해서 잡아주자.

<div class="code-example" markdown="1">
**SecurityJavaConfig.class**
</div>

```java
@Override
public void configure(HttpSecurity http) throws Exception {
   Filter authenticationFilter = new JwtAuthenticationFilter(authenticationManager(), authenticationService);
   Filter authenticationErrorFilter = new AuthenticationErrorFilter();

   http.csrf().disable()
            .addFilter(authenticationFilter)
            // authenticationFilter를 필터로 등록
            // authenticationFilter의 전처리 필터 authenticationErrorFilter를 등록
            .addFilterBefore(authenticationErrorFilter , JwtAuthenticationFilter.class);
}
```

<br>

- **필터에서 토큰을 분석하고 아래와 같이 분석된 정보를 컨트롤러에서도 사용할 수 있게 담아주자**
  - 컨트롤러에서는 **Authentication** 타입을 받아주면 사용할 수 있다
  
<div class="code-example" markdown="1">
**JwtAuthenticationFilter.class**
</div>

```java
   ...

   SecurityContext context = SecurityContextHolder.getContext();
   context.setAuthentication({Authentication});

   ...
```

- **Authentication** 타입의 객체 만들기
  - [`Spring Docs` Authentication](https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/core/Authentication.html) 인터페이스를 구현하지 말고 [`Spring Docs` AbstractAuthenticationToken](https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/authentication/AbstractAuthenticationToken.html) 추상화 클래스를 상속받자

<br>

- **@EnableGlobalMethodSecurity**
  - 어노테이션 기반의 보안을 적용할 수 있도록 해주는 어노테이션이다.
  - `prePostEnabled` 속성을 `true`로 설정하면 우리의 메서드에 **PreAuthorize 어노테이션을 사용하여 Role기반의 제약을 사용할 수 있다.**
  - [`Spring Reference` Spring Security](https://docs.spring.io/spring-security/reference/)
  - [`Spring Reference` Access Control using @PreAuthorize and @PostAuthorize](https://docs.spring.io/spring-security/reference/servlet/authorization/expression-based.html#_access_control_using_preauthorize_and_postauthorize)
- 위의 설정을 따로 해주면 **403 Forbidden** 상태가 반환된다
- 그럼 이 상태를 그대로 반환할 것인지? 아니면 커스텀할 것인지? 결정하는 것
   - 아래와 같이 `Authentication` 관련 에러들은 뭐든지 `HttpStatus.UNAUTHORIZED` 이걸로 바꿀 수 있다

<div class="code-example" markdown="1">
**SecurityJavaConfig.class**
</div>

```java
@Override
public void configure(HttpSecurity http) throws Exception {
   Filter authenticationFilter = new JwtAuthenticationFilter(authenticationManager(), authenticationService);
   Filter authenticationErrorFilter = new AuthenticationErrorFilter();

   http.csrf().disable()
            .addFilter(authenticationFilter)
            .addFilterBefore(authenticationErrorFilter , JwtAuthenticationFilter.class)
            .exceptionHandling()
            .authenticationEntryPoint(new HttpStatusEntryPoint(HttpStatus.UNAUTHORIZED));
}
```

<br>

- [`Wikipedia` Bcrypt](https://en.wikipedia.org/wiki/Bcrypt)
  - 암호화된 메시지를 읽을 수 있도록 다시 평문으로 변환하는 것을 복호화라고 부른다. 
  - 그런데 복호화를 할 수 없는 암호화가 존재한다. 
  - 가장 대표적인 예가 **bcrypt**다. 
  - 사용자의 비밀번호를 데이터베이스에 저장할 때 주로 쓰인다. 
  - 한번 암호화된 비밀번호는 복호화 할 수 없어 원본 비밀번호를 알 수 없다.
- **해시 함수**
  - 정해지지 않은 길이의 문자열을 입력받아 `고정된 크기의 결괏값`을 출력하는 함수이다.
  - 단방향 함수(one-way function) 여야 한다. 
  - 즉 메시지 `m`을 알면 `h(m)`을 구하기는 쉽지만, `h(m)`을 을 만족하는 `x`를 찾는 것은 구할 수 없어야 한다.
  - **어떤 값을 계산할 수 있지만 그 역을 구하는 것은 어려운 함수를 말한다.**
- **충돌 저항성(collision resistance)**
  - 충돌이란 두 개의 서로 다른 입력 m1과 m2가 있을 때 `h(m1) = h(m2)`가 되는 상황을 말한다. 
  - 해시 함수의 입력은 무한하므로, 이와 같은 충돌을 수없이 만들 수 있다. 
  - 그래서 해시 함수에 완벽한 충돌 회피란 없다.
- **역상 저항성**
  - 해시 함수의 결과를 이미 알고 있다. 그때 이 결과를 만드는 입력값 m을 찾는 것이 얼마나 어려운지를 나타낸다.
- **제 2 역상 저항성**
  - 입력값 m을 이미 알고 있는 상태에서 `h(m) = x`을 만족하는 **x를 얼마나 찾기 쉬운지**를 나타낸다.

## 09.20 (화)

- [스프링 시큐리티 설정](https://jdalma.github.io/docs/algorithmTheory/httpSecurity/) 정리
- [공통으로 제공하는 내장 표현식](https://jdalma.github.io/docs/algorithmTheory/httpSecurity/#preauthorize-%EB%B0%8F-postauthorize%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%9C-%EC%95%A1%EC%84%B8%EC%8A%A4-%EC%A0%9C%EC%96%B4) 정리
- 스프링 2장 읽기

## 09.21 (수)

- [`johngrib` OAuth](https://johngrib.github.io/wiki/oauth/)
- [`buzzvill` 멀티리포 vs 모노리포](https://tech.buzzvil.com/handbook/multirepo-vs-monorepo/)
- [`Spring Docs` MockMvcResultMatchers](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/test/web/servlet/result/MockMvcResultMatchers.html)
  - `jsonPath()`
  - `handler()`

### 프로그래머스 주문 API 과제

1. **상품** 요청에 성공한다면 응답에 `success` , `erorr` 필드가 포함되어야 한다.
   - `ApiUtils.success()` static 메소드를 사용해서 반환하면 된다.
2. 로그인 시 헤더에 토큰 담아주기
   - `public class JwtAuthenticationToken extends AbstractAuthenticationToken`
3. [Spring Security에서 GrantedAuthority vs Role](https://www.baeldung.com/spring-security-granted-authority-vs-role)
4. [`Spring Reference` SecurityContextHolder](https://docs.spring.io/spring-security/reference/servlet/authentication/architecture.html#servlet-authentication-securitycontextholder)

### 종립님 강연 ⭐️

1. 자주 사용하는 것 자세하게
   - 내가 쓰는 라이브러리 뜯어봐라
   - ArrayList의 사이즈는 왜 1.5배로 증가할까? *이분 탐색과 관련있다*
   - GC의 Young Gen , Old Gen 오랫만에 다시 들었다
   - 스택과 **프레임**
   - 데이터간 메모리 위에서 오염을 막는 것
2. 종립님 블로그 랜덤 읽기 버튼
   - 텀을 두고 반복 읽기
3. 공부할 때 1차 창작자의 글 또는 책을 읽어라
   - **매우 공감**
   - RFC 또는 JLS 봐라
   - [**생각하는 프로그래밍**](http://www.kyobobook.co.kr/product/detailViewKor.laf?mallGb=KOR&ejkGb=KOR&barcode=9788966260997) `퀵 소트 알고리즘 공동 저술자`
   - [**자바 병렬 프로그래밍**](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=2354267) 
4. 알고리즘에 집중 하지마라
   - 필요한 만큼만 해라
5. 면접은 가기 싫은 순으로 많이 봐라
   - 긍정적인 에너지를 보이려고 노력해라


## 09.22(목)

- Authorization Basic , Bearer [정리](https://jdalma.github.io/docs/algorithmTheory/authorization/)
- [`jojoldu` 테스트 픽스처 올바르게 사용하기](https://jojoldu.tistory.com/611)
  - **절대 테스트 메소드를 이해하기 위해 다른 부분을 찾아보게 만들어선 안된다.**
  - 테스트를 수정해도 **다른 테스트에 영향을 주어서는 안되게 하는 것이 좋은 테스트의 기본조건**이다.
- **DozerMapper 제거**
  - DozerMapper는 더 이상 지원되지 않는 라이브러리 이다.


## 09.23(금)

- 오브젝트 2장 다 읽고 3장 시작
- **JwtAuthenticationFilter** Java Doc 작성
  - BasicAuthenticationFilter는 "HTTP 요청의 BASIC 권한 부여 헤더를 처리하여 결과를 SecurityContextHolder 에 넣습니다." 그럼 지금 과제에서 헤더는 `Bearer`이 아니라 `Basic`을 써야하는거 아닌가... [`RFC1945 section11.1` Basic Authentication Scheme](https://www.rfc-editor.org/rfc/rfc1945#section-11.1)
  - [`Spring Docs` OncePerRequestFilter](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/filter/OncePerRequestFilter.html) 중요!!

<br>

1. `userId -1`을 관리자로 지정
2. User 엔티티에 enum `role` 필드 추가
3. 사용자 생성 시 기본 사용자는 `USER`로 저장
4. JWT 페이로드에 `userId`와 `role` 정보를 같이 인코딩
5. 사용자 또는 상품 도메인 접근 시 JWT에 담겨 있는 `role`정보를 확인해서 인가가 가능한지 구분