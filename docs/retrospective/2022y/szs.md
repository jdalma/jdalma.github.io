---
layout: default
title: 자비스앤빌런즈 과제 후기
nav_order: 999
parent: 2022년
grand_parent: ⏪ 회고
---
{: .no_toc }

<details open markdown="block">
  <summary>
    Table of contents
  </summary>
  {: .text-delta }
1. TOC
{:toc}
</details>

---


# **과제**

## **1.** `DTO`는 `Controller`계층에서만 사용
`Service`계층은 요청과 응답 DTO를 의존하지 않게 했습니다.<br>
`DTO ↔︎ Entity`매핑 의 책임은 `Controller`에게 있다고 판단하였습니다.<br>
`요청 DTO → Entity`로 변경할 때는 `toXXX()` 규칙으로 작성하였고,<br>
`Entity → 응답 DTO`로 변경할 때는 응답 DTO에 스태틱 팩토리 메소드 `of()`로 작성하였습니다.<br>
- Entity가 DTO를 모르게 하고 싶었습니다

## **2.** 롬복 추가
`DTO`를 불변클래스로 만들기 위해 `Setter`를 쓰지 않고 `@Builder`를 사용하였습니다.<br>
롬복에서 제공하는 생성자 관련 어노테이션은 사용하지 않았으며 <br>
- 클래스의 필드 순서가 바뀌거나 수정되면 기존 생성자에도 반영되기 때문에 문제 생길 확률이 높다
- 순서가 바뀌었지만 타입이 똑같아 컴파일 에러가 나지 않는 큰 문제가 생길 수도 있다
`@Builder`를 클래스 레벨에 작성하지 않고 생성자 메소드 레벨에 작성하였습니다.<br>
- 필드들이 `final`로 선언되어 있고 `private`생성자를 이미 작성했기 때문에 클래스 레벨에 작성해도 큰 문제는 없다
- 필드가 수정되면 바로 반영되는 문제 정도?
`Entity`객체에도 가독성을 위해 `@Builder`를 사용하였습니다.<br>

## **3.** 입출금 기록 동시성 문제
`@Transactional` + `synchronized`로는 트랜잭션 동시성을 해결할 수 없다
- `@Transactional`은 프록시로 동작하기 때문에 여러 스레드에 의해 트랜잭션이 열려버리고 `synchronized 메소드`만 동기화 상태이기 때문에 근본적인 문제는 해결되지 않는다
누적 잔액을 관리하는 것 이였다면 DB의 원자적 연산 기능도 가능했을까?<br>

1. 낙관적인 락을 사용하는 방법
   - `Entity`에 `Version`필드를 추가하고 락 획득에 실패한다면 계속 재시도 한다
   - 경쟁상태에 자주 놓이게 되면 계속 재시도하기 때문에 부하가 높다
2. 비관적인 락을 사용하는 방법
   - 해당 row를 잠금을 걸고 다른 트랜잭션들은 락이 풀리길 무한정 기다린다
   - 해당 과제에서는 해당 메소드의 트랜잭션은 항상 새로 시작하게 했고, 시간 초과는 5초로 했다
   - DB에도 시간을 지정하여 특정시간 이상 락을 잡고 있으면 해제할 수 있다
   - 경쟁상태에 자주 놓이는 상황이라면 효율적이다
3. Named 락을 사용하는 방법
   - 세션 기준으로 락을 건다
   - 트랜잭션이 해제될 때 자동으로 락이 풀리지 않는다
4. Redis의 라이브러리
   - **Lettuce**
     - `spin lock` 방식
       - 단점
         - 무한 루프를 돌며 최대한 다른 스레드에게 CPU를 양보하지 않는다
         - 다른 스레드가 락을 오래가지고 있는다면 다른 블록킹된 스레드는 CPU를 쓸데 없이 낭비한다
       - 장점 : 문맥 교환을 줄여 CPU의 부담을 덜어준다
     - 락을 획득하기 위해 계속 재시도를 한다
     - 재시도 로직을 추가 작성하여야 한다
     - Redis에 부하가 갈 수 있다
   - **Redisson**
     - `pub-sub` 방식
     - 별도의 재시작 로직을 작성하지 않아도 된다
     - 자신이 점유하고 있는 락을 해제할 때 같은 채널에 있는 스레드에게 락을 획득하라고 말한다
   - 뮤텍스 vs 세마포어
     - **차이는 동기화의 개수이다**
     - 뮤텍스 : 한 개의 자원을 잡고 한 명씩 넘기는 것
     - 세마포어 : 여러 개의 자원을 잡고 한 명씩 넘기는 것

## **4.** 게좌와 입출금 기록 조인 전략
`transactions`가 연관관계의 주인입니다<br>
- `account_id`와 `user_id`를 가지고 있기 때문에
**단일 계좌를 조회할 때 해당 계좌에 대한 입출금 기록**을 보기위함이니 엔티티 상으로는 `accounts`가 `transactions`를 찾아가야 합니다.<br>
입출금 기록이 없어도 계좌는 조회되어야 하니 `outer join`이 필요하여

1. `fetch join`은 `inner join`이니 제외
2. `@NamedEntityGraph`는 선호도가 다를 것 같은데 개인적으로는 엔티티에도 작성하고 레포지토리에도 추가적으로 작성해야 해서 번거롭다고 느꼇습니다
   - 객체간 탐색이 복잡해진다면 사용할 것 같습니다
3. `@EntityGraph`로 해결했습니다

## **5.** 이자율 전략 패턴 적용
이자율은 요구사항이 자주 바뀔 것 같아 이 부분을 전략 패턴을 적용하기 좋겠다는 생각이 들었습니다.<br>
클라이언트인 `Service`가 `계좌 Entity`에게 잔액을 계산해달라는 메시지를 전송할 때 사용할 전략을 정해서 넘겨주도록 작성했습니다.<br>

## **6.** 책임
객체의 책임들을 고민하며 개발하였습니다.<br>
데이터를 요구하는 것이 아니라 작업을 요청하도록 했습니다.<br>
`입출금 기록 Entity`에게 `type`을 달라고 하는것이 아니라 입출금 구분을 해달라고 하거나,<br>
`계좌 Entity`에게 입출금 기록 최대 ID를 계산해 달라고 하거나, 잔액을 계산해달라고 작업을 요청하게 작성했습니다.<br>
- JPA를 사용하니 `계좌 Entity`에게 잔액을 계산해달라고 하는 것이 가능했습니다.
- mybatis였다면 Service에서 계산해야 했지 않을까 생각했습니다

# **개선사항**

1. `계좌 Entity`에 단순 필드 보관용으로 `@Transient`를 사용했는데 이 어노테이션에 대해 어떻게 생각하시는지?
   - 엔티티 접근 방식이 `@Id`위치에 따라 달라지니 문제가 생길 수 있는 여지가 있다고 생각햇다
   - DTO를 추가해야 했을까?
2. 입출금 기록 동시성을 해결하기 위해 비관적인 잠금을 사용했는데 조회용 테이블이 따로 필요하다
   - 입출금 기록이 저장될 때 해당 계좌 로우를 잠금하여 버리기 때문에 조회가 지연될 것 이다
3. 계좌의 잔액을 구하는 방법
   - 현재 한 계좌의 모든 기록을 순회하며 계산하는데 `계좌 Entity`에 가장 최신 동기화 정보를 연관관계로 추가하여 계산하면 더 효율적일 것이다
