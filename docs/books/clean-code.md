---
layout: default
title: Clean Code
parent: Books
nav_order: 1
---
## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}
---
# **1장. 깨끗한 코드**
> **좋은 코드를 사수하는 일은 바로 프로그래머들의 책임이다.**
> **세세한 사항까지 꼼꼼하게 신경 써라.**
> - 오류처리
> - 메모리 누수
> - 경쟁 상태
> - 일관성 없는 명명법...

- 의존성은 최소 이며 각 의존성을 명확히 정의한다.
- **오류는 명백한 전략에 의거해 철저히 처리**한다.
- **나쁜 코드는 나쁜 코드를 유혹한다.**
  - 나쁜 코드는 너무 많은 일을 하려 애쓰다가 의도가 뒤섞이고 목적이 흐려진다.
  - 각 함수와 클래스와 모듈은 주변 상황에 현혹되거나 오염되지 않은 채 한길만 걷는다.
  - 특정 목적을 달성하는 방법은 (여러가지가 아니라) 하나만 제공한다.
- **켄트 벡이 제안한 단순한 코드 규칙**
  - 모든 테스트를 통과한다.
  - 중복이 없다.
  - 시스템 내 모든 설계 아이디어를 표현한다.
  - 클래스 , 메서드 , 함수 등을 최대한 줄인다.
- 객체가 여러 기능을 수행한다면 여러 객체로 나눈다.
- 메서드가 여러 기능을 수행한다면 **메서드 추출(Extract Method) 리팩토링 기법**을 적용해 기능을 명확히 기술하는 메서드 하나와 기능을 실제로 수행하는 메서드 여러 개로 나눈다.
- 초반부터 간단한 추상화 고려하기

## 1. 우리는 저자다.
- Javadoc에서 `@Author`필드는 저자를 소개한다.
- 저자에게는 독자와 잘 소통할 **책임**도 있다.
- 저자의 노력을 보고 판단을 내릴 독자가 있다는 사실을 기억하자.
- 주변 코드가 읽기 쉬우면 새 코드를 짜기도 쉽다.

## 2. 보이스카우트 규칙
- `캠프장은 처음 왔을 때보다 더 깨끗하게 해놓고 떠나라`
- 잘 짠 코드가 전부가 아니다. 시간이 지나도 언제나 깨끗하게 유지해야 한다.
- 한꺼번에 많은 시간과 노력을 투자해 코드를 정리할 필요가 없다.
  - 변수 이름 하나를 개선하고 ,
  - 조금 긴 함수 하나를 분할하고 ,
  - 약간의 중복을 제거하고 ,
  - 복잡한 if문 하나를 정리하면 충분하다.

## 3. 프리퀄과 원칙
- [PPP 책](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=108856171)은 객체 지향 설계의 원칙을 설명하고 전문 개발자들이 사용하는 실무 기법을 소개한다. 이 책에서 하는 이야기를 이어간다.

# **2장. 의미 있는 이름**

## 1. 의도를 분명히 밝혀라.
- 좋은 이름을 지으려면 시간이 걸리지만 좋은 이름으로 절약하는 시간이 훨씬 더 많다.
- **변수(혹은 함수나 클래스)의 존재 이유는 ?**
- **수행 기능은 ?**
- **사용 방법은 ?**
- **따로 주석이 필요하다면 의도를 분명히 드러내지 못했다는 말이다.**
- **코드 맥락이 코드 자체에 명시적으로 드러나게 해야한다.**

## 2. 그릇된 정보를 피하라.
- 그릇된 단서는 코드의 의미를 흐린다.
- **나름대로 널리 쓰이는 의미가 있는 단어를 다른 의미로 사용해도 안 된다.**
  - ex) 실제 List가 아니지만 accountList라고 명명하는 것
  - accountGroup , bunchOfAccounts , Accounts ... 라고 명명하는게 옳다
- **서로 흡사한 이름을 사용하지 않도록 주의한다.**
  - 일관성이 떨어지는 표기법은 **그릇된 정보**다.

## 3. 의미 있게 구분하라.
- 컴파일러나 인터프리터만 통과하려는 생각으로 코드를 구현하는 프로그래머는 스스로 문제를 일으킨다.
- **연속된 숫자를 덧붙이거나 [불용어](https://bkshin.tistory.com/entry/NLP-3-%EB%B6%88%EC%9A%A9%EC%96%B4Stop-word-%EC%A0%9C%EA%B1%B0)**를 추가하는 방식은 적절하지 못하다.
- `Info` 나 `Data`는 a , an , the,와 마찬가지로 의미가 불분명한 불용어다.
- 에를 들어 모든 지역변수는 a를 사용하고 모든 함수 인수는 the를 사용해도 되겠다.
- 코드를 읽다가 `Customer`라는 클래스와 `CustomerObject`라는 클래스의 발견하게되면 차이를 알 수 있는가?
  - moneyAmount <-> money
  - customerInfo <-> customer
  - accountData <-> account
  - theMessage <-> message
  - 서로 구분이 안된다.

## 4. 발음하기 쉬운 이름을 사용하라

```java
class DtaRcrd102{
  private Date genymdhms;
  private Date modymdhms;
  private final String pszqint = "102";
  ...
}
```

```java
class Customer{
  private Date generationTimestamp;
  private Date modificationTimestamp;
  private final String recordId = "102";
  ...
}
```

- 2번째 코드는 지적인 대화가 가능하다.


## 5. 검색하기 쉬운 이름을 사용하라
- **문자 하나를 사용하는 이름과 상수는 텍스트 코드에서 쉽게 눈에 띄지 않는다는 문제점이 있다.**
- 이런 관점에서 긴 이름이 짧은 이름보다 좋다.
- 검색하기 쉬운 이름이 상수보다 좋다.

```java
for(int j = 0 ; j < 34 ; j++){
  s += (t[j] * 4) / 5;
}
```

```java
int realDaysPerIdealDay =4;
const int WORK_DAYS_PER_WEEK = 5;
int sum = 0;
for (int j = 0 ; j < NUMBER_OF_TASKS ; j++){
  int realTaskDays = taskEstimate[j] * realDaysPerIdealDay;
  int realTaskWeeks = (realTaskDays / WORK_DAYS_PER_WEEK);
  sum += realTaskWeeks;
}
```
- **이름을 의미있게 지으면 함수가 길어진다.**
- 하지만 `WORK_DAYS_PER_WEEK`을 찾기가 얼마나 쉬운지 생각해 보라.

## 6. 인코딩을 피하라
- **유형이나 범위정보 까지 인코딩에 넣으면 그만큼 이름을 해독하기 어려워진다.**
- 인코딩한 이름은 발음하기도 어려우며 오타가 생기기도 쉽다.

### **헝가리식 표기법**
- 옛날에는 컴파일러가 타입을 점검하지 않았으므로 프로그래머에게 타입을 기억할 단서가 필요했다.
- 객체는 강한타입 `Strongly-typed` 이며 , IDE는 코드를 컴파일하지 않고도 타입 오류를 감지할 정도로 발전했다.
- 따라서 이제는 **헝가리식 표기법이나 기타 인코딩 방식이 오히려 방해가 될뿐이다.**
```
접두어 데이터 타입
b - byte, boolean
n - int, short
i - int, short (주로 인덱스로 사용)
c - int, short (주로 크기로 사용)
l - long
f - float
d, db - double
ld - long double
...
```

### **멤버 변수 접두어**
- 이제는 멤버 변수에 m_이라는 접두어를 붙일 필요도 없다.
- **클래스와 함수는 접두어가 필요없을 정도로 작아야 마땅하다.**

### **인터페이스 클래스와 구현 클래스**
- 때로는 인코딩이 필요한 경우도 있다.
- **인터페이스 이름은 접두어를 붙이지 않는 편이 좋다고 생각한다.**
  - 옛날 코드에서 많이 사용하는 접두어 `I`는 주의를 흐트리고 과도한 정보를 제공한다.
  - 대부분 구현클래스 이름에 접두어를 붙인다.
  - `TestServiceImpl`

## 7. 자신의 기억력을 자랑하지 마라
- **📌 명료함이 최고**
- **독자가 코드를 읽으면서 변수 이름을 자신이 아는 이름으로 변환해야 한다면 그 변수 이름은 바람직하지 못하다.**
  - 루프에서 반복횟수를 세는 변수 i,j,k 까지는 괜찮다.

## 8. 클래스 이름
- **클래스 이름과 객체 이름은 명사나 명사구가 적합하다.**
  - `Customer` , `WikiPage` , `Account` , `AddressParser` 등이 좋은 예다.
  - **`Manager` , `Processor` , `Data` , `Info` 등과 같은 단어는 피하고 , 동사는 사용하지 않는다.**

## 9. 메서드 이름
- **메서드 이름은 동사나 동사구가 적합하다.**
  - `postPayment` , `deletePage` , `save` 등이 좋은 예다.
- `Accessor`(접근자) , `Mutator`(변경자) , `Predicate`(조건자)는 **javabean표준**에 따라 `get` , `set` , `is`를 붙인다.
- 📌`Constructor`(생성자)를 `overload`(중복정의)할 때는 **정적 팩토리 메서드**를 사용한다.
  - 메서드는 인수를 설명하는 이름을 사용한다.
  - `Complex fulcrumPoint = Complex.FromRealNumber(23.0);`👍
  - `Complex fulcrumPoing = new Complex(23.0);`👎

## 10. 기발한 이름은 피하라
- **재미난 이름보다 명료한 이름을 선택하라**
- 이름이 너무 기발하면 저자와 유머 감각이 비슷한 사람만 , 그리고 농담을 기억하는 동안만, 이름을 기억한다.
- **특정 문화에서만 사용하는 농담은 피하는 편이 좋다. 의도를 분명하고 솔직하게 표현하라**

## 11. 한 개념에 한 단어를 사용하라
- **추상적인 개념 하나에 단어 하나를 선택해 이를 고수한다.**
  - 예를 들어 , 똑같은 메서드를 클래스마다 `fetch` ,  `retrieve` , `get`으로 제가각 부르면 혼란스럽다.
- 메서드 이름은 독자적이고 **일관적이어야 한다.**
  - 그래야 주석을 뒤져보지 않고도 개발자가 올바른 메서드를 선택할 수 있다.
- 마찬가지로, 동일 코드 기반에 **Controller** , **Manager** , **Driver**를 섞어쓰면 혼란스럽다.
  - `DeviceManager`와 `ProtocolController`는 근본적으로 어떻게 다른가?
  - 어째서 둘 다 `Controller`가 아닌가?
  - 어째서 둘 다 `Manager`가 아닌가?
  - 정말 둘 다 `Driver`가 아닌가?
  - **이름이 다르면 독자는 당연히 클래스도 다르고 타입도 다르다고 생각한다.**

> ✋ [get , retrieve , fetch](https://nassol.tistory.com/3)
> - **Get** 
>   - to **get back** something that **you had before**
>   - 전에 **가졌던** 사물을 다시 돌려 받다.
> - **Retrieve**
>   - **(formal)** to get back something after you have **put it** somewhere
>   - **어딘가에 두었던 것을** 그 후에, 다시 가져오다.
> - **Take**
>   - **to go** to a place and **take** someone tor something from there
>   - 어떤 장소로 **가서** 사람이나 물건을 그곳에서 **가져오는 것**
> - **Fetch**
>   - **(British)** **to go** to get someone or something that **you need** and **bring** them back
>   - **필요로 하는 것을** 가지러 **가서 가져** 오다.

## 11. 말장난을 하지 마라
- **한 단어를 두 가지 목적으로 사용하지 마라.**
- **다른 개념에 같은 단어를 사용한다면 그것은 말장난에 불과하다.**
- 예를 들어,
  - 여러 클래스에 `add`라는 메서드가 생겼다.
  - 같은 맥락이 아닌데도 **일관성**을 고려해 `add`라는 단어를 선택한다.
  - 지금까지 구현한 `add`메서드는 모두가 기존 값 두 개를 더하거나 이어서 새로운 값을 만든다고 가정하자.
  - *새로 작성하는 메서드는 집합에 값 하나를 추가한다.*
  - **이 메서드를 `add`라 불러도 괜찮을까?**
  - 맥락이 다르므로 `insert`나  `append`라는 이름이 적당하다.
    - **새 메서드를 `add`라 부른다면 이는 말장난이다.**
- 📌의미를 해독할 책임이 독자에게 있는 논문 모델이 아니라 의도를 밝힐 책임이 저자에게 있는 잡지 모델이 바람직하다.

## 12. 해법 영역에서 가져온 이름을 사용하라
- **전산 용어 , 알고리즘 이름 , 패턴 이름 , 수학 용어 등을 사용해도 괜찮다.**
- 모든 이름을 **문제 영역 (domain)**에서 가져오는 정책은 현명하지 못하다.
- 같은 개념을 다른 이름으로 이해하던 동료들이 매번 고객에게 의미를 물어야하기 때문이다.

## 13. 문제 영역에서 가져온 이름을 사용하라
- **적절한 *개발 용어*가 없다면 문제 영역에서 이름을 가져온다.**
- 우수한 개발자와 설계자라면 **해법 영역**과 **문제 영역**을 구분할 줄 알아야 한다.
- **문제 영역 개념과 관련이 깊은 코드라면 문제 영역에서 이름을 가져와야 한다.**

## 14. 의미 있는 맥락을 추가하라
- **대다수의 이름들의 의미들을 분명히 하기 위해 클래스 , 함수 , 이름 공간에 넣어 맥락을 부여한다.**
  - 모든 방법이 실패하면 마지막 수단으로 접두어를 붙인다.
  - 예를들어 , `firstName` , `lastName` , `street` , `houseNumber` , `city` , `state` 라는 변수가 있다.
    - **주소라는 사실을 금방 알아채지만 어느 메서드가 `state`변수 하나만 사용한다면 알아챌 수 있을까??**
    - `addr`이라는 접두어를 추가해 `addrState`라 쓰면 맥락이 조금 더 분명해진다.

### 맥락이 불분명한 변수 👎

```java
private void printGuessStatistics(char candidate , int count){
  String number;
  String verb;
  String pluralModifier;
  if(count == 0){
    number = "no";
    verb = "are";
    pluralModifier = "s";
  }
  else if(count == 1){
    number = "1";
    verb = "is";
    pluralModifier = "";
  }
  else {
    number = Integer.toString(count);
    verb = "are";
    pluralModifier = "s";
  }
  String guessMessage = String.format("There %s %s %s%s" , verb , number , candidate , pluralModifier);
  print(guessMessage);
}
```

### 맥락이 분명한 변수 👍

```java
public class GuessStatisticsMessage{
  private String number;
  private String verb;
  private String pluralModifier;

  public String make(char candidate , int count){
    createPluralDependentMessageParts(count);
    return String.format("There %s %s %s%s" , verb , number , candidate , pluralModifier);
  }

  private void createPluralDependentMessageParts(int count){
    if(count == 0){
      thereAreNoLetters();
    }
    else if(count == 1){
      thereIsOneLetter();
    }
    else{
      thereAreManyLetters(count);
    }
  }

  private void thereAreManyLetters(int count){
    number = Integer.toString(count);
    verb = "are";
    pluralModifier = "s";
  }

  private void thereIsOneLetter(){
    number = "1";
    vers = "is";
    pluralModifier = "";
  }

  private void thereAreNoLetters(){
    number = "no";
    verb = "are";
    pluralModifier = "s";
  }
}
```

## 15. 불필요한 맥락을 없애라
- **이름에 불필요한 맥락을 추가하지 않도록 주의한다.**
- `accountAddress` 와 `customerAddress`는 **Address클래스 인스턴스로는 좋은 이름**이지만 **클래스 이름으로는 적합하지 못하다.**

# **3장. 함수**
작게 만들어라!
__ 블록과 들여쓰기
한 가지만 해라!
__ 함수 내 섹션
함수 당 추상화 수준은 하나로!
__ 위에서 아래로 코드 읽기: 내려가기 규칙
Switch 문
서술적인 이름을 사용하라!
함수 인수
__ 많이 쓰는 단항 형식
__ 플래그 인수
__ 이항 함수
__ 삼항 함수
__ 인수 객체
__ 인수 목록
__ 동사와 키워드
부수 효과를 일으키지 마라!
__ 출력 인수
명령과 조회를 분리하라!
오류 코드보다 예외를 사용하라!
__ Try/Catch 블록 뽑아내기
__ 오류 처리도 한 가지 작업이다.
__ Error.java 의존성 자석
반복하지 마라!
구조적 프로그래밍
함수를 어떻게 짜죠?
결론
참고 문헌
# **4장. 주석**
주석은 나쁜 코드를 보완하지 못한다
코드로 의도를 표현하라!
좋은 주석
__ 법적인 주석
__ 정보를 제공하는 주석
__ 의도를 설명하는 주석
__ 의미를 명료하게 밝히는 주석
__ 결과를 경고하는 주석
__ TODO 주석
__ 중요성을 강조하는 주석
__ 공개 API에서 Javadocs
나쁜 주석
__ 주절거리는 주석
__ 같은 이야기를 중복하는 주석
__ 오해할 여지가 있는 주석
__ 의무적으로 다는 주석
__ 이력을 기록하는 주석
__ 있으나 마나 한 주석
__ 무서운 잡음
__ 함수나 변수로 표현할 수 있다면 주석을 달지 마라
__ 위치를 표시하는 주석
__ 닫는 괄호에 다는 주석
__ 공로를 돌리거나 저자를 표시하는 주석
__ 주석으로 처리한 코드
__ HTML 주석
__ 전역 정보
__ 너무 많은 정보
__ 모호한 관계
__ 함수 헤더
__ 비공개 코드에서 Javadocs
__ 예제
참고 문헌
# **5장. 형식 맞추기**
형식을 맞추는 목적
적절한 행 길이를 유지하라
__ 신문 기사처럼 작성하라
__ 개념은 빈 행으로 분리하라
__ 세로 밀집도
__ 수직 거리
__ 세로 순서
가로 형식 맞추기
__ 가로 공백과 밀집도
__ 가로 정렬
__ 들여쓰기
가짜 범위
팀 규칙
밥 아저씨의 형식 규칙
# **6장. 객체와 자료 구조**
자료 추상화
자료/객체 비대칭
디미터 법칙
__ 기차 충돌
__ 잡종 구조
__ 구조체 감추기
자료 전달 객체
__ 활성 레코드
결론
참고 문헌
# **7장. 오류 처리**
오류 코드보다 예외를 사용하라
Try-Catch-Finally 문부터 작성하라
미확인unchecked 예외를 사용하라
예외에 의미를 제공하라
호출자를 고려해 예외 클래스를 정의하라
정상 흐름을 정의하라
null을 반환하지 마라
null을 전달하지 마라
결론
참고문헌
# **8장. 경계**
외부 코드 사용하기
경계 살피고 익히기
log4j 익히기
학습 테스트는 공짜 이상이다
아직 존재하지 않는 코드를 사용하기
깨끗한 경계
참고 문헌
# **9장. 단위 테스트**
TDD 법칙 세 가지
깨끗한 테스트 코드 유지하기
__ 테스트는 유연성, 유지보수성, 재사용성을 제공한다
깨끗한 테스트 코드
__ 도메인에 특화된 테스트 언어
__ 이중 표준
테스트 당 assert 하나
__ 테스트 당 개념 하나
F.I.R.S.T.
결론
참고 문헌
# **10장. 클래스**
클래스 체계
__ 캡슐화
클래스는 작아야 한다!
__ 단일 책임 원칙
__ 응집도Cohesion
__ 응집도를 유지하면 작은 클래스 여럿이 나온다
변경하기 쉬운 클래스
__ 변경으로부터 격리
참고 문헌
# **11장. 시스템**
도시를 세운다면?
시스템 제작과 시스템 사용을 분리하라
__ Main 분리
__ 팩토리
__ 의존성 주입
확장
__ 횡단(cross-cutting) 관심사
자바 프록시
순수 자바 AOP 프레임워크
AspectJ 관점
테스트 주도 시스템 아키텍처 구축
의사 결정을 최적화하라
명백한 가치가 있을 때 표준을 현명하게 사용하라
시스템은 도메인 특화 언어가 필요하다
결론
참고 문헌
# **12장. 창발성(創發性)**
창발적 설계로 깔끔한 코드를 구현하자
단순한 설계 규칙 1: 모든 테스트를 실행하라
단순한 설계 규칙 2~4: 리팩터링
중복을 없애라
표현하라
클래스와 메서드 수를 최소로 줄여라
결론
참고 문헌
# **13장. 동시성**
동시성이 필요한 이유?
__ 미신과 오해
난관
동시성 방어 원칙
__ 단일 책임 원칙Single Responsibility Principle, SRP
__ 따름 정리corollary: 자료 범위를 제한하라
__ 따름 정리: 자료 사본을 사용하라
__ 따름 정리: 스레드는 가능한 독립적으로 구현하라
라이브러리를 이해하라
__ 스레드 환경에 안전한 컬렉션
실행 모델을 이해하라
__ 생산자-소비자Producer-Consumer
__ 읽기-쓰기Readers-Writers
__ 식사하는 철학자들Dining Philosophers
동기화하는 메서드 사이에 존재하는 의존성을 이해하라
동기화하는 부분을 작게 만들어라
올바른 종료 코드는 구현하기 어렵다
스레드 코드 테스트하기
__ 말이 안 되는 실패는 잠정적인 스레드 문제로 취급하라
__ 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자
__ 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있게 스레드 코드를
구현하라
__ 다중 스레드를 쓰는 코드 부분을 상황에 맞게 조율할 수 있게 작성하라
__ 프로세서 수보다 많은 스레드를 돌려보라
__ 다른 플랫폼에서 돌려보라
__ 코드에 보조 코드instrument를 넣어 돌려라. 강제로 실패를 일으키게 해보라
__ 직접 구현하기
__ 자동화
결론
참고 문헌
# **14장. 점진적인 개선**
Args 구현
__ 어떻게 짰느냐고?
Args: 1차 초안
__ 그래서 멈췄다
__ 점진적으로 개선하다
String 인수
결론
# **15장. JUnit 들여다보기**
JUnit 프레임워크
결론
# **16장. SerialDate 리팩터링**
첫째, 돌려보자
둘째, 고쳐보자
결론
참고 문헌
# **17장. 냄새와 휴리스틱**
주석
__ C1: 부적절한 정보
__ C2: 쓸모 없는 주석
__ C3: 중복된 주석
__ C4: 성의 없는 주석
__ C5: 주석 처리된 코드
환경
__ E1: 여러 단계로 빌드해야 한다
__ E2: 여러 단계로 테스트해야 한다
함수
__ F1: 너무 많은 인수
__ F2: 출력 인수
__ F3: 플래그 인수
__ F4: 죽은 함수
일반
__ G1: 한 소스 파일에 여러 언어를 사용한다
__ G2: 당연한 동작을 구현하지 않는다
__ G3: 경계를 올바로 처리하지 않는다
__ G4: 안전 절차 무시
__ G5: 중복
__ G6: 추상화 수준이 올바르지 못하다
__ G7: 기초 클래스가 파생 클래스에 의존한다
__ G8: 과도한 정보
__ G9: 죽은 코드
__ G10: 수직 분리
__ G11: 일관성 부족
__ G12: 잡동사니
__ G13: 인위적 결합
__ G14: 기능 욕심
__ G15: 선택자 인수
__ G16: 모호한 의도
__ G17: 잘못 지운 책임
__ G18: 부적절한 static 함수
__ G19: 서술적 변수
__ G20: 이름과 기능이 일치하는 함수
__ G21: 알고리즘을 이해하라
__ G22: 논리적 의존성은 물리적으로 드러내라
__ G23: If/Else 혹은 Switch/Case 문보다 다형성을 사용하라
__ G24: 표준 표기법을 따르라
__ G25: 매직 숫자는 명명된 상수로 교체하라
__ G26: 정확하라
__ G27: 관례보다 구조를 사용하라
__ G28: 조건을 캡슐화하라
__ G29: 부정 조건은 피하라
__ G30: 함수는 한 가지만 해야 한다
__ G31: 숨겨진 시간적인 결합
__ G32: 일관성을 유지하라
__ G33: 경계 조건을 캡슐화하라
__ G34: 함수는 추상화 수준을 한 단계만 내려가야 한다
__ G35: 설정 정보는 최상위 단계에 둬라
__ G36: 추이적 탐색을 피하라
자바
__ J1: 긴 import 목록을 피하고 와일드카드를 사용하라
__ J2: 상수는 상속하지 않는다
__ J3: 상수 대 Enum
이름
__ N1: 서술적인 이름을 사용하라
__ N2: 적절한 추상화 수준에서 이름을 선택하라
__ N3: 가능하다면 표준 명명법을 사용하
__ N4: 명확한 이름
__ N5: 긴 범위는 긴 이름을 사용하라
__ N6: 인코딩을 피하라
__ N7: 이름으로 부수 효과를 설명하라
테스트
__ T1: 불충분한 테스트
__ T2: 커버리지 도구를 사용하라!
__ T3: 사소한 테스트를 건너뛰지 마라
__ T4: 무시한 테스트는 모호함을 뜻한다
__ T5: 경계 조건을 테스트하라
__ T6: 버그 주변은 철저히 테스트하라
__ T7: 실패 패턴을 살펴라
__ T8: 테스트 커버리지 패턴을 살펴라
__ T9: 테스트는 빨라야 한다
결론
참고 문헌
부록A 동시성 II
클라이언트/서버 예제
__ 서버
__ 스레드 추가하기
__ 서버 살펴보기
__ 결론
가능한 실행 경로
__ 경로 수
__ 가능한 순열 수 계산하기
__ 심층 분석
__ 결론
라이브러리를 이해하라
__ Executor 프레임워크
__ 스레드를 차단하지 않는non blocking 방법
__ 다중 스레드 환경에서 안전하지 않은 클래스
메서드 사이에 존재하는 의존성을 조심하라
__ 실패를 용인한다
__ 클라이언트-기반 잠금
__ 서버-기반 잠금
작업 처리량 높이기
__ 작업 처리량 계산 - 단일스레드 환경
__ 작업 처리량 계산 - 다중 스레드 환경
데드락
__ 상호 배제Mutual Exclusion
__ 잠금 & 대기Lock & Wait
__ 선점 불가No Preemption
__ 순환 대기Circular Wait
__ 상호 배제 조건 깨기
__ 잠금 & 대기 조건 깨기
__ 선점 불가 조건 깨기
__ 순환 대기 조건 깨기
__ 다중 스레드 코드 테스트
__ 스레드 코드 테스트를 도와주는 도구
결론
자습서: 전체 코드 예제
__ 클라이언트/서버 - 단일스레드 버전
__ 클라이언트/서버 - 다중 스레드 버전
