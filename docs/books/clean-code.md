---
layout: default
title: Clean Code
parent: Books
nav_order: 1
---
## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}
---
# **1장. 깨끗한 코드**
> **좋은 코드를 사수하는 일은 바로 프로그래머들의 책임이다.**
> **세세한 사항까지 꼼꼼하게 신경 써라.**
> - 오류처리
> - 메모리 누수
> - 경쟁 상태
> - 일관성 없는 명명법...

- 의존성은 최소 이며 각 의존성을 명확히 정의한다.
- **오류는 명백한 전략에 의거해 철저히 처리**한다.
- **나쁜 코드는 나쁜 코드를 유혹한다.**
  - 나쁜 코드는 너무 많은 일을 하려 애쓰다가 의도가 뒤섞이고 목적이 흐려진다.
  - 각 함수와 클래스와 모듈은 주변 상황에 현혹되거나 오염되지 않은 채 한길만 걷는다.
  - 특정 목적을 달성하는 방법은 (여러가지가 아니라) 하나만 제공한다.
- **켄트 벡이 제안한 단순한 코드 규칙**
  - 모든 테스트를 통과한다.
  - 중복이 없다.
  - 시스템 내 모든 설계 아이디어를 표현한다.
  - 클래스 , 메서드 , 함수 등을 최대한 줄인다.
- 객체가 여러 기능을 수행한다면 여러 객체로 나눈다.
- 메서드가 여러 기능을 수행한다면 **메서드 추출(Extract Method) 리팩토링 기법**을 적용해 기능을 명확히 기술하는 메서드 하나와 기능을 실제로 수행하는 메서드 여러 개로 나눈다.
- 초반부터 간단한 추상화 고려하기

## 1. 우리는 저자다.
- Javadoc에서 `@Author`필드는 저자를 소개한다.
- 저자에게는 독자와 잘 소통할 **책임**도 있다.
- 저자의 노력을 보고 판단을 내릴 독자가 있다는 사실을 기억하자.
- 주변 코드가 읽기 쉬우면 새 코드를 짜기도 쉽다.

## 2.보이스카우트 규칙
- `캠프장은 처음 왔을 때보다 더 깨끗하게 해놓고 떠나라`
- 잘 짠 코드가 전부가 아니다. 시간이 지나도 언제나 깨끗하게 유지해야 한다.
- 한꺼번에 많은 시간과 노력을 투자해 코드를 정리할 필요가 없다.
  - 변수 이름 하나를 개선하고 ,
  - 조금 긴 함수 하나를 분할하고 ,
  - 약간의 중복을 제거하고 ,
  - 복잡한 if문 하나를 정리하면 충분하다.

## 3.프리퀄과 원칙
- [PPP 책](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=108856171)은 객체 지향 설계의 원칙을 설명하고 전문 개발자들이 사용하는 실무 기법을 소개한다. 이 책에서 하는 이야기를 이어간다.

# **2장. 의미 있는 이름**

## 1. 의도를 분명히 밝혀라.
- 좋은 이름을 지으려면 시간이 걸리지만 좋은 이름으로 절약하는 시간이 훨씬 더 많다.
- **변수(혹은 함수나 클래스)의 존재 이유는 ?**
- **수행 기능은 ?**
- **사용 방법은 ?**
- **따로 주석이 필요하다면 의도를 분명히 드러내지 못했다는 말이다.**
- **코드 맥락이 코드 자체에 명시적으로 드러나게 해야한다.**

## 2. 그릇된 정보를 피하라.
- 그릇된 단서는 코드의 의미를 흐린다.
- **나름대로 널리 쓰이는 의미가 있는 단어를 다른 의미로 사용해도 안 된다.**
  - ex) 실제 List가 아니지만 accountList라고 명명하는 것
  - accountGroup , bunchOfAccounts , Accounts ... 라고 명명하는게 옳다
- **서로 흡사한 이름을 사용하지 않도록 주의한다.**
  - 일관성이 떨어지는 표기법은 **그릇된 정보**다.

## 3. 의미 있게 구분하라.
- 컴파일러나 인터프리터만 통과하려는 생각으로 코드를 구현하는 프로그래머는 스스로 문제를 일으킨다.
- **연속된 숫자를 덧붙이거나 [불용어](https://bkshin.tistory.com/entry/NLP-3-%EB%B6%88%EC%9A%A9%EC%96%B4Stop-word-%EC%A0%9C%EA%B1%B0)**를 추가하는 방식은 적절하지 못하다.
- `Info` 나 `Data`는 a , an , the,와 마찬가지로 의미가 불분명한 불용어다.
- 에를 들어 모든 지역변수는 a를 사용하고 모든 함수 인수는 the를 사용해도 되겠다.
- 코드를 읽다가 `Customer`라는 클래스와 `CustomerObject`라는 클래스의 발견하게되면 차이를 알 수 있는가?
  - moneyAmount <-> money
  - customerInfo <-> customer
  - accountData <-> account
  - theMessage <-> message
  - 서로 구분이 안된다.

## 4. 발음하기 쉬운 이름을 사용하라

```java
class DtaRcrd102{
  private Date genymdhms;
  private Date modymdhms;
  private final String pszqint = "102";
  ...
}
```

```java
class Customer{
  private Date generationTimestamp;
  private Date modificationTimestamp;
  private final String recordId = "102";
  ...
}
```

- 2번째 코드는 지적인 대화가 가능하다.


## 5. 검색하기 쉬운 이름을 사용하라
- **문자 하나를 사용하는 이름과 상수는 텍스트 코드에서 쉽게 눈에 띄지 않는다는 문제점이 있다.**
- 이런 관점에서 긴 이름이 짧은 이름보다 좋다.
- 검색하기 쉬운 이름이 상수보다 좋다.

```java
for(int j = 0 ; j < 34 ; j++){
  s += (t[j] * 4) / 5;
}
```

```java
int realDaysPerIdealDay =4;
const int WORK_DAYS_PER_WEEK = 5;
int sum = 0;
for (int j = 0 ; j < NUMBER_OF_TASKS ; j++){
  int realTaskDays = taskEstimate[j] * realDaysPerIdealDay;
  int realTaskWeeks = (realTaskDays / WORK_DAYS_PER_WEEK);
  sum += realTaskWeeks;
}
```
- **이름을 의미있게 지으면 함수가 길어진다.**
- 하지만 `WORK_DAYS_PER_WEEK`을 찾기가 얼마나 쉬운지 생각해 보라.

## 6. 인코딩을 피하라
- **유형이나 범위정보 까지 인코딩에 넣으면 그만큼 이름을 해독하기 어려워진다.**
- 인코딩한 이름은 발음하기도 어려우며 오타가 생기기도 쉽다.


__ 헝가리식 표기법
__ 멤버 변수 접두어
__ 인터페이스 클래스와 구현 클래스
자신의 기억력을 자랑하지 마라
클래스 이름
메서드 이름
기발한 이름은 피하라
한 개념에 한 단어를 사용하라
말장난을 하지 마라
해법 영역에서 가져온 이름을 사용하라
문제 영역에서 가져온 이름을 사용하라
의미 있는 맥락을 추가하라
불필요한 맥락을 없애라
마치면서
# **3장. 함수**
작게 만들어라!
__ 블록과 들여쓰기
한 가지만 해라!
__ 함수 내 섹션
함수 당 추상화 수준은 하나로!
__ 위에서 아래로 코드 읽기: 내려가기 규칙
Switch 문
서술적인 이름을 사용하라!
함수 인수
__ 많이 쓰는 단항 형식
__ 플래그 인수
__ 이항 함수
__ 삼항 함수
__ 인수 객체
__ 인수 목록
__ 동사와 키워드
부수 효과를 일으키지 마라!
__ 출력 인수
명령과 조회를 분리하라!
오류 코드보다 예외를 사용하라!
__ Try/Catch 블록 뽑아내기
__ 오류 처리도 한 가지 작업이다.
__ Error.java 의존성 자석
반복하지 마라!
구조적 프로그래밍
함수를 어떻게 짜죠?
결론
참고 문헌
# **4장. 주석**
주석은 나쁜 코드를 보완하지 못한다
코드로 의도를 표현하라!
좋은 주석
__ 법적인 주석
__ 정보를 제공하는 주석
__ 의도를 설명하는 주석
__ 의미를 명료하게 밝히는 주석
__ 결과를 경고하는 주석
__ TODO 주석
__ 중요성을 강조하는 주석
__ 공개 API에서 Javadocs
나쁜 주석
__ 주절거리는 주석
__ 같은 이야기를 중복하는 주석
__ 오해할 여지가 있는 주석
__ 의무적으로 다는 주석
__ 이력을 기록하는 주석
__ 있으나 마나 한 주석
__ 무서운 잡음
__ 함수나 변수로 표현할 수 있다면 주석을 달지 마라
__ 위치를 표시하는 주석
__ 닫는 괄호에 다는 주석
__ 공로를 돌리거나 저자를 표시하는 주석
__ 주석으로 처리한 코드
__ HTML 주석
__ 전역 정보
__ 너무 많은 정보
__ 모호한 관계
__ 함수 헤더
__ 비공개 코드에서 Javadocs
__ 예제
참고 문헌
# **5장. 형식 맞추기**
형식을 맞추는 목적
적절한 행 길이를 유지하라
__ 신문 기사처럼 작성하라
__ 개념은 빈 행으로 분리하라
__ 세로 밀집도
__ 수직 거리
__ 세로 순서
가로 형식 맞추기
__ 가로 공백과 밀집도
__ 가로 정렬
__ 들여쓰기
가짜 범위
팀 규칙
밥 아저씨의 형식 규칙
# **6장. 객체와 자료 구조**
자료 추상화
자료/객체 비대칭
디미터 법칙
__ 기차 충돌
__ 잡종 구조
__ 구조체 감추기
자료 전달 객체
__ 활성 레코드
결론
참고 문헌
# **7장. 오류 처리**
오류 코드보다 예외를 사용하라
Try-Catch-Finally 문부터 작성하라
미확인unchecked 예외를 사용하라
예외에 의미를 제공하라
호출자를 고려해 예외 클래스를 정의하라
정상 흐름을 정의하라
null을 반환하지 마라
null을 전달하지 마라
결론
참고문헌
# **8장. 경계**
외부 코드 사용하기
경계 살피고 익히기
log4j 익히기
학습 테스트는 공짜 이상이다
아직 존재하지 않는 코드를 사용하기
깨끗한 경계
참고 문헌
# **9장. 단위 테스트**
TDD 법칙 세 가지
깨끗한 테스트 코드 유지하기
__ 테스트는 유연성, 유지보수성, 재사용성을 제공한다
깨끗한 테스트 코드
__ 도메인에 특화된 테스트 언어
__ 이중 표준
테스트 당 assert 하나
__ 테스트 당 개념 하나
F.I.R.S.T.
결론
참고 문헌
# **10장. 클래스**
클래스 체계
__ 캡슐화
클래스는 작아야 한다!
__ 단일 책임 원칙
__ 응집도Cohesion
__ 응집도를 유지하면 작은 클래스 여럿이 나온다
변경하기 쉬운 클래스
__ 변경으로부터 격리
참고 문헌
# **11장. 시스템**
도시를 세운다면?
시스템 제작과 시스템 사용을 분리하라
__ Main 분리
__ 팩토리
__ 의존성 주입
확장
__ 횡단(cross-cutting) 관심사
자바 프록시
순수 자바 AOP 프레임워크
AspectJ 관점
테스트 주도 시스템 아키텍처 구축
의사 결정을 최적화하라
명백한 가치가 있을 때 표준을 현명하게 사용하라
시스템은 도메인 특화 언어가 필요하다
결론
참고 문헌
# **12장. 창발성(創發性)**
창발적 설계로 깔끔한 코드를 구현하자
단순한 설계 규칙 1: 모든 테스트를 실행하라
단순한 설계 규칙 2~4: 리팩터링
중복을 없애라
표현하라
클래스와 메서드 수를 최소로 줄여라
결론
참고 문헌
# **13장. 동시성**
동시성이 필요한 이유?
__ 미신과 오해
난관
동시성 방어 원칙
__ 단일 책임 원칙Single Responsibility Principle, SRP
__ 따름 정리corollary: 자료 범위를 제한하라
__ 따름 정리: 자료 사본을 사용하라
__ 따름 정리: 스레드는 가능한 독립적으로 구현하라
라이브러리를 이해하라
__ 스레드 환경에 안전한 컬렉션
실행 모델을 이해하라
__ 생산자-소비자Producer-Consumer
__ 읽기-쓰기Readers-Writers
__ 식사하는 철학자들Dining Philosophers
동기화하는 메서드 사이에 존재하는 의존성을 이해하라
동기화하는 부분을 작게 만들어라
올바른 종료 코드는 구현하기 어렵다
스레드 코드 테스트하기
__ 말이 안 되는 실패는 잠정적인 스레드 문제로 취급하라
__ 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자
__ 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있게 스레드 코드를
구현하라
__ 다중 스레드를 쓰는 코드 부분을 상황에 맞게 조율할 수 있게 작성하라
__ 프로세서 수보다 많은 스레드를 돌려보라
__ 다른 플랫폼에서 돌려보라
__ 코드에 보조 코드instrument를 넣어 돌려라. 강제로 실패를 일으키게 해보라
__ 직접 구현하기
__ 자동화
결론
참고 문헌
# **14장. 점진적인 개선**
Args 구현
__ 어떻게 짰느냐고?
Args: 1차 초안
__ 그래서 멈췄다
__ 점진적으로 개선하다
String 인수
결론
# **15장. JUnit 들여다보기**
JUnit 프레임워크
결론
# **16장. SerialDate 리팩터링**
첫째, 돌려보자
둘째, 고쳐보자
결론
참고 문헌
# **17장. 냄새와 휴리스틱**
주석
__ C1: 부적절한 정보
__ C2: 쓸모 없는 주석
__ C3: 중복된 주석
__ C4: 성의 없는 주석
__ C5: 주석 처리된 코드
환경
__ E1: 여러 단계로 빌드해야 한다
__ E2: 여러 단계로 테스트해야 한다
함수
__ F1: 너무 많은 인수
__ F2: 출력 인수
__ F3: 플래그 인수
__ F4: 죽은 함수
일반
__ G1: 한 소스 파일에 여러 언어를 사용한다
__ G2: 당연한 동작을 구현하지 않는다
__ G3: 경계를 올바로 처리하지 않는다
__ G4: 안전 절차 무시
__ G5: 중복
__ G6: 추상화 수준이 올바르지 못하다
__ G7: 기초 클래스가 파생 클래스에 의존한다
__ G8: 과도한 정보
__ G9: 죽은 코드
__ G10: 수직 분리
__ G11: 일관성 부족
__ G12: 잡동사니
__ G13: 인위적 결합
__ G14: 기능 욕심
__ G15: 선택자 인수
__ G16: 모호한 의도
__ G17: 잘못 지운 책임
__ G18: 부적절한 static 함수
__ G19: 서술적 변수
__ G20: 이름과 기능이 일치하는 함수
__ G21: 알고리즘을 이해하라
__ G22: 논리적 의존성은 물리적으로 드러내라
__ G23: If/Else 혹은 Switch/Case 문보다 다형성을 사용하라
__ G24: 표준 표기법을 따르라
__ G25: 매직 숫자는 명명된 상수로 교체하라
__ G26: 정확하라
__ G27: 관례보다 구조를 사용하라
__ G28: 조건을 캡슐화하라
__ G29: 부정 조건은 피하라
__ G30: 함수는 한 가지만 해야 한다
__ G31: 숨겨진 시간적인 결합
__ G32: 일관성을 유지하라
__ G33: 경계 조건을 캡슐화하라
__ G34: 함수는 추상화 수준을 한 단계만 내려가야 한다
__ G35: 설정 정보는 최상위 단계에 둬라
__ G36: 추이적 탐색을 피하라
자바
__ J1: 긴 import 목록을 피하고 와일드카드를 사용하라
__ J2: 상수는 상속하지 않는다
__ J3: 상수 대 Enum
이름
__ N1: 서술적인 이름을 사용하라
__ N2: 적절한 추상화 수준에서 이름을 선택하라
__ N3: 가능하다면 표준 명명법을 사용하
__ N4: 명확한 이름
__ N5: 긴 범위는 긴 이름을 사용하라
__ N6: 인코딩을 피하라
__ N7: 이름으로 부수 효과를 설명하라
테스트
__ T1: 불충분한 테스트
__ T2: 커버리지 도구를 사용하라!
__ T3: 사소한 테스트를 건너뛰지 마라
__ T4: 무시한 테스트는 모호함을 뜻한다
__ T5: 경계 조건을 테스트하라
__ T6: 버그 주변은 철저히 테스트하라
__ T7: 실패 패턴을 살펴라
__ T8: 테스트 커버리지 패턴을 살펴라
__ T9: 테스트는 빨라야 한다
결론
참고 문헌
부록A 동시성 II
클라이언트/서버 예제
__ 서버
__ 스레드 추가하기
__ 서버 살펴보기
__ 결론
가능한 실행 경로
__ 경로 수
__ 가능한 순열 수 계산하기
__ 심층 분석
__ 결론
라이브러리를 이해하라
__ Executor 프레임워크
__ 스레드를 차단하지 않는non blocking 방법
__ 다중 스레드 환경에서 안전하지 않은 클래스
메서드 사이에 존재하는 의존성을 조심하라
__ 실패를 용인한다
__ 클라이언트-기반 잠금
__ 서버-기반 잠금
작업 처리량 높이기
__ 작업 처리량 계산 - 단일스레드 환경
__ 작업 처리량 계산 - 다중 스레드 환경
데드락
__ 상호 배제Mutual Exclusion
__ 잠금 & 대기Lock & Wait
__ 선점 불가No Preemption
__ 순환 대기Circular Wait
__ 상호 배제 조건 깨기
__ 잠금 & 대기 조건 깨기
__ 선점 불가 조건 깨기
__ 순환 대기 조건 깨기
__ 다중 스레드 코드 테스트
__ 스레드 코드 테스트를 도와주는 도구
결론
자습서: 전체 코드 예제
__ 클라이언트/서버 - 단일스레드 버전
__ 클라이언트/서버 - 다중 스레드 버전
