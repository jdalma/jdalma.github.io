---
layout: default
title: 그림으로 배우는 Http & Network
parent: 📖 Books
nav_order: 2
---

{: .no_toc }

<details open markdown="block">
  <summary>
    Table of contents
  </summary>
  {: .text-delta }
1. TOC
{:toc}
</details>

---



# 3장. **HTTP 정보는 HTTP 메시지에 있다**

## **HTTP 메시지**
- HTTP 메시지는 복수 행(개행 문자는 `CR` + `LF`)의 데이터로 구성된 **텍스트 문자열**
- 최초에 나타나는 개행 문자로 메시지 헤더와 메시지 바디를 구분한다

1. **메시지 헤더**
   - 서버와 클라이언트가 꼭 처리해야 하는 리퀘스트와 리스폰스 내용과 속성 등
2. **CR** + **LF**
   - CR : carriage return `16진수 0x0d`
   - LF : Line feed `16진수 0x0a`
3. **메시지 바디**
   - 데이터 그 자체

## **인코딩으로 전송 효율을 높이다**
- 전송할 떄 인코딩을 하면 다량의 액세스를 효율 좋게 처리할 수 있다
  - *컴퓨터에서 인코딩 처리를 해야 하기 때문에 CPU 등의 리소스는 보다 많이 소비하게 된다*

### **`메시지 바디`와 `엔티티 바디`의 차이**
- **메시지**
  - HTTP 통신의 기본 단위로 옥텟 시퀀스 (`Octet Sequence` , octet은 8비트)로 구성되고 통신을 통해서 전송된다
- **엔티티**
  - 리퀘스트랑 리스폰스의 페이로드 (`payload`)로 전송되는 정보로 **엔티티 헤더 필드**와 **엔티티 바디**로 구성된다
  - 인코딩 된 정보

HTTP 메시지 바디의 역할은 **리퀘스트랑 리스폰스에 관한 엔티티 바디를 운반하는 일**이다<br>

### **압축해서 보내는 `콘텐츠 코딩`**
- 메일에 파일을 첨부해서 보낼 경우 `zip`으로 압축한 파일을 보내는 일이 있다
- HTTP에는 이와 같은 일이 가능한 **콘텐츠 코딩**이라고 불리는 기능이 구현되어 있다
- **콘텐츠 코딩**은 `엔티티에 적용하는 인코딩` , 엔티티의 정보를 유지한 채로 압축한다
- 수신한 클라이언트 측에서 디코딩 한다

### **분해해서 보내는 `청크 전송 코딩`**
- HTTP 통신에서는 리퀘스트 했었던 리소스 전부에서 엔티티 바디의 전송이 완료되지 않으면 브라우저에 표시 되지 않는다
- 사이즈가 큰 데이터를 전송하는 경우엔 데이터를 분할해서 조금씩 표시할 수 있다
- 이렇게 `엔티티 바디를 분할하는 기능`을 **청크 전송 코딩 (Chunked Transfer Coding)**이라고 부른다

### **여러 데이터를 보내는 `멀티파트`** RFC2046
- 메일의 경우에는 메일의 본문이나 복수의 첨부 파일을 붙여서 함께 보낼 수 있다
- 이것은 **MIME** (`Multipurpose Internet Mail Extensions` 다목적 인터넷 메일) 확장 사양으로 불리는 메일로 텍스트나 영상 , 이미지와 같은 여러 다른 데이터를 다루기 위한 기능을 사용하고 있다
- **MIME**는 이미지 등의 바이너리 데이터를 ASCII 문자열에 인코딩 하는 방법과 데이터 종류를 나타내는 방법 등을 규정하고 있다
- **HTTP**도 멀티파트에 대응하고 있어 하나의 메시지 바디 내부에 엔티티를 여러 개 포함시킬 수 있다

1. **multipart/form-data**
   - Web 폼으로 부터 파일 업로드에 사용된다
2. **multipart/byteranges**
   - 상태코드 206 (Partial Content) 리스폰스 메시지가 복수 범위의 내용을 포함하는 때에 사용된다

### **일부분만 받는 `레인지 리퀘스트`**
- 광대역의 네트워크를 사용하기 전 까지는 대용량의 데이터나 이미지를 받기가 힘들었다 , 왜냐하면 다운로드 중에 커넥션이 끊어진다면 처음부터 끝까지 다시 다운로드를 해야했기 때문이다
- 이러한 문제를 해결하기 위해 **리줌** `resume`이라는 기능이 필요하게 되었다
- 이 기능을 실현하기 위해서는 엔티티의 범위를 지정해서 다운로드를 할 필요가 있다
  - 이와 같이 범위를 지정하여 리퀘스트 하는 것을 **레인지 리퀘스트** `Reange Request`라고 한다
  - **Range 헤더 필드를 사용**
  - 상태코드 206 (Partial Content)이 돌아온다
- 서버가 **레인지 리퀘스트**를 지원하지 않는 경우에는 200 , 완전한 엔티티가 넘어온다

### **최적의 콘텐츠를 돌려주는 `콘텐츠 네고시에이션`**
- 표시되는 언어가 서로 다른 웹 페이지를 **URI 엑세스** 할 때에 각각 구분하여 표시해준다
- 이와 같은 구조를 **콘텐츠 네고시에이션** (`Content Negotiation`)이라고 한다
  - 제공하는 리소스를 언어와 문자 세트 , 인코딩 방식 등을 기준으로 판단한다
  - 판단 기준은 리퀘스트 메시지에 포함된 리퀘스트 헤더 필드이다
    1. Accept
    2. Accept-Charset
    3. Accept-Encoding
    4. Accept-Language
    5. Content-Language

<br>

**종류**
1. **서버 구동형 네고시에이션** `Server-driven Negotiation`
   - 서버 측에서 하는 방식
   - 서버 측에서 리퀘스트 헤더 필드의 정보를 참고해서 자동적으로 처리
2. **에이전트 구동형 네고시에이션** `Agent-driven Negotiation`
   - 클라이언트 측에서 하는 방식
   - 브라우저에서 유저가 수동으로 선택
   - OS의 종류나 브라우저 종류 등에 의해서 PC용 ↔︎ 스마트폰 웹 전환이 이에 해당한다
3. **트랜스페어런트 네고시에이션** `Transparent Negotiation`
   - 서버 구동형과 에이전트 구동형을 혼합한 것
   - 각각 하는 방식

# 4장. **[결과를 전달하는 HTTP 상태 코드](https://jdalma.github.io/docs/network/http-code-redirection/)**

# 5장. **HTTP와 연계하는 웹 서버**

## **1대로 멀티 도메인을 가능하게 하는 `가상 호스트`**
- HTTP/1.1 에서는 하나의 HTTP 서버에 여러 개의 웹 사이트를 실행할 수 있다
  - *1대의 서버에 여러 고객의 웹 사이트를 넣을 수 있다*
- HTTP 리퀘스트를 보내는 경우에는 호스트 명과 도메인 명을 완전하게 포함한 URI를 지정하거나, 반드시 Host 헤더 필드에서 지정해야 한다

## **통신을 중계하는 프로그램 : `프록시` , `게이트웨이` , `터널`**
- 다른 서버에 리퀘스트를 중계하고 , 그 서버로 부터 받은 리스폰스를 클라이언트에 반환하는 역할을 담당

### 프록시
- 서버와 클라이언트의 양쪽 역할을 하는 중계 프로그램으로 , 클라이언트로 부터의 리퀘스트를 서버에 전송하고 , 서버로 부터의 리스폰스를 클라이언트로 전달
- 리소스 본체를 가진 서버를 `origin server`라고 부른다
- 프록시 서버를 경유해서 요청과 응답이 릴레이 될 때마다 **Via**헤더 필드에 경유한 호스트 정보를 추가해야 한다
- 프록시 서버를 사용하는 이유는 캐시를 사용해서 네트워크 대역등을 호율적으로 사용하는 것과 조직 내에 특정 웹사이트에 대한 엑세스 제한 등등
- 프록시와 게이트웨의 차이는 프록시로 보낸다기 보다는 `origin server`를 보냈지만 중간에 프록시가 끼게 되는 것


<br>

1. **캐싱 프록시**
   - 프록시 서버상에 리소스 캐시를 보존해 두는 타입
   - 같은 리소스에 리퀘스트가 온 경우 해당 캐시로 응답한다
2. **투명 프록시**
   - 중계할 때 메시지 변경을 하지 않는 타입
   - *반대로 메시지에 변경을 가하는 타입의 프록시를 **비투과 프록시**라고 한다*

### 게이트웨이
- 프록시와 매우 유사하다
- 게이트웨이의 경우에는 그 다음에 있는 서버가 HTTP 서버 이외의 서비스를 제공하는 서버가 된다
- 클라이언트와 게이트웨이 사이를 암호화하는 등으로 안전하게 접속함으로써 통신의 안전성을 높이는 역할 등을 한다

### 터널
- 서로 떨어진 두 대의 클라이언트와 서버 사이를 중계하며 접속을 주선하는 중계 프로그램
- 요구에 따라서 다른 서버와의 통신 경로를 확립
- 이 때 클라이언트는 SSL 같은 암호화 통신을 통해 서버와 안전하게 통신을 하기 위해 사용한다
- HTTP 리퀘스트를 해석하려고 하지 않는다 , 그냥 전달한다
- 통신하고 있는 양쪽 끝의 접속이 끊어질 때에 종료한다

## **리소스를 보관하는 `캐시`** ⭐️
- 프록시 서버와 클라이언트의 로컬 디스크에 보관된 리소스의 사본을 가리킨다
  - 통신량과 통신시간을 절약
- **캐시 서버**는 프록시 서버의 하나로 캐싱 프록시로 분류 된다


### 캐시는 유효기간이 있다
- 캐시를 가지고 있더라도 클라이언트의 요구나 캐시의 유효기간 등에 의해서 오리진 서버에 리소스의 유효성을 확인하거나 새로운 리소스를 다시 획득하러 가게되는 경우도 있다

### 클라이언트 측에도 캐시가 있다
- 클라이언트가 사용하는 브라우저에도 캐시를 가질 수 있다
- 캐시로 가지고 있는 경우 서버에 접근하지 않고 로컬 디스크로 부터 불러온다
- 유효성을 확인하거나 새로운 리소스를 가지러 서버에 접근하게 되는 경우도 있다




