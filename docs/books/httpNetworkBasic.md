---
layout: default
title: 그림으로 배우는 Http & Network
parent: 📖 Books
nav_order: 2
---

{: .no_toc }

<details open markdown="block">
  <summary>
    Table of contents
  </summary>
  {: .text-delta }
1. TOC
{:toc}
</details>

---



# 3장. **HTTP 정보는 HTTP 메시지에 있다**

## **HTTP 메시지**
- HTTP 메시지는 복수 행(개행 문자는 `CR` + `LF`)의 데이터로 구성된 **텍스트 문자열**
- 최초에 나타나는 개행 문자로 메시지 헤더와 메시지 바디를 구분한다

1. **메시지 헤더**
   - 서버와 클라이언트가 꼭 처리해야 하는 리퀘스트와 리스폰스 내용과 속성 등
2. **CR** + **LF**
   - CR : carriage return `16진수 0x0d`
   - LF : Line feed `16진수 0x0a`
3. **메시지 바디**
   - 데이터 그 자체

## **인코딩으로 전송 효율을 높이다**
- 전송할 떄 인코딩을 하면 다량의 액세스를 효율 좋게 처리할 수 있다
  - *컴퓨터에서 인코딩 처리를 해야 하기 때문에 CPU 등의 리소스는 보다 많이 소비하게 된다*

### **`메시지 바디`와 `엔티티 바디`의 차이**
- **메시지**
  - HTTP 통신의 기본 단위로 옥텟 시퀀스 (`Octet Sequence` , octet은 8비트)로 구성되고 통신을 통해서 전송된다
- **엔티티**
  - 리퀘스트랑 리스폰스의 페이로드 (`payload`)로 전송되는 정보로 **엔티티 헤더 필드**와 **엔티티 바디**로 구성된다

HTTP 메시지 바디의 역할은 **리퀘스트랑 리스폰스에 관한 엔티티 바디를 운반하는 일**이다<br>

### **압축해서 보내는 콘텐츠 코딩**
- 메일에 파일을 첨부해서 보낼 경우 `zip`으로 압축한 파일을 보내는 일이 있다
- HTTP에는 이와 같은 일이 가능한 **콘텐츠 코딩**이라고 불리는 기능이 구현되어 있다
- **콘텐츠 코딩**은 `엔티티에 적용하는 인코딩` , 엔티티의 정보를 유지한 채로 압축한다
- 수신한 클라이언트 측에서 디코딩 한다

### **분해해서 보내는 청크 전송 코딩**
- HTTP 통신에서는 리퀘스트 했었던 리소스 전부에서 엔티티 바디의 전송이 완료되지 않으면 브라우저에 표시 되지 않는다
- 사이즈가 큰 데이터를 전송하는 경우엔 데이터를 분할해서 조금씩 표시할 수 있다
- 이렇게 `엔티티 바디를 분할하는 기능`을 **청크 전송 코딩 (Chunked Transfer Coding)**이라고 부른다

### **여러 데이터를 보내는 멀티파트** RFC2046
- 메일의 경우에는 메일의 본문이나 복수의 첨부 파일을 붙여서 함께 보낼 수 있다
- 이것은 **MIME** (`Multipurpose Internet Mail Extensions` 다목적 인터넷 메일) 확장 사양으로 불리는 메일로 텍스트나 영상 , 이미지와 같은 여러 다른 데이터를 다루기 위한 기능을 사용하고 있다
- **MIME**는 이미지 등의 바이너리 데이터를 ASCII 문자열에 인코딩 하는 방법과 데이터 종류를 나타내는 방법 등을 규정하고 있다
- **HTTP**도 멀티파트에 대응하고 있어 하나의 메시지 바디 내부에 엔티티를 여러 개 포함시킬 수 있다

1. **multipart/form-data**
   - Web 폼으로 부터 파일 업로드에 사용된다
2. **multipart/byteanges**
   - 상태코드 206 (Partial Content) 리스폰스 메시지가 복수 범위의 내용을 포함하는 때에 사용된다

### **일부분만 받는 레인지 리퀘스트**
- 광대역의 네트워크를 사용하기 전 까지는 대용량의 데이터나 이미지를 받기가 힘들었다 , 왜냐하면 다운로드 중에 커넥션이 끊어진다면 처음부터 끝까지 다시 다운로드를 해야했기 때문이다
- 이러한 문제를 해결하기 위해 **리줌** `resume`이라는 기능이 필요하게 되었다
- 이 기능을 실현하기 위해서는 엔티티의 범위를 지정해서 다운로드를 할 필요가 있다
  - 이와 같이 범위를 지정하여 리퀘스트 하는 것을 **레인지 리퀘스트** `Reange Request`라고 한다
  - **Range 헤더 필드를 사용**
  - 상태코드 206 (Partial Content)이 돌아온다
- 서버가 **레인지 리퀘스트**를 지원하지 않는 경우에는 200 , 완전한 엔티티가 넘어온다

### **최적의 콘텐츠를 돌려주는 콘텐츠 네고시에이션**
- 표시되는 언어가 서로 다른 웹 페이지를 **URI 엑세스** 할 때에 각각 구분하여 표시해준다
- 이와 같은 구조를 **콘텐츠 네고시에이션** (`Content Negotiation`)이라고 한다
  - 제공하는 리소스를 언어와 문자 세트 , 인코딩 방식 등을 기준으로 판단한다
  - 판단 기준은 리퀘스트 메시지에 포함된 리퀘스트 헤더 필드이다
    1. Accept
    2. Accept-Charset
    3. Accept-Encoding
    4. Accept-Language
    5. Content-Language

<br>

**종류**
1. **서버 구동형 네고시에이션** `Server-driven Negotiation`
   - 서버 측에서 하는 방식
   - 서버 측에서 리퀘스트 헤더 필드의 정보를 참고해서 자동적으로 처리
2. **에이전트 구동형 네고시에이션** `Agent-driven Negotiation`
   - 클라이언트 측에서 하는 방식
   - 브라우저에서 유저가 수동으로 선택
   - OS의 종류나 브라우저 종류 등에 의해서 PC용 ↔︎ 스마트폰 웹 전환이 이에 해당한다
3. **트랜스페어런트 네고시에이션** `Transparent Negotiation`
   - 서버 구동형과 에이전트 구동형을 혼합한 것
   - 각각 하는 방식