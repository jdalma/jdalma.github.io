---
layout: default
title: 자바 8,9,10,11
parent: 모던 자바 인 액션
grand_parent: Books
nav_order: 1
---
## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}
---

# **자바 역사를 통틀어 가장 큰 변화가 자바8 에서 일어났다.**

- 자바5에서는 **Thread Pool , 병렬 실행 컬렉션** 등 아주 강력한 도구를 도입했다.
- 자바7에서는 병렬 실행에 도움을 줄 수 있는 **포크/조인 프레임워크**를 제공했지만 여전히 활용하기가 쉽지 않았다.
- **자바8에서는 병렬 실행을 새롭고 단순한 방식으로 접근할 수 있는 방법을 제공한다.**
  - ***간결한 코드 , 멀티코어 프로세서의 쉬운 활용*이라는 두 가지 요구사항을 기반으로 한다.**
  - **함수형 프로그래밍**에서 위력을 발휘한다.
  - **새로운 기술**
    1. 병렬 연산을 지원하는 **스트림 API**
    2. **메서드에 코드를 전달하는 기법 (메서드 참조와 람다)**
    3. **인터페이스의 디폴트 메서드**
- 자바9에서는 **리액티브 프로그래밍** 이라는 **병렬 실행 기법을 지원한다.**
  - 고성능 병렬 시스템에서 특히 인기를 얻고 있는 **RxJava(리액티브 스트림 툴킷 이라고도 불림)** 를 표준적인 방식으로 지원한다.

- 예를 들어 , 다음은 사과 목록을 무게순으로 정렬하는 고전적 코드다.
```java
Collections.sort(inventory, new Comparator<Apple>() {
   public int compare(Apple a1 , Apple a2){
       return a1.getWeight().compareTo(a2.getWeight());
   }
});
```
- 자바8을 이용하면 자연어에 더 가깝게 구현할 수 있다.
```java
inventory.sort(comparing(Apple::getWeight));
```

***

# **자바8 설계의 밑바탕을 이루는 세 가지 프로그래밍 개념**

## 스트림 처리
- **스트림 이란?**
  - **한 번에 한 개씩 만들어지는 연속적인 데이터 항목들의 모임이다.**
  - 이론적으로 프로그램은 입력 스트림에서 데이터를 한 개씩 읽어 들이며 마찬가지로 출력 스트림으로 데이터를 한 개씩 기록한다.
  - *즉, 어떤 프로그램의 출력 스트림은 다른 프로그램의 입력 스트림이 될 수 있다.*

- **유닉스 명령행  `|` 사용해 명령을 연결한다** - `cat file1 file2 | tr "[A-Z]" "[a-z]" | sort | tail -3`**
- 파일의 단어를 소문자로 바꾼 다음에 사전순으로 단어를 정렬했을 때 가장 마지막에 위치한 세 단어를 출력하는 프로그램이다.
- **유닉스에서는 여러 명령을 병렬로 실행한다.**
- **스트림 API가 조립 라인 처럼 어떤 항목을 연속으로 제공하는 어떤 기능이라고 단순하게 생각하자**
- **스트림 API는 `|`을 만드는데 필요한 많은 메서드를 제공한다.**
- 스레드라는 복잡한 작업을 사용하지 않으면서 **공짜로 병렬성을 얻을 수 있다.**

## **동작 파라미터화**로 메서드에 코드 전달하기
- **코드 일부를 API로 전달하는 기능이다.**
- **연산의 동작을 파라미터화 할 수 있는 코드를 전달한다.**

## 병렬성과 공유 가변 데이터
- 다른 코드와 동시에 실행 하더라도 **안전하게 실행**할 수 있는 코드를 만들어야 한다.
- **공유된 가변 데이터에 접근하지 않아야 한다.**
  - 이러한 함수를 `순수(pure) 함수` , `부작용 없는(side-effect-free) 함수` , `상태 없는(stateless) 함수`라 부른다.

***

# **자바 함수**
- 프로그래밍 언어에서 **함수** 라는 용어는 **메서드 (특히 *정적 메서드*)** 와 같은 의미로 사용된다.
- 자바8에서는 함수를 새로운 값의 형식으로 추가했다.
  - **멀티코어에서 병렬 프로그래밍을 활용할 수 있는 스트림과 연계될 수 있도록 함수를 만들었기 때문이다.**

>**함수를 값처럼 취급한다고 했는데 이 특징이 어떤 장점을 제공할까?**
> - 프로그래밍 언어의 핵심은 값을 바꾸는 것이다.
> - 📌 이 값을 **일급(first-class) 값** 또는 **일급 시민**이라 부른다.
> - **자바의 다양한 구조체(메서드 , 클래스 같은)가 값의 구조를 표현하는데 도움이 될 수 있다.**
>    - 하지만 , 프로그램을 실행하는 동안 이러한 모든 구조체를 자유롭게 전달할 수는 없다.
>    - 이렇게 전달할 수 없는 구조체는 **이급 시민** (메서드 , 클래스 등)이다.
>    - *메서드와 클래스는 그 자체로 값이 될 수 없다.*

## 메서드와 람다를 일급 시민으로

### 메서드 참조
- 디렉터리에서 모든 숨겨진 파일을 필터링한다고 가정하자.
- `File`클래스는 이미 `isHidden`메서드를 제공한다.
  - `File`클래스를 인수로 받아 `boolean`을 반환하는 함수다.

```java
File[] hiddenFiles = new File(".").listFiles(new FileFilter(){
  public boolean accept(File file){
    return file.isHidden();
  }
})
```

> ✋ `정말로 저렇게 프로그래밍을 해야하나?`
> - `File`클래스에는 이미 `isHidden`이라는 메서드가 있는데
> - 굳이 `FileFilter`로 `isHidden`을 복잡하게 감싼 다음에
> - `FileFilter`를 인스턴스화 해야할까??

```java
File[] hiddenFiles = new File(".").listFiles(File::isHidden);
```

### 람다 : 익명 함수
- 자바 8 에서는 메서드를 일급값으로 취급할 뿐  아니라 **람다 (또는 익명 함수 `anonymous function`)**를 포함하여 함수도 값으로 취급할 수 있다.
- *3장에서* , 람다 문법 형식으로 구현된 프로그램을 함수형 프로그래밍 , **즉 , 함수를 일급값으로 넘겨주는 프로그램을 구현한다.**

***


### 메서드 전달에서 람다로
- 한 두번만 사용할 메서드를 매번 정의하는 것은 귀찮은 일이다.
- **자바 8 에서는 다음처럼 (익명 함수 또는 람다라는) 새로운 개념을 이용할 수 있다.**

```java
  fillterApples(inventory , (Apple a) -> GREEN.equals(a.getColor()));
  fillterApples(inventory , (Apple a) -> a.getWeight() > 150);
  fillterApples(inventory , (Apple a) -> a.getWeight() < 80 || RED.equals(a.getColor()));
```
