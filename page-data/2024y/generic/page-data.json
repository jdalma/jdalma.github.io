{"componentChunkName":"component---src-templates-blog-post-js","path":"/2024y/generic/","result":{"data":{"site":{"siteMetadata":{"title":"코딩 주머니"}},"markdownRemark":{"id":"be694c1c-f095-5970-ae40-b324ed2b5259","excerpt":"…","html":"<p>자바나 코틀린을 사용하면서 언어 내부를 조사한다던지, 자료구조 성격의 클래스를 설계한다던지, 특정 계층에서만 사용할 수 있는 함수를 작성 할때 제네릭을 종종 접한다.<br>\n하지만 매번 제네릭에 대한 이해가 부족해 타입 검사기가 왜 거부하는지 이해하지 못하여 원하는대로 작성을 못한 경험이 있다.<br>\n그리고 제네릭하면 빠지지 않는 공변,불변,반공변에 대한 내용도 머리에서 정리되지 않아 누군가에게 설명하기도 힘들었다.</p>\n<p>이번에 <a href=\"https://product.kyobobook.co.kr/detail/S000210397750\">타입으로 견고하게 다형성으로 유연하게</a>를 읽으면서 제네릭에 대해 구멍나있던 지식들을 촘촘히 채울 수 있었다.<br>\n(만약 이런 경험이 있는 개발자라면 이 책을 추천한다.)</p>\n<p>이 글에서는 아래의 내용을 전개한다.</p>\n<ol>\n<li><strong>여러 종류의 다형성</strong></li>\n<li><strong>제네릭 가변성이 왜 필요한지</strong></li>\n<li><strong>PECS를 왜 지켜야 하는지</strong></li>\n</ol>\n<p>일단 다형성에 대해 간단하게 알아보자.</p>\n<h1 id=\"다형성\" style=\"position:relative;\">다형성<a href=\"#%EB%8B%A4%ED%98%95%EC%84%B1\" aria-label=\"다형성 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>다형성은 프로그램의 <strong>한 개체가 여러 타입에 속하도록 만드는 것이다.</strong><br>\n(개체는 값, 함수, 클래스, 메서드 등 여러 가지가 될 수 있다.)</p>\n<p>하나의 값이 여러 타입에 속할 수도 있고, 한 함수를 여러 타입의 함수로 사용할 수도 있는 것이다.<br>\n<strong>다형성은 거의 모든 정적 타입 언어에서만 발견할 수 있는 매우 널리 사용되는 개념이다.</strong><br>\n<code class=\"language-text\">\"어떤 개체에 다형성을 부여하는지\"</code> , <code class=\"language-text\">\"어떻게 다형성을 부여하는지\"</code> 를 이해하는 것이 중요하다.</p>\n<h2 id=\"서브타입에-의한-다형성\" style=\"position:relative;\">서브타입에 의한 다형성<a href=\"#%EC%84%9C%EB%B8%8C%ED%83%80%EC%9E%85%EC%97%90-%EC%9D%98%ED%95%9C-%EB%8B%A4%ED%98%95%EC%84%B1\" aria-label=\"서브타입에 의한 다형성 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>이 주제는 객체를 다룰 때 유용하며 <strong>서브타입</strong> 이라는 개념을 통해 다형성을 실현한다.<br>\n서브타입은 타입 사이의 관계이며, <code class=\"language-text\">\"A는 B이다.\"</code> 라는 설명이 올바르다면 <code class=\"language-text\">A는 B의 서브타입</code> , <code class=\"language-text\">B는 A의 슈퍼타입</code>이다.</p>\n<p>A는 B의 서브타입일 때 B 타입의 부품을 A 타입의 부품으로도 간주할 수 있게 하는 기능이 서브타입에 의한 다형성이다.<br>\n즉, <strong>슈퍼타입이 요구되는 자리에 서브타입이 위치하더라도 타입 검사기가 문제삼지 않는다는 것이다.</strong><br>\n반대로 서브타입이 요구되는 자리에느 슈퍼타입이 위치할 수는 없다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 451px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/ab487c944bf8a83a56f771c3d2cfa5c7/38070/subtype.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 60%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAACKElEQVR42lWTSY/TQBCF/f+Pc+AGB8SVXEAgoaBwgMlCRrNAEme1J453OxnHieO1H9Vle5ix9NRlu/vrV13VCugRAs0jUFZAdBGwI4GNW0A1M0x2KaYk1cqwcjIYQY7gWCDNK17zkqG0QZqXsA4Frv+Y+PVgYTBxMNkmWLrA3BEkQG00swSmVomFncPc58gYXEMVGRyTAnPafeEKfP5xjw+dLt53ehhMfWh+Ac0OsXNsmK7J46MTYmUnUO2SwGCwZLDD86WkVHLM6efCKaGFlOoeMMMTonCJ/DCmMxjRrlLDZhzx96dghkc3IDBlQAzJUjQv550kTGpGqdiOjurQbwBjiOj3C9Xv8jviIcUD+N6G12l+DmW6y7BkGBWAzmrr+DyJQcebemFyC1zuSXe1krvmP/3jOX1YnkXFK18DZzYQ+Et2JqKbZ3dfO1fofnqDLx+v8PPbW1x33yEPadP4hh0jHuEpVPHXIIe6X6e8ZIeA5Rq8o3RXOxjjYPQQ6F2E+nfstz1+b9OupMO4D8fdYO2Rw3P6uihcsWDCkxA3KZ1v6zSlZCzVHsdpgFP4gLl5xjmt2rapQapVELTi2PN0qqRcRKlFjY6thjwWVGnXXWFhJcQQ3ORKe0myouImlbAZgSfUvHKi4bgIAw3H/QJRMMXeVwmyxta2sbRiGGGFtGhuC5rGfr55fGMqhHFBE3Nqg5Idj9cpxpuUYkHnJKAHFbyjIND/dS3jH61mgkoOmwTNAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"subtype\"\n        title=\"\"\n        src=\"/static/ab487c944bf8a83a56f771c3d2cfa5c7/38070/subtype.png\"\n        srcset=\"/static/ab487c944bf8a83a56f771c3d2cfa5c7/3684f/subtype.png 225w,\n/static/ab487c944bf8a83a56f771c3d2cfa5c7/fc2a6/subtype.png 450w,\n/static/ab487c944bf8a83a56f771c3d2cfa5c7/38070/subtype.png 451w\"\n        sizes=\"(max-width: 451px) 100vw, 451px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">open class Person(val name: String)\nclass Marathoner(name: String): Person(name)\n\nfun run1(person: Person) { .. }\nrun1(Person(..))\nrun1(Marathoner(..))\n\nfun run2(marathoner: Marathoner) { .. }\nrun2(Person(name))   &quot;컴파일 에러&quot;\nrun2(Marathoner(name))</code>\n        </deckgo-highlight-code>\n<h2 id=\"오버로딩에-의한-다형성\" style=\"position:relative;\">오버로딩에 의한 다형성<a href=\"#%EC%98%A4%EB%B2%84%EB%A1%9C%EB%94%A9%EC%97%90-%EC%9D%98%ED%95%9C-%EB%8B%A4%ED%98%95%EC%84%B1\" aria-label=\"오버로딩에 의한 다형성 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>한 함수가 여러 타입의 인자를 받아야 같은 이름의 함수들을 매개변수 타입을 서로 다르게 하여 여러 개 정의하는 것이다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">fun aging(person: Person) = Person(person.age + 1)\nfun aging(marathoner: Marathoner) = Marathoner(marathoner.age + 1)</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">aging</code> 두 함수 중에 어느 것을 호출할지는 언어 수준에서 자동으로 결정된다.<br>\n함수 선택의 가장 기본적인 규칙은 <strong>인자의 타입에 맞는 함수를 고른다.</strong></p>\n<p>예제는 정수를 관리하는 <code class=\"language-text\">Numbers</code> 클래스와 양수의 인덱스를 따로 가지는 <code class=\"language-text\">PositiveNumbers</code> 클래스가 있다고 가정하자.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">open class Numbers(val elements: List&lt;Int&gt;)\nclass PositiveNumbers(elements: List&lt;Int&gt;): Numbers(elements) {\n    val positiveNumberIndexes: List&lt;Int&gt; = &quot;합계를 빠르게 계산하기 위해 양수의 index를 저장&quot;\n}\n\nfun positiveNumberSum(numbers: Numbers): Int = ..\nfun positiveNumberSum(numbers: PositiveNumbers): Int = ..\n\npositiveNumberSum(Numbers(..))\npositiveNumberSum(PositiveNumbers(..))\n\nval numbers: Numbers = PositiveNumbers(..)  &quot;Numbers가 정적 타입, PositiveNumber가 동적 타입이다.&quot;\npositiveNumberSum(numbers)    &quot;정적 선택 (static dispatch)&quot;</code>\n        </deckgo-highlight-code>\n<p>오버로딩된 양수의 사이즈를 반환하는 <code class=\"language-text\">positiveNumberSum()</code> 함수를 확인할 수 있다.</p>\n<blockquote>\n<ol>\n<li><strong>인자의 타입에 맞는 함수를 고른다.</strong></li>\n<li><strong>인자의 타입에 가장 특화된 함수를 고른다.</strong></li>\n<li><strong>함수를 고를 때는 인자의 정적 타입을 우선으로 고려한다.</strong></li>\n</ol>\n</blockquote>\n<p><code class=\"language-text\">2번</code>과 <code class=\"language-text\">3번</code>을 취합하면 <strong>함수는 인자의 동적 타입보다는 정적 타입을 우선 고려하며, 이 정적 타입에 가장 특화된 함수를 고른다.</strong><br>\n이 이유로 함수 선택 시 정적 타입에 대한 이해가 없다면 버그를 발생시키기 쉽다.<br>\n버그를 방지하기 위한 방법은 <code class=\"language-text\">B</code>가 <code class=\"language-text\">A</code>의 서브타입일 때 <strong><code class=\"language-text\">A</code>를 위한 함수가 이미 있다면 <code class=\"language-text\">B</code>를 위한 같은 이름의 함수를 추가로 정의하지 않는 것이다.</strong><br>\n즉, 함수 오버로딩은 서로 완전히 다른 타입들의 값을 인자로 받는 함수를 정의하는 용도로 사용하는 게 좋다.<br>\n굳이 함수 오버로딩에 서브타입에 의한 다형성을 활용하여 복잡한 상황을 만들지 말자. (메서드 오버로딩도 동일하다.)</p>\n<h2 id=\"오버라이딩에-의한-다형성\" style=\"position:relative;\">오버라이딩에 의한 다형성<a href=\"#%EC%98%A4%EB%B2%84%EB%9D%BC%EC%9D%B4%EB%94%A9%EC%97%90-%EC%9D%98%ED%95%9C-%EB%8B%A4%ED%98%95%EC%84%B1\" aria-label=\"오버라이딩에 의한 다형성 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>메서드 오버라이딩은 클래스를 상속해서 자식 클래스에 메서드를 새로 정의할 때 메서드의 이름과 매개변수 타입을 부모 클래스에 정의되어 있는 메서드와 똑같게 정의하여 <strong>자식 클래스에 특화된 방법을 정의하는 방법이다.</strong><br>\n양수의 개수를 반환하는 <code class=\"language-text\">Numbers</code>의 <code class=\"language-text\">length()</code>함수를 최적화한 <code class=\"language-text\">PositiveNumbers</code>가 있다고 가정하자.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">open class Numbers(val elements: List&lt;Int&gt;) {\n    open fun length(): Int = ..\n}\nclass PositiveNumbers(elements: List&lt;Int&gt;): Numbers(elements) {\n    val positiveNumberIndexes: List&lt;Int&gt; = ..\n\n    override fun length(): Int = ..\n}\n\nval elements = listOf(1,2,3,4)\nval numbers: Numbers = Numbers(elements)\nnumbers.length()\n\nval positiveNumbers: PositiveNumbers = PositiveNumbers(elements)\npositiveNumbers.length()\n\nval numbers2: Numbers = PositiveNumbers(elements)\nnumbers2.length()   &quot;동적 선택 (dynamic dispatch)&quot;</code>\n        </deckgo-highlight-code>\n<blockquote>\n<ol>\n<li><strong>인자의 타입에 맞는 메서드를 고른다.</strong></li>\n<li><strong>인자의 타입에 가장 특화된 메서드를 고른다.</strong></li>\n<li><strong>메서드를 고를 때는 인자의 정적 타입을 우선으로 고려한다.</strong></li>\n<li><strong>메서드를 고를 때는 수신자의 동적 타입도 고려한다.</strong></li>\n</ol>\n</blockquote>\n<p>오버로딩과 다르게 <strong>오버라이딩은 동적 타입에 대해 더 특화된 메서드가 선택되기 때문에, 정적 타입에 상관없이 언제나 그 특화된 동작이 사용되도록 만들 수 있다.</strong><br>\n즉, 함수 선택은 인자의 정적 타입만 고려하지만 <strong>메서드 선택은 인자의 정적 타입도 고려하고 <code class=\"language-text\">수신자(메서드를 호출하는 객체)의 동적 타입</code>도 고려된다.</strong></p>\n<h2 id=\"매개변수에-의한-다형성\" style=\"position:relative;\">매개변수에 의한 다형성<a href=\"#%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98%EC%97%90-%EC%9D%98%ED%95%9C-%EB%8B%A4%ED%98%95%EC%84%B1\" aria-label=\"매개변수에 의한 다형성 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>매개변수에 의한 다형성은 <strong>타입 매개변수를 통해 다형성을 만드는 기능으로, 제네릭스라고도 부른다.</strong></p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">fun &lt;T&gt; choose(v1: T, v2: T): T {\n   println(v1)\n   println(v2)\n   return if(readln() == &quot;Y&quot;) v1 else v2\n}</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">T</code>를 매개변수 타입 표시와 결과 타입 표시에 사용했다. 이와 같이 한 개 이상의 타입 매개변수를 가지는 함수를 <strong>제네릭 함수</strong> 라고 부른다.<br>\n타입 매개변수를 추가할 수 있는 곳은 함수뿐이 아니라 타입에 타입 매개변수를 추가하여 <strong>제네릭 타입</strong> 을 지정할 수 있고,<br>\n타입 매개변수를 가진 클래스를 정의하여 <strong>제네릭 클래스</strong> 도 만들 수 있다.</p>\n<p>하지만 제네릭 <code class=\"language-text\">T</code>가 아무 타입이나 될 수 있기 때문에 특정 타입에서 제공하는 기능을 사용할 수 없다.<br>\n<strong>타입 매개변수로 지정된 타입은 함수 또는 클래스 안에서 특정 능력이 필요한 자리에 사용된다면 제네릭으로 선언할 필요가 없다.</strong></p>\n<h1 id=\"두-다형성의-만남\" style=\"position:relative;\">두 다형성의 만남<a href=\"#%EB%91%90-%EB%8B%A4%ED%98%95%EC%84%B1%EC%9D%98-%EB%A7%8C%EB%82%A8\" aria-label=\"두 다형성의 만남 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>다형성의 내용은 이해하기 쉬웠을 것이다. 이제 이 글을 쓴 이유인 제네릭 가변성에 대해 알아보자.<br>\n위에서 설명한 <strong>서브타입에 의한 다형성</strong>과 <strong>매개변수에 의한 다형성</strong>이 만나게 되면서 복잡한 여러 기능들이 탄생하게 되는데 순서대로 알아보자.</p>\n<h2 id=\"제네릭-클래스와-상속\" style=\"position:relative;\">제네릭 클래스와 상속<a href=\"#%EC%A0%9C%EB%84%A4%EB%A6%AD-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%EC%83%81%EC%86%8D\" aria-label=\"제네릭 클래스와 상속 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">abstract class List&lt;T&gt; {\n    abstract fun get(index: Int): T\n}\nclass ArrayList&lt;T&gt;: List&lt;T&gt;() {\n    override fun get(index: Int): T = ..\n}</code>\n        </deckgo-highlight-code>\n<p>위와 같은 제네릭 클래스가 있을 때 타입들 사이의 서브타입 관계가 <code class=\"language-text\">ArrayList&lt;T>: List&lt;T></code>라면 <code class=\"language-text\">ArrayList&lt;A></code>는 <strong><code class=\"language-text\">List</code>에 등장하는 모든 <code class=\"language-text\">T</code>를 <code class=\"language-text\">A</code>로 바꿔서 만든 타입의 서브타입</strong> 이라고 이해할 수 있다.<br>\n그리고 서브타입을 선언할 때 <strong>특정 타입에 대한 서브타입</strong>으로 만들 수 있다.<br>\n기존의 <code class=\"language-text\">List&lt;T></code>를 구현하는 <code class=\"language-text\">ArrayList&lt;T></code> 와 다르게 <code class=\"language-text\">List&lt;Boolean>()</code> 에 대한 클래스와 함수를 필요로한다고 가정해보자.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">class AnotherList: List&lt;Boolean&gt;() {\n    override fun get(index: Int): Boolean = ..\n}\n\nval stringList = ArrayList&lt;String&gt;()\nval intList = ArrayList&lt;Int&gt;()\nval anotherList = AnotherList()\n\nfun &lt;T&gt; findFirst(list: List&lt;T&gt;): T = ..\nfun isExist(list: List&lt;Boolean&gt;): Boolean = ..\n\nfindFirst(stringList)\nfindFirst(intList)\nfindFirst(anotherList)\n\nisExist(stringList)     &quot;컴파일 에러&quot;\nisExist(intList)        &quot;컴파일 에러&quot;\nisExist(anotherList)</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">AnotherList</code>와 같이 특정 타입에 대한 서브타입을 지정하여 의도를 직관적으로 표현할 수 있다.</p>\n<h2 id=\"타입-매개변수-제한\" style=\"position:relative;\">타입 매개변수 제한<a href=\"#%ED%83%80%EC%9E%85-%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98-%EC%A0%9C%ED%95%9C\" aria-label=\"타입 매개변수 제한 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>제네릭 함수를 정의한다는 것은 여러 타입으로 사용될 수 있는 함수를 만드는 일이니, <strong>인자로 주어질 값이 특별한 능력을 가진다고 가정할 수 없다.</strong><br>\n반대로 인자가 특별한 능력을 가져야만 한다면 그 함수는 제네릭 함수일 필요가 없다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">open class Person(private val age: Int): Comparable&lt;Person&gt;{\n    override fun compareTo(other: Person): Int = compareValuesBy(this, other, Person::age)\n}\nclass Marathoner(age: Int): Person(age)\n\nfun elder(person: Person, other: Person): Person =\n    if(person &gt; other) person else other\n\nval person: Person = elder(person1, person2)\nval marathoner: Marathoner = elder(marathoner1, marathoner1)    &quot;[1] 컴파일 에러&quot;</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">[1]</code> 컴파일 에러가 난 부분은 <code class=\"language-text\">elder()</code> 함수의 파라미터로 <code class=\"language-text\">Marathoner</code>가 사용되어도 서브타입에 의한 다형성으로 컴파일을 통과하지만 기대하는 반환 타입이 <code class=\"language-text\">Marathoner</code>이기 때문에 컴파일 에러가 발생한다.<br>\n실제로 반환 타입인 <code class=\"language-text\">Person</code>은 <code class=\"language-text\">Marathoner</code>의 서브타입이 아니기 때문이다.</p>\n<p>이때 제네릭 함수를 적용하려 할 수 있다. 하지만 제네릭 타입은 모든 타입을 수용하기 때문에 <code class=\"language-text\">></code> 연산 같은 특별한 능력을 사용할 수 없다.<br>\n이때 <strong>타입 매개변수 제한의 상한(upper bound)</strong> 을 지정하여 <strong>\"T가 최대 Person 타입까지 커질 수 있다.\"</strong> 라는 의미를 부여할 수 있다.<br>\n즉, <strong>T가 Person의 서브타입이다.</strong> 라고 선언하는 것이다. (제네릭 함수뿐 아니라 제네릭 클래스도 마찬가지다.)</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">fun &lt;T: Person&gt; elder(person: T, other: T): T =\n    if(person &gt; other) person else other\n\nval person: Person = elder&lt;Person&gt;(person1, person2)\nval marathoner: Marathoner = elder&lt;Marathoner&gt;(marathoner1, marathoner1)</code>\n        </deckgo-highlight-code>\n<p>위와 같이 상한을 <code class=\"language-text\">&lt;T: Person></code>으로 지정하여 반환 타입으로 <code class=\"language-text\">Marathoner</code>를 받을 수 있고, 특별한 <code class=\"language-text\">></code> 연산을 사용할 수 있게 되었다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">class List&lt;T : Person&gt; {\n    fun get(index: Int): T = TODO()\n}</code>\n        </deckgo-highlight-code>\n<p>위와 같이 <code class=\"language-text\">List&lt;T></code>의 상한을 <code class=\"language-text\">Person</code>으로 제한했다고 해서 <code class=\"language-text\">List&lt;Marathoner></code>가 <code class=\"language-text\">List&lt;Person></code>의 서브타입이라고 보장하진 않는다.</p>\n<h2 id=\"둘-이상의-상한-제한\" style=\"position:relative;\">둘 이상의 상한 제한<a href=\"#%EB%91%98-%EC%9D%B4%EC%83%81%EC%9D%98-%EC%83%81%ED%95%9C-%EC%A0%9C%ED%95%9C\" aria-label=\"둘 이상의 상한 제한 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>기본적으로 <code class=\"language-text\">&lt;></code>에 하나의 상한만 지정이 가능하지만 <strong>코틀린에서는 둘 이상의 상한이 필요한 경우 <code class=\"language-text\">where</code>을 사용할 수 있다.</strong><br>\n<strong>전달된 유형은 절의 모든 조건을 동시에 만족해야한다.</strong> 아래의 예제를 확인해보자.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 476px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/a31fce48b48f12a00340d2c7fc9b87e6/f2205/intersection.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 55.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB+0lEQVR42n2Sa3OaUBCG/f9/pf3QtEkn07SNycR+iE2qUVEEhrugCN6IoFyeHjAxTSftzrzs4TDz7LvLNnpawL2k8yDbSJqH4a0way3/0uoo218j6XPmyy1VlEUpHgc1HpQp3ftbWjfXDKU+eZ7zvyifcpzs0QS8vitfvjdkK6oPhahS3RdJSmqqPGodoS6x2iExJBLHIewrhAOFSFLwOjJWT6Gc+WS+R+5NyH2fxvgILOqcTT1W6hW7lUEaaaQLk8dpG7s/wFNnhE5A5ITYQwdj5Ap7OUWaCpclmW1VwMUr4N63iO02VeNZntWudxsTs98jTctj0+l2h28GLzMUUblsjO3XwJ1nkfodhmOFiy/nXF232EQq8l2b88/faDYvOTs75fvXS1zNfwIWL8CRGb3psKqZpgm7TGTh0Br0SbYZ+yxlv0+J1zG+/obDnjY/gPY5WQXxXRZ6i+02JIkDdtslm3kPXcxwNtmwFquyWSU4AjYxDsBCbEaFzCqgG2xQnSX6ZInmx1gjE01WGcgPSKMug+EvZHWMIjpp3xm0fxrctnW6XZs8K/hzb2qHh/eynkNdZTaliON/7t9zJOLPaoaOK1bFcV1mqxVrTaVRPm/lc5UwJHMd8kUozsFRRTgnn8/JgoAyilgaBhfv39E8+cDN6SeaH0+wfrT4DfWnPeKOHHiFAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"intersection\"\n        title=\"\"\n        src=\"/static/a31fce48b48f12a00340d2c7fc9b87e6/f2205/intersection.png\"\n        srcset=\"/static/a31fce48b48f12a00340d2c7fc9b87e6/3684f/intersection.png 225w,\n/static/a31fce48b48f12a00340d2c7fc9b87e6/fc2a6/intersection.png 450w,\n/static/a31fce48b48f12a00340d2c7fc9b87e6/f2205/intersection.png 476w\"\n        sizes=\"(max-width: 476px) 100vw, 476px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">interface Person\ninterface Marathoner\n\nclass Trainer: Person, Marathoner\nclass Developer: Person, Marathoner\n\ninterface Intersection&lt;T&gt; where T : Person, T : Marathoner\n\nfun main() {\n    val person = object : Intersection&lt;Person&gt; {}         &quot;컴파일 에러 (타입 인수가 해당 바운드내에 없습니다.)&quot;\n    val marathoner = object : Intersection&lt;Marathoner&gt; {} &quot;컴파일 에러 (타입 인수가 해당 바운드내에 없습니다.)&quot;\n    val trainer = object : Intersection&lt;Trainer&gt; {}\n    val developer = object : Intersection&lt;Developer&gt; {}\n}</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">Intersection&lt;T></code> 인터페이스를 구현하는 타입은 <code class=\"language-text\">Person</code>와 <code class=\"language-text\">Marathoner</code> 둘 다 만족해야 한다.</p>\n<p>아래와 같이 함수의 인자를 동시에 제한하여 <strong><code class=\"language-text\">CharSequence</code>와 <code class=\"language-text\">Comparable</code>을 구현하는 타입만 받을 수 있는 함수</strong>를 만들수도 있다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">fun &lt;T&gt; copyWhenGenerator(list: List&lt;T&gt;, threshold: T): List&lt;String&gt;\n    where T: CharSequence, T: Comparable&lt;T&gt; = \n        list.filter { it &gt; threshold }.map { it.toString() }\n\ndescribe(&quot;copyWhenGenerator 함수는&quot;) {\n    val param1: Pair&lt;List&lt;String&gt;, String&gt; = listOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;) to &quot;b&quot;\n    val param2: Pair&lt;List&lt;StringBuilder&gt;, StringBuilder&gt; = listOf(\n        StringBuilder(&quot;A&quot;),\n        StringBuilder(&quot;B&quot;),\n        StringBuilder(&quot;C&quot;)\n    ) to StringBuilder(&quot;B&quot;)\n\n    context(&quot;threshold 보다 큰 값만 반환한다.&quot;) {\n\n        copyWhenGenerator(param1.first, param1.second) shouldBe listOf(&quot;c&quot; , &quot;d&quot;)\n        copyWhenGenerator(param2.first, param2.second) shouldBe listOf(&quot;C&quot;)\n    }\n}</code>\n        </deckgo-highlight-code>\n<h2 id=\"가변성\" style=\"position:relative;\">가변성<a href=\"#%EA%B0%80%EB%B3%80%EC%84%B1\" aria-label=\"가변성 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><strong>지금까지 제네릭 함수를 정의할 때는 대개 매개변수 타입과 결과 타입의 관계를 유지해야 한다는 목표가 있었다.</strong><br>\n아래의 <code class=\"language-text\">choose()</code>와 <code class=\"language-text\">elder()</code> 같이 받은 타입을 그대로 <strong>반환</strong>해야 하는 함수는 매개변수에 의한 다형성이 반드시 필요했다.<br>\n반면 인자로 받아 <strong>소비</strong>만하는 <code class=\"language-text\">run()</code>과 같은 함수는 서브타입에 의한 다형성이면 충분하다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">open class Person\nclass Marathoner : Person()\n\nfun &lt;T&gt; choose(v1: T, v2: T): T = if ( .. ) v1 else v2\nfun &lt;T: Person&gt; elder(person: T, other: T): T = if( .. ) person else other\n\nfun run(person: Person) {\n    person.age ..\n}</code>\n        </deckgo-highlight-code>\n<br>\n<p><code class=\"language-text\">Marathoner</code>는 <code class=\"language-text\">Person</code>의 서브타입이 맞지만, <strong><code class=\"language-text\">List&lt;Marathoner></code>는 <code class=\"language-text\">List&lt;Person></code>의 서브타입이 아니기 때문에 <code class=\"language-text\">List&lt;Marathoner></code>와 <code class=\"language-text\">List&lt;Person></code> 타입의 리스트를 모두 사용하기 위한 함수는 <code class=\"language-text\">averageAge</code>함수처럼 제네릭 함수로 정의하고 타입 매개변수 제한을 사용하였다.</strong></p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">fun &lt;T: Person&gt; averageAge(people: List&lt;T&gt;): Int = ..</code>\n        </deckgo-highlight-code>\n<p>하지만 이 방법대로라면 아래와 같은 귀찮은 점이 있다.</p>\n<ol>\n<li><strong><code class=\"language-text\">List&lt;A></code> 타입의 인자를 받는 함수를 정의할 때 마다 매개변수 타입을 <code class=\"language-text\">List&lt;A></code>로 하는 대신, 상한이 <code class=\"language-text\">A</code>인 타입 매개변수 <code class=\"language-text\">T</code>를 정의하고 매개변수 타입을 <code class=\"language-text\">List&lt;T></code>로 해야 한다.</strong></li>\n<li><strong>제네릭 타입의 값을 인자로 받는 모든 함수를 동일하게 제네릭 함수로 만들어야 한다.</strong></li>\n</ol>\n<blockquote>\n<p>그럼 그냥 <code class=\"language-text\">Marathoner</code>가 <code class=\"language-text\">Person</code>의 서브타입인 것처럼 <code class=\"language-text\">List&lt;Marathoner></code>도 <code class=\"language-text\">List&lt;Person></code>의 서브타입이면 안 될까?</p>\n</blockquote>\n<p>즉, <strong>\"B가 A의 서브타입일 때 <code class=\"language-text\">List&lt;B></code>가 <code class=\"language-text\">List&lt;A></code>의 서브타입이라고 인정해주면 안될까?\"</strong><br>\n<code class=\"language-text\">List&lt;Marathoner></code>가 <code class=\"language-text\">List&lt;Person></code>의 서브타입이 된다고 가정하고 ReadOnlyList와 ReadWriteList의 예제를 보자.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">open class Person(val age: Int)\nclass Marathoner(age: Int) : Person(age)\n\n&quot;가지고 있는 원소들을 알려줄 뿐, 원소를 추가하거나 제거할 수 없는 리스트다.&quot;\nabstract class ReadOnlyList&lt;T&gt; {\n    abstract fun get(index: Int): T\n}\n\n&quot;[1]&quot;\nval marathoners: ReadOnlyList&lt;Marathoner&gt; = ..\nval people: ReadOnlyList&lt;Person&gt; = marathoners\nval person = people.get(0)\nperson.age ..</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">[1]</code>의 상황을 보면 <code class=\"language-text\">Marathoner</code>의 객체들로 구성된 <code class=\"language-text\">marathoners</code> 리스트는 <code class=\"language-text\">people</code>에 대입이 가능하고, <code class=\"language-text\">people</code>에서 꺼낸 원소는 <code class=\"language-text\">Person</code> 타입으로 사용할 수 있다.<br>\n런타임에는 <code class=\"language-text\">Marathoner</code> 객체이지만 타입 검사기가 알 수 있는 타입은 <code class=\"language-text\">Person</code>이다.<br>\n하지만 이 상황은 문제가 되지 않는다. Marathoner는 이미 Person의 서브타입이므로 <strong>Marathoner 객체를 Person 객체처럼 사용해도 문제 없다.</strong><br>\n즉, <strong><code class=\"language-text\">ReadOnlyList&lt;Marathoner></code> 를 <code class=\"language-text\">ReadOnlyList&lt;Person></code>으로 취급함으로써 일어날 수 있는 일은 Person 객체를 기대한 곳에서 Marathoner 객체가 나오는 것 뿐이다.</strong></p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">&quot;가지고 있는 원소들을 알려주고 새 원소를 추가할 수 있다.&quot;\nabstract class ReadWriteList&lt;T&gt; {\n    abstract fun get(index: Int): T\n    abstract fun add(element: T)\n}\n\n&quot;[2]&quot;\nval marathoners: ReadWriteList&lt;Marathoner&gt; = ..\nval people: ReadWriteList&lt;Person&gt; = marathoners\npeople.add(Person(..))\n\nval marathoner: Marathoner = marathoners.get(0)</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">[2]</code>의 상황을 보면 <code class=\"language-text\">Marathoner</code>의 객체들로 구성된 <code class=\"language-text\">marathoners</code> 리스트를 <code class=\"language-text\">people</code>에 대입하고, <code class=\"language-text\">people</code>에 <code class=\"language-text\">Person</code>을 추가할 때 <strong>Marathoner와 Person이 같은 리스트를 나태나는 문제가 발생한다.</strong><br>\n<code class=\"language-text\">people</code>에 Marathoner 객체와 Person 객체가 동시에 존재할 수 있게 되면서 <strong><code class=\"language-text\">marathoners</code>에 Person 객체가 추가되게 되었다.</strong><br>\n타입 검사기는 <code class=\"language-text\">marathoners</code>에서 꺼낸 원소의 타입은 <code class=\"language-text\">Marathoner</code>라고 믿고있지만 실제로는 <code class=\"language-text\">Person</code> 객체가 반환될 수 있기 때문에 <strong>타입 안전성을 깨트리는 큰 문제다.</strong></p>\n<p>즉, B가 A의 서브타입일 때<br>\n<code class=\"language-text\">ReadOnlyList&lt;B></code>는 <code class=\"language-text\">ReadOnlyList&lt;A></code>의 서브타입이 가능하지만,<br>\n<code class=\"language-text\">ReadWriteList&lt;B></code>는 <code class=\"language-text\">ReadWriteList&lt;A></code>의 서브타입이 불가능하다는 것이다.</p>\n<blockquote>\n<p>원소 읽기만 허용하면 <code class=\"language-text\">List&lt;B></code>는 <code class=\"language-text\">List&lt;A></code>의 서브타입이 될 수 있지만, 원소 쓰기를 허용하면 서브타입이 될 수 없다.<br>\n이 예제를 이해하면 <strong>PECS : producer-extends, consumer-super</strong> 원칙이 등장한 이유를 이해할 수 있다.</p>\n</blockquote>\n<p>이 내용들로 알 수 있는 사실은 <strong>\"어떤 제네릭 타입은 타입 인자의 서브타입 관계를 보존하지만, 어떤 제네릭 타입은 그렇지 않다.\"</strong> 라는 것이다.<br>\n그러므로 제네릭 타입과 타입 인자 사이의 관계를 분류할 수 있다. 이 분류를 <strong>가변성</strong> 이라고 부른다.</p>\n<p><strong>가변성은 제네릭 타입과 타입 인자 사이의 관계를 뜻하며, 제네릭 타입 사이의 서브타입 관계를 추가로 정의하는 기능이다.</strong><br>\n(하나의 제네릭 타입에서 타입 인자만 다르게 하여 얻은 타입들 사이의 서브타입 관계를 만든다.)</p>\n<h3>공변</h3>\n<p>제네릭 타입이 타인 인자의 서브타입 관계를 보존하는 것이며, <strong>타입 인자가 <code class=\"language-text\">A</code>에서 서브타입인 <code class=\"language-text\">B</code>로 변할 때 <code class=\"language-text\">List&lt;A></code> 역시 <code class=\"language-text\">List&lt;B></code>로 변한다고 말할 수 있다.</strong><br>\n그래서 \"제네릭 타입이 타입 인자와 함께 변한다\"는 뜻을 담아, 이런 가변성을 <strong>공변 (convariance)</strong> 라고 부른다.</p>\n<h3>불변</h3>\n<p>제네릭 타입이 타입 인자의 서브타입 관계를 무시하는 것이며, <strong><code class=\"language-text\">B</code>가 <code class=\"language-text\">A</code>의 서브타입이더라도 <code class=\"language-text\">List&lt;B></code>와 <code class=\"language-text\">List&lt;A></code>는 아무런 관계가 없는 것이다.</strong><br>\n서로 다른 타입인 것이다. 따라서 \"타입 인자가 서브타입으로 변해도 제네릭 타입은 서브타입으로 안 변한다\"는 뜻을 담아, 이런 가변성을 <strong>불변 (invariance)</strong> 이라 부른다.</p>\n<h3>반변</h3>\n<p>반변을 이해하기 위해서는 먼저 <strong>함수와 서브타입</strong> 관계에 대해서 이해해야 한다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">open class Person\nclass Marathoner : Person()\n\nfun selectBySubType(selector: (Marathoner) -&gt; Person) {\n    val person = selector(Marathoner())\n}\n\nfun selectBySuperType(selector: (Person) -&gt; Person) {\n    val person = selector(Person())\n}\n\nval superTypeConsumer: (Person) -&gt; Person = ..\nval subTypeConsumer: (Marathoner) -&gt; Person = ..\n\nselectBySubType(superTypeConsumer)\nselectBySubType(subTypeConsumer)\n\nselectBySuperType(superTypeConsumer)\nselectBySuperType(subTypeConsumer)      &quot;컴파일 에러&quot;</code>\n        </deckgo-highlight-code>\n<p>(결과 타입은 서브타입 관계를 유지하기 때문에 입력으로 받는 타입에 집중하자.)<br>\n위의 예제를 보면 <code class=\"language-text\">(Person) -> Marathoner</code>은 <code class=\"language-text\">(Marathoner) -> Marathoner</code>의 서브타입이 가능하다.<br>\n<strong>\"사람을 인자로 받을 수 있는 함수는 마라토너를 인자로 받을 수 있는 함수다.\"</strong> 가 성립되기 때문이다.</p>\n<p>하지만 그 반대인 <code class=\"language-text\">(Marathoner) -> Marathoner</code>은 <code class=\"language-text\">(Person) -> Marathoner</code>의 서브타입이 아니다.<br>\n<code class=\"language-text\">Marathoner</code>에는 존재하는 속성이나 메서드가 <code class=\"language-text\">Person</code>에는 존재하지 않을 수 있기 때문에 <strong>\"마라토너를 인자로 받을 수 있는 함수는 사람을 인자로 받을 수 있는 함수다.\"</strong> 가 성립되지 않는다.<br>\n타입 검사기가 <code class=\"language-text\">selectBySuperType(subTypeConsumer)</code> 함수를 거부하는 이유를 생각하면 된다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 796px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/b8fd32776c679261a601b162ffd247e4/d48f1/functionSubtype.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 100%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsTAAALEwEAmpwYAAAC6UlEQVR42p1U25KbOhD0jywgCQlxR1wMGHvt7Fad85L//51OS/iyyUMqyUPXGIFHPT09c+jrGpW1aFuHVFu8RQJRLP8Zh0xnSI2FzgporUPCkNTHf0lYMFlrHXJTIi8KWJszNihsBpOqv2Z8mJsW7+6KS3dF13ZYlhnODTgeF/RdhabMEP9NQp2SibQwykJJzbItJGPK8zQ1RLrLwI/fYvGUZJdFBuzv928OxuSITB0QmwYJNY1TgUSl1DZH7C8xBZRgFCZcaDKLLCsheJnIFKUxgZSSKQ5dVSErHbrxhKZf4KYZ8+mE47JhY/zvcsVtu6J1DpnRSJIUUmkiQyIVL1SsiGfCv1M49HUFm9cYJ2o2TBiPK97fP7BdvuF82vBtvOA6XDGOM4q2eDbp2azoLsWjZMGSYj4kQvEGGRgIf5tIA+KI5/H+O0rkFw0f+r0ShqZYWyCxHUTRQ+YO0moIrejLHIra2LzC3jg2ifDfZ7aE0gbCUj9GK3NoEgsJh6aGrRzG+Qw3rpjmleXSRjeWPbF8d8PRrXCDg1I7U19VYE/9BCsTrMrrFxK2RRludP2Epu0Zj1jWM9bThYkmLPUJYzWzYT1Z0ehve4kPywQ97wgJE0/1PmpR/OtUiJf4ifx5aqKvDfli7KqsocoRupmhqxGm5kxzOsq6Q1U1qKuWY1ij0DxPLceypA8LyExD5Sksz2zKZ5Yeujxw2xTUsKdeAzGvGy7XD5zfb/i83fD9839sywUdNZRSIqZWHp6xRxyrgCfD0rve+sVQo24chnFBR+2O/Ygzm7G2R2rbIc30yy6/m2UhDW9SO+KXp+K7TnH0YHWPjz8Hdi88E7Z1A0P9Mreh7GdUPZl2LdqmR1l2aMi6NN5n1Cr3662CNIZ+VfC7NFcF/Zm+utxxBxZlGyzjy93ON4Ljdjrjc/vAxLOqq+k7eS/3NXLRF7u8Fmzmt0cZJqKsuqBfy324dhN35IyhGZBzgXgD/8k+/AFhGEPuNY5zJQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"functionSubtype\"\n        title=\"\"\n        src=\"/static/b8fd32776c679261a601b162ffd247e4/d48f1/functionSubtype.png\"\n        srcset=\"/static/b8fd32776c679261a601b162ffd247e4/3684f/functionSubtype.png 225w,\n/static/b8fd32776c679261a601b162ffd247e4/fc2a6/functionSubtype.png 450w,\n/static/b8fd32776c679261a601b162ffd247e4/d48f1/functionSubtype.png 796w\"\n        sizes=\"(max-width: 796px) 100vw, 796px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">람다 \\ 함수 인자</th>\n<th align=\"center\">selectSuperToSuper</th>\n<th align=\"center\">selectSubToSuper</th>\n<th align=\"center\">selectSuperToSub</th>\n<th align=\"center\">selectSubToSub</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><code class=\"language-text\">(Sub) -> Sub</code></td>\n<td align=\"center\">❌</td>\n<td align=\"center\">O</td>\n<td align=\"center\">❌</td>\n<td align=\"center\">O</td>\n</tr>\n<tr>\n<td align=\"left\"><code class=\"language-text\">(Sub) -> Super</code></td>\n<td align=\"center\">❌</td>\n<td align=\"center\">O</td>\n<td align=\"center\">❌</td>\n<td align=\"center\">❌</td>\n</tr>\n<tr>\n<td align=\"left\"><code class=\"language-text\">(Super) -> Super</code></td>\n<td align=\"center\">O</td>\n<td align=\"center\">O</td>\n<td align=\"center\">❌</td>\n<td align=\"center\">❌</td>\n</tr>\n<tr>\n<td align=\"left\"><code class=\"language-text\">(Super) -> Sub</code></td>\n<td align=\"center\">O</td>\n<td align=\"center\">O</td>\n<td align=\"center\">O</td>\n<td align=\"center\">O</td>\n</tr>\n</tbody>\n</table>\n<p>즉, A가 B의 서브타입일 떄 <code class=\"language-text\">B -> C</code>가 <code class=\"language-text\">A -> C</code>의 서브타입이며 그 반대는 성립하지 않는다.<br>\n따라서 <strong>함수 타입은 매개변수 타입의 서브타입 관계를 뒤집는다.</strong><br>\n결과 타입의 서브타입 관계가 유지된다는 사실은 나름 직관적인것에 비해, 매개변수 타입의 서브타입 관계가 뒤집히는게 이상할 수 있지만 논리적으로 타당하다.<br>\n<code class=\"language-text\">selectSubToSuper</code>의 함수는 4가지의 람다를 모두 허용하는 이유가 <strong>\"함수 타입은 매개변수 타입의 서브타입 관계를 뒤집고 결과 타입의 서브타입 관계는 유지하기 때문이다.\"</strong> ⭐️</p>\n<p>즉, 함수 타입과 결과 타입 사이의 관계는 <strong>공변</strong>이다. 한편 함수 타입과 매개변수 타입 사이의 관계는 공변도 불변도 아니다.<br>\n여기서 <strong>제네릭 타입이 타입 인자의 서브타입 관계를 뒤집는 가변성이 등장한다.</strong></p>\n<p>결과 타입을 <code class=\"language-text\">C</code>로 고정할 때 <code class=\"language-text\">B</code>가 <code class=\"language-text\">A</code>의 서브타입이면 <code class=\"language-text\">B -> C</code>는 <code class=\"language-text\">A -> C</code>의 <strong>슈퍼 타입이다.</strong><br>\n타입 인자가 <code class=\"language-text\">A</code>에서 서브타입인 <code class=\"language-text\">B</code>로 변할 때 <code class=\"language-text\">A -> C</code>는 타입 인자와는 반대 반향으로 움직여 슈퍼 타입인 <code class=\"language-text\">B -> C</code>로 변한다고도 할 수 있다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 900px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/be7b1988a84f607240aa2c956fdab9a4/951a4/variance.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 17.77777777777778%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAlUlEQVR42k2PCw6AIAxDuf9BNX5Q8Q8qNW8JxiXNxsrazS3LonEc1fe9rusy5Jy/fJ6n5nk23Pctgj71cRwKIXw8Mw5imiZVVWWiwzDoeR6r13VVSkn7vpswNYDnH3Olt22buq6TK44EjmUL3GKMJto0jWXvvdq2Na78R/z/djQ4u65rG2QzerixAcEb/ANxUHguwOwFoNA2xvhlrbwAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"variance\"\n        title=\"\"\n        src=\"/static/be7b1988a84f607240aa2c956fdab9a4/1cfc2/variance.png\"\n        srcset=\"/static/be7b1988a84f607240aa2c956fdab9a4/3684f/variance.png 225w,\n/static/be7b1988a84f607240aa2c956fdab9a4/fc2a6/variance.png 450w,\n/static/be7b1988a84f607240aa2c956fdab9a4/1cfc2/variance.png 900w,\n/static/be7b1988a84f607240aa2c956fdab9a4/21482/variance.png 1350w,\n/static/be7b1988a84f607240aa2c956fdab9a4/951a4/variance.png 1355w\"\n        sizes=\"(max-width: 900px) 100vw, 900px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>종합해보자면 <code class=\"language-text\">ReadOnlyList</code>는 원소 타입에 대해 <strong>공변</strong> 이며, <code class=\"language-text\">ReadWriteList</code>는 <strong>불변</strong> 이다.<br>\n마지막으로 함수 타입은 매개변수 타입에 대해서는 <strong>반변</strong> 이고, 결과 타입에 대해서는 <strong>공변</strong> 이다.</p>\n<h3>각 제네릭 타입의 가변성을 결정하는 일반적인 방법</h3>\n<p>논의를 간단하게 만들기 위해 타입 매개변수가 하나뿐인 제네릭 타입만 고려한다.<br>\n제네릭 타임의 이름은 <code class=\"language-text\">G</code>, 타입 매개변수의 이름은 <code class=\"language-text\">T</code>라고 하자.</p>\n<blockquote>\n<p><code class=\"language-text\">G</code>가 <code class=\"language-text\">T</code>를 출력에만 사용하면 <strong>공변</strong> , 입력에만 사용하면 <strong>반변</strong> , 출력과 입력 모두에 사용하면 <strong>불변</strong> 이다.</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th align=\"center\"><code class=\"language-text\">G</code>에 해당하는 타입</th>\n<th align=\"center\"><code class=\"language-text\">T</code>를 출력에 사용(공급자)</th>\n<th align=\"center\"><code class=\"language-text\">T</code>를 입력에 사용(소비자)</th>\n<th align=\"center\"><strong>가변성</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">ReadOnlyList&#x3C;T></td>\n<td align=\"center\">O</td>\n<td align=\"center\">X</td>\n<td align=\"center\"><strong>공변</strong></td>\n</tr>\n<tr>\n<td align=\"center\">ReadWriteList&#x3C;T></td>\n<td align=\"center\">O</td>\n<td align=\"center\">O</td>\n<td align=\"center\"><strong>불변</strong></td>\n</tr>\n<tr>\n<td align=\"center\">Int -> T</td>\n<td align=\"center\">O</td>\n<td align=\"center\">X</td>\n<td align=\"center\"><strong>공변</strong></td>\n</tr>\n<tr>\n<td align=\"center\">T -> Int</td>\n<td align=\"center\">X</td>\n<td align=\"center\">O</td>\n<td align=\"center\"><strong>반변</strong></td>\n</tr>\n</tbody>\n</table>\n<p>즉, <strong>타입 매개변수를 출력에만 사용하는지, 입력에만 사용하는지, 둘 모두에 사용하는지 보면 가변성을 판단할 수 있다.</strong><br>\n타입 매개변수를 사용한 곳에 따라 달라진다는 것이다.</p>\n<h3 id=\"정의할-때-가변성-지정하기\" style=\"position:relative;\">정의할 때 가변성 지정하기<a href=\"#%EC%A0%95%EC%9D%98%ED%95%A0-%EB%95%8C-%EA%B0%80%EB%B3%80%EC%84%B1-%EC%A7%80%EC%A0%95%ED%95%98%EA%B8%B0\" aria-label=\"정의할 때 가변성 지정하기 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>가변성은 각 제네릭 타입의 고유한 속성이다. 따라서 <strong>제네릭 타입을 정의할 때 가변성을 지정하는게 가장 직관적이다.</strong><br>\n개발자는 제네릭 타입의 각 매개변수에 가변성을 표시함으로써 공변, 반변, 불변 중 하나를 고를 수 있다.</p>\n<h3>불변</h3>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">abstract class List&lt;T&gt; {\n    abstract fun length(): Int\n    abstract fun get(index: Int): T\n    abstract fun add(element: T)\n}</code>\n        </deckgo-highlight-code>\n<h3>공변</h3>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">abstract class ReadOnlyList&lt;out T&gt; {\n    abstract fun get(index: Int): T\n}\n\nval marathoners: ReadOnlyList&lt;Marathoner&gt; = ..\nval people: ReadOnlyList&lt;Person&gt; = marathoners\nval person = people.get(0)\n\nfun averageAge(people: ReadOnlyList&lt;Person&gt;): Int = ..\n\naverageAge(marathoners)\naverageAge(people)</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">ReadOnlyList&lt;out T></code>는 해당 타입 매개변수가 출력에만 사용됨을 뜻하며 원소를 추가할 수 없는 대신 공변인 리스트를 정의할 수 있다.<br>\n<code class=\"language-text\">T</code>를 출력에만 사용한다고 했으니, <code class=\"language-text\">T</code>를 메서드 결과 타입으로 사용할 수 있는 있어도 매개변수 타입으로 사용할 수는 없다.<br>\n<code class=\"language-text\">ReadOnlyList</code>는 <strong>공변이므로 타입 인자의 서브타입 관계를 보존한다.</strong></p>\n<p>이제 <code class=\"language-text\">averageAge</code> 함수를 제네릭 함수로 만들지 않고 타입 매개변수 제한없이 사용할 수 있다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 783px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/16c3998ca212b2bd0b7a9d4af61c113e/e51a6/genericOut.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 47.55555555555556%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAACIElEQVR42lWSCU8aURhF+f9/o6klrbUa05q2VtkGZgWhpGosGlkEHBHQYVhmOb2DTVMnuXnztvO+9+7NkaZkX5rGJKsJK/+c8WWBUfuI+9YhfnOfSWufzfUx0W2BqF8lHp8RP15t12f7/gK2TS5NE+KgTzS0SfsG65syF8VdLku7dMx9ru09OvZHknENJjb4JsmgRNIvEXdLRHe29g+ESgQVMPKbpL0y3DlSXYu1aWIST6pcuHnaVp6rn59oWTs0K284V39zb0iCScl9Bj7Rf4s02ajCngHDumAecb9C7JdJZhbJ3GEl8GJUZvrrmKl3wswqMKsWCB2DsF4lbKm9KLK+E7z/neihTY5hQzCXdFBTVao0EHzuwrNHMrUJmyVCyxTEYSGt6h6BrXHX2Y4tbUd9g2XnlI2g/4BxX5XNdd0n7wW4cAmvdLrj4RslrHdv8d7naXx4j5PfwZZc9Ttfv7BpNFh4NRY3h7pyt0IGTQcW0bioytwXaOCx0VxQq7D26qwarqpzWdadV+2qoTm3wdw8UEK8zJQWidxi4MqQDFraviFPWZUe69uKGsmqsXQFcD2W2QHSUlcOzAJza49QccqczqXyOrM9GgnYq5B2DeLeKfGwSOIbpDO97UOZVU9mXP4gaH8jODsiaH7muX1AeCOHgy7bzGSxeR3sR+LZb2JFIB55ck7x6CrMvaLyJg3LiodJ5LtEs3OS9fQlf/8F+w96RNZi2cqAkAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"genericOut\"\n        title=\"\"\n        src=\"/static/16c3998ca212b2bd0b7a9d4af61c113e/e51a6/genericOut.png\"\n        srcset=\"/static/16c3998ca212b2bd0b7a9d4af61c113e/3684f/genericOut.png 225w,\n/static/16c3998ca212b2bd0b7a9d4af61c113e/fc2a6/genericOut.png 450w,\n/static/16c3998ca212b2bd0b7a9d4af61c113e/e51a6/genericOut.png 783w\"\n        sizes=\"(max-width: 783px) 100vw, 783px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">abstract class ReadOnlyList&lt;T&gt; {\n    abstract fun get(index: Int): T\n}</code>\n        </deckgo-highlight-code>\n<p>위와 같이 선언된 List는 원소를 추가할 수도 없는 주제에 불변이기까지 한 불편한 리스트일 뿐이다.<br>\n<code class=\"language-text\">T</code>를 입력에 사용하는 메서드를 추가하려고 계획 중인 게 아니라면, 굳이 이런 리스트를 정의할 필요는 없다.</p>\n<h3>반변</h3>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">abstract class Map&lt;in K, V&gt; {\n    abstract fun size(): Int\n    abstract fun get(key: K): V\n    abstract fun add(key: K, value: V)\n}</code>\n        </deckgo-highlight-code>\n<p>타입 매개변수를 반변으로 만들고 싶을 때는 <code class=\"language-text\">in</code>을 붙여 <strong>그 타입 매개변수를 입력에만 사용한다는 뜻이다.</strong><br>\n<code class=\"language-text\">abstract fun getKey(value: V): K</code> 이 메서드는 컴파일 에러를 발생시킨다.</p>\n<p><code class=\"language-text\">Map&lt;in K, V></code> 클래스는 두 개의 타입 매개변수를 가지며, <code class=\"language-text\">in</code>으로 가변성이 지정된 <code class=\"language-text\">K</code>는 <code class=\"language-text\">get()</code>과 <code class=\"language-text\">add()</code>에서 입력으로만 사용되었기 때문에 <strong>반변</strong> 으로 정의해도 타입 검사기가 문제 삼지 않는다.<br>\n반면 <code class=\"language-text\">V</code>는 <code class=\"language-text\">get()</code>에서는 출력, <code class=\"language-text\">add()</code>에서는 입력으로 사용되었기 때문에 <strong>반드시 불변이어야 한다.</strong></p>\n<p>열쇠 타입에 대해 반변이므로 <code class=\"language-text\">B</code>가 <code class=\"language-text\">A</code>의 서브타입일 때 <code class=\"language-text\">Map&lt;A, V></code>가 <code class=\"language-text\">Map&lt;B, V></code>의 서브타입이다.<br>\n예를 들면 <code class=\"language-text\">Map&lt;Person, Int></code>가 <code class=\"language-text\">Map&lt;Marathoner, Int></code>의 서브타입이다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">val personKey: Map&lt;Person, Int&gt; = ..\npersonKey.add(Person(10), 1)\npersonKey.add(Marathoner(10), 1)\n\nval marathonerKey: Map&lt;Marathoner, Int&gt; = ..\nmarathonerKey.add(Person(10), 1)        &quot;컴파일 에러&quot;\nmarathonerKey.add(Marathoner(10), 1)</code>\n        </deckgo-highlight-code>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 783px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/6b9822e8b29a39a5df81410ae89c62ce/e51a6/genericIn.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 47.55555555555556%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAACJUlEQVR42k2SiU7bUBBF8//fUVGVqiyNuggUwFmI4y0hhCYFKpTVZIM4OI4d2+907FQVlkbvWfacuTNzCyhF9iiVoKIlm+kdbveS2d1PZu0iL50iy9tTto9nJH2NZFQnmbZIXh5Iw2We9w+QHwWlUhJ/ROwaMLlm3SvRPj+gq32mWz7kyTymb5+wGWiwNEifr0lH5TySQZl4Ykj+WFCpQAUYz29Qw4rATAkH5ZqohQ5vBt7kglv9I/ftI3rOIT3rE16/hFrq7KYCm1VIZxn4Qu5tVLoThcMauI7AbGmnSjyX6qsGam2RrEx8t4wnql+tEp6h4RtVArNG4EjcSPQ0oonAR+fEiw4F3KbALNRYZrMUpb7APUsU2qSvDUkqE5oGkW2ztSy2cga2RWCZhNm7IUWNGts/l+wE+h+YjES+J3Nc23vgRn5+KBM0JLFpE7cc7r8X0Q8+cHv8hV9fT2QqOlHLJpQiG7vO5qkoLQ+qZFA1bhBPZfBv1h7q2+zkm1+v5gkZNHSkiGOKSjO/h02LqOmI0iaefko4t7OltEllW4wt0hy6nyHrTKVN1K/KIdGo5y2GVqbIyWNrSrv6FV7jiGB0nW+6oGTX2drjZwEOq6hBjWR4SeJqpPMaaiWzXVQIh1cEv0v4nTP81g/8m2+8dU4JnmTD/oDcM5lt3hs7DV9ks48kYoHkWeY2qknbV8RDTfwm4VbEHro4wSJedUmj173/3hn7Lx1j2Krz2R/8AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"genericIn\"\n        title=\"\"\n        src=\"/static/6b9822e8b29a39a5df81410ae89c62ce/e51a6/genericIn.png\"\n        srcset=\"/static/6b9822e8b29a39a5df81410ae89c62ce/3684f/genericIn.png 225w,\n/static/6b9822e8b29a39a5df81410ae89c62ce/fc2a6/genericIn.png 450w,\n/static/6b9822e8b29a39a5df81410ae89c62ce/e51a6/genericIn.png 783w\"\n        sizes=\"(max-width: 783px) 100vw, 783px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p><strong>정의할 때 가변성을 지정하는 방법은 이해하기 쉬운 대신 클래스를 정의할 때 큰 제약이 생긴다는 문제가 있다.</strong><br>\n타입을 공변으로 만든다면 타입 매개변수를 입력에 사용하는 절반을 모두 포기해야 하고, 반변으로 만든나면 나머지 절반을 포기해야 한다.<br>\n그러니 공변이나 반변을 선택하면 <strong>반쪽짜리 클래스를 만들 수 밖에 없는 것이다.</strong><br>\n함수형 프로그래밍에서는 대부분의 경우 수정할 수 없는 자료구조만 사용해 프로그램을 작성하기 때문에 함수형 언어에서는 이 단점이 상대적으로 덜 드러난다.</p>\n<h3 id=\"사용할-때-가변성-지정하기\" style=\"position:relative;\">사용할 때 가변성 지정하기<a href=\"#%EC%82%AC%EC%9A%A9%ED%95%A0-%EB%95%8C-%EA%B0%80%EB%B3%80%EC%84%B1-%EC%A7%80%EC%A0%95%ED%95%98%EA%B8%B0\" aria-label=\"사용할 때 가변성 지정하기 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>제네릭 타입을 사용할 때 가변성을 지정하는 경우, 제네릭 타입을 정의할 때는 가변성을 지정할 수 없다.<br>\n<strong>모든 제네릭 타입은 불변으로 정의되며 타입 매개변수를 아무 데서나 사용할 수 있다.</strong></p>\n<h3>불변</h3>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">abstract class ReadWriteList&lt;T&gt; {\n    abstract fun length(): Int\n    abstract fun get(index: Int): T\n    abstract fun add(element: T)\n}</code>\n        </deckgo-highlight-code>\n<h3>공변</h3>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">val onlyReadPeople: ReadWriteList&lt;out Person&gt; = ..\nval size = onlyReadPeople.length()\nval person: Person = onlyReadPeople.get(0)\nonlyReadPeople.add(Person(10)) &quot;컴파일 에러&quot;</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">onlyReadPeople</code>은 출력 기능만 사용할 수 있고, 원소 타입이 매개변수 타입으로 사용되지 않는 메서드만 사용할 수 있다는 뜻이다.<br>\n그리고 <strong>\"A를 출력과 입력에 모두 사용할 수 있는 불변 <code class=\"language-text\">List&lt;A></code>는 A를 출력에 사용할 수 있는 리스트다.\"</strong> 가 사실이기 때문에 <code class=\"language-text\">List&lt;A></code>는 <code class=\"language-text\">List&lt;out A></code>의 서브타입이다.<br>\n<code class=\"language-text\">ReadWriteList&lt;T></code>는 불변이지만 <code class=\"language-text\">ReadWriteList&lt;out Person></code>는 공변이다. 따라서 <strong><code class=\"language-text\">B</code>가 <code class=\"language-text\">A</code>의 서브타입일 때 <code class=\"language-text\">List&lt;out B></code>는 <code class=\"language-text\">List&lt;out A></code>의 서브타입이다.</strong></p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">fun averageAge(people: ReadWriteList&lt;out Person&gt;): Int {\n    people.get(0)\n    people.add(Person(10)) &quot;컴파일 에러&quot;\n}\n\nval onlyReadPeople: ReadWriteList&lt;out Person&gt; = ..\naverageAge(onlyReadPeople)\n\nval onlyReadMarathoners: ReadWriteList&lt;out Marathoner&gt; = ..\naverageAge(onlyReadMarathoners)\n\nval readWriteMarathoner: ReadWriteList&lt;Marathoner&gt; = ..\naverageAge(readWriteMarathoner)</code>\n        </deckgo-highlight-code>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 900px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/0372e7ff130078424ceddb061324fb5c/38124/chainingOut.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 43.55555555555555%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB5ElEQVR42k1S2XLaQBDk//8klVRBnASwzCVucTix8+ALgYQOTscIJ0KwR6cRhMpWTWm1s9vTM90ZnJfWAvttiG34E++uhWTagvKbUFMT2qtD+w3osA0160Et76DebKh4mb77f2W0EhDRBHreR/RUxrj9CY51hei5AcwHBGwhscvYHWNUgnRrLGBCOSXmaixgQW2nF+CMXNzyQhsIBgT4DqzugeUPKK/BB1XEowoL5OD0chh3stg+FrEfGwQ3ED/nET/mIOxvkCyu5Y4MvQ7ANnTYgQ4sRh/SqZKJyQI9Bs/S/BAIm9g8FAmexcT6iFHnA7zhZ+zta0j7CyTJZNRrF3/CGt5DE4d1C3LGr1uAWHewntxgxYjndai5CcG9Wlh4c0tY2kaai7wy9KILMT4yz5PhrwYTZdj3OfzmQ71uY+98RbKoYPZiIHgqYONzbqtmCiiCMsHy8B7yaW5pF3Hwr3F4yUKs7pA5HFULapzbsbVj24O0beHcUNkSz5r8Z4Sc8eyWcyVbr8oc2foG5OTqBMbxaJmQoZaQkQsZ9nmJ80wF6qePtdeFcusnENrnFNw7NQpRSNsUQfussjypfPEh7aN2K6jNCJI+kyHt4LfOapsUqQJJm8iAc14MeY8+TF4vQP98+Beos5JXTnVBiAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"chainingOut\"\n        title=\"\"\n        src=\"/static/0372e7ff130078424ceddb061324fb5c/1cfc2/chainingOut.png\"\n        srcset=\"/static/0372e7ff130078424ceddb061324fb5c/3684f/chainingOut.png 225w,\n/static/0372e7ff130078424ceddb061324fb5c/fc2a6/chainingOut.png 450w,\n/static/0372e7ff130078424ceddb061324fb5c/1cfc2/chainingOut.png 900w,\n/static/0372e7ff130078424ceddb061324fb5c/38124/chainingOut.png 953w\"\n        sizes=\"(max-width: 900px) 100vw, 900px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p><code class=\"language-text\">averageAge()</code> 함수와 같이 새로운 <code class=\"language-text\">&lt;out Person></code> 타입을 통해 함수 내부에서는 출력의 용도로만 사용하겠다고 선언하여 공변으로 지정하여 사용할 수 있다.</p>\n<h3>반변</h3>\n<p><code class=\"language-text\">ReadWriteList&lt;in A></code> 역시 <code class=\"language-text\">ReadWriteList&lt;A></code>와 비슷하게 <code class=\"language-text\">A</code> 타입의 원소들로 구성된 리스트를 나타내지만 <strong>입력 기능만 사용할 수 있다는 차이가 있다.</strong><br>\n정확히 말하면 <strong>메서드 중 원소 타입이 결과 타입으로 사용되지 않는 메서드만 사용할 수 있다.</strong></p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">val readWritePeople: ReadWriteList&lt;in Person&gt; = ..\nval people: Any? = readWritePeople.get(0)\nreadWritePeople.add(Person(10))\nreadWritePeople.add(Marathoner(10))\n\nval readWriteMarathoners: ReadWriteList&lt;in Marathoner&gt; = ..\nval marathoner: Any? = readWriteMarathoners.get(0)\nreadWriteMarathoners.add(Marathoner(10))</code>\n        </deckgo-highlight-code>\n<p><strong>\"A를 출력과 입력에 모두 사용할 수 있는 불변 <code class=\"language-text\">List&lt;A></code>는 A를 입력에 사용할 수 있는 리스트다.\"</strong> 가 사실이기 때문에 <code class=\"language-text\">List&lt;A></code>는 <code class=\"language-text\">List&lt;in A></code>의 서브타입이다.<br>\n따라서 <strong><code class=\"language-text\">B</code>가 <code class=\"language-text\">A</code>의 서브타입일 때 <code class=\"language-text\">List&lt;in A></code>는 <code class=\"language-text\">List&lt;in B></code>의 서브타입이다.</strong></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 900px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/48da0b2963cedd8e26b04c7ad7f470a3/38124/chainingIn.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 43.55555555555555%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB5ElEQVR42k1Si27aQBDk/z+lqgRJ1EDAPEwMmEdQkqqqmhrw2ca8AoEkCo7vMR2bJOpJq1tbtzs7s1PAx9E6xesuwEv8EwffxcvUhgqvoQOb0YZhbuZd6MUAen0HvZ9Av61hjMT/p2C0hH6eIZ27EP0ipt3v8LpFiOElVODCRF0kkzqOHoO3FDZMBiIsArWgY5f14qtxQa3GRO8C8Q1AZGzuGbf8dljQxPvMhhicwR+UMOuX2NSC9C0C1BgVpN4F1JTgyxGMOnLCyAWWQ5i4xyYD0hpB+U1O0uL/AaMPQ5pYjKHDNhA52P+uYeJ+QzguIvHbfE8Q7xyKwxSSxTWeAguHqIXXuIU0biIVFcjHHh5ntTzelixa2pDMNQHUrodd0MBONPJcr1zIaYVsLlF48suY3J8zShC/LnCMWSh+IFk1sPhbxfxPGXuCmY3DhpwkqkNtHSy9KuIHUt52kEZXSB+KkJs7argekQ6prPvAihFTi2hIGjXeFuk6lMHJpchpc+PSr0NHnDas4t07OzWjPEYl1NAoqIMPNR/yAXXMFsQ8KzYhNyjaeZOTfT4sRH3lpEyaV5CZlZ4DZH3yLX/6J7fPcUN/eVDctor7nKJDkJMXVaYXbaLmHajVzcmHyfar0acP/wGdHpKfkVW4jAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"chainingIn\"\n        title=\"\"\n        src=\"/static/48da0b2963cedd8e26b04c7ad7f470a3/1cfc2/chainingIn.png\"\n        srcset=\"/static/48da0b2963cedd8e26b04c7ad7f470a3/3684f/chainingIn.png 225w,\n/static/48da0b2963cedd8e26b04c7ad7f470a3/fc2a6/chainingIn.png 450w,\n/static/48da0b2963cedd8e26b04c7ad7f470a3/1cfc2/chainingIn.png 900w,\n/static/48da0b2963cedd8e26b04c7ad7f470a3/38124/chainingIn.png 953w\"\n        sizes=\"(max-width: 900px) 100vw, 900px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">fun addPerson(people: ReadWriteList&lt;in Person&gt;) {\n    people.add(Person(..))\n    people.add(Marathoner(..))\n}\n\nval readWritePeople1: ReadWriteList&lt;in Person&gt; = ..\nval readWritePeople2: ReadWriteList&lt;Person&gt; = ..\naddPerson(readWritePeople1)\naddPerson(readWritePeople2)\n\nval readWriteMarathoners1: ReadWriteList&lt;in Marathoner&gt; = ..\nval readWriteMarathoners2: ReadWriteList&lt;Marathoner&gt; = ..\naddPerson(readWriteMarathoners1)    &quot;컴파일 에러&quot;\naddPerson(readWriteMarathoners2)    &quot;컴파일 에러&quot;</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">addPerson</code> 함수는 <code class=\"language-text\">ReadWriteList&lt;in Person></code> 반변으로 지정되어 있기 때문에 <code class=\"language-text\">ReadWriteList&lt;Marathoner></code>는 <code class=\"language-text\">Person</code>의 서브타입이긴 하지만 <code class=\"language-text\">addPerson</code>의 인자로 사용될 수 없다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">fun addMarathoner(people: ReadWriteList&lt;in Marathoner&gt;) {\n    people.add(Person(..))      &quot;컴파일 에러&quot;\n    people.add(Marathoner(..))\n}\n\nval readWritePeople1: ReadWriteList&lt;in Person&gt; = ..\nval readWritePeople2: ReadWriteList&lt;Person&gt; = ..\naddMarathoner(readWritePeople1)\naddMarathoner(readWritePeople2)\n\nval readWriteMarathoners1: ReadWriteList&lt;in Marathoner&gt; = ..\nval readWriteMarathoners2: ReadWriteList&lt;Marathoner&gt; = ..\naddMarathoner(readWriteMarathoners1)\naddMarathoner(readWriteMarathoners2)</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">ReadWriteList&lt;in Marathoner></code> 반변으로 지정하면 <code class=\"language-text\">List&lt;Person></code>은 <code class=\"language-text\">List&lt;in Marathoner></code>의 서브타입이기 때문에 <code class=\"language-text\">addMarathoner</code> 함수 호출이 다 가능해진다.<br>\n<code class=\"language-text\">List&lt;in Marathoner></code>에는 <code class=\"language-text\">Marathoner</code>가 보장되어야 하기 때문에 더 작은 의미를 가지는 <code class=\"language-text\">Person</code>을 직접 추가하지는 못한다.<br>\n이는 <strong>Person 리스트에 Marathoner 객체를 추가해도 괜찮고 Marathoner 리스트에 Person 객체를 추가하지 못한다는 직관과 일치한다.</strong></p>\n<h1 id=\"맺으며\" style=\"position:relative;\">맺으며<a href=\"#%EB%A7%BA%EC%9C%BC%EB%A9%B0\" aria-label=\"맺으며 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>여러 종류의 다형성을 이해하고 제네릭 가변성에 대해 알아보았다.<br>\n개인적으로 공변,불변을 제외한 나머지를 반변이라고 설명하는 글들을 많이 접했었는데 이 책에서는 반변을 설명할 때 <strong>함수와 서브타입</strong>에 대한 설명이 독특했다.<br>\n**\"함수 타입은 매개변수 타입의 서브타입 관계를 뒤집는다.\"**는 사실이 반변을 이해할 때 도움이 되었다.</p>\n<p>어려운 제네릭 가변성에 대한 내용을 배워봤지만 제네릭이 능사는 아니다.<br>\n서브타입 관계를 추가하는 대신 기능이 빠진 타입을 만들거나, 기능을 다 갖춘 타입을 만드는 대신 서브타입 관계를 포기하거나, 개발자는 반드시 이 둘 중 하나를 골라야 한다.</p>","frontmatter":{"title":"제네릭 가변성에 대해","date":"February 20, 2024","description":null,"tags":["generic"]},"tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EB%8B%A4%ED%98%95%EC%84%B1\">다형성</a></p>\n<ul>\n<li><a href=\"#%EC%84%9C%EB%B8%8C%ED%83%80%EC%9E%85%EC%97%90-%EC%9D%98%ED%95%9C-%EB%8B%A4%ED%98%95%EC%84%B1\">서브타입에 의한 다형성</a></li>\n<li><a href=\"#%EC%98%A4%EB%B2%84%EB%A1%9C%EB%94%A9%EC%97%90-%EC%9D%98%ED%95%9C-%EB%8B%A4%ED%98%95%EC%84%B1\">오버로딩에 의한 다형성</a></li>\n<li><a href=\"#%EC%98%A4%EB%B2%84%EB%9D%BC%EC%9D%B4%EB%94%A9%EC%97%90-%EC%9D%98%ED%95%9C-%EB%8B%A4%ED%98%95%EC%84%B1\">오버라이딩에 의한 다형성</a></li>\n<li><a href=\"#%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98%EC%97%90-%EC%9D%98%ED%95%9C-%EB%8B%A4%ED%98%95%EC%84%B1\">매개변수에 의한 다형성</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%91%90-%EB%8B%A4%ED%98%95%EC%84%B1%EC%9D%98-%EB%A7%8C%EB%82%A8\">두 다형성의 만남</a></p>\n<ul>\n<li>\n<p><a href=\"#%EC%A0%9C%EB%84%A4%EB%A6%AD-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%EC%83%81%EC%86%8D\">제네릭 클래스와 상속</a></p>\n</li>\n<li>\n<p><a href=\"#%ED%83%80%EC%9E%85-%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98-%EC%A0%9C%ED%95%9C\">타입 매개변수 제한</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%91%98-%EC%9D%B4%EC%83%81%EC%9D%98-%EC%83%81%ED%95%9C-%EC%A0%9C%ED%95%9C\">둘 이상의 상한 제한</a></p>\n</li>\n<li>\n<p><a href=\"#%EA%B0%80%EB%B3%80%EC%84%B1\">가변성</a></p>\n<ul>\n<li><a href=\"#%EC%A0%95%EC%9D%98%ED%95%A0-%EB%95%8C-%EA%B0%80%EB%B3%80%EC%84%B1-%EC%A7%80%EC%A0%95%ED%95%98%EA%B8%B0\">정의할 때 가변성 지정하기</a></li>\n<li><a href=\"#%EC%82%AC%EC%9A%A9%ED%95%A0-%EB%95%8C-%EA%B0%80%EB%B3%80%EC%84%B1-%EC%A7%80%EC%A0%95%ED%95%98%EA%B8%B0\">사용할 때 가변성 지정하기</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%A7%BA%EC%9C%BC%EB%A9%B0\">맺으며</a></p>\n</li>\n</ul>"},"previous":{"fields":{"slug":"/2024y/transaction/"},"frontmatter":{"title":"트랜잭션과 잠금"}},"next":{"fields":{"slug":"/2024y/bookReview/bookReview/"},"frontmatter":{"title":"2024년 책,강의 서평"}}},"pageContext":{"id":"be694c1c-f095-5970-ae40-b324ed2b5259","previousPostId":"099bd161-b615-5200-ab96-c2a0d6a8dfa3","nextPostId":"459e967c-8067-5121-a9e4-07e0de4508d6"}},"staticQueryHashes":["230163734","3589320610"],"slicesMap":{}}