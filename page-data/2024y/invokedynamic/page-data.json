{"componentChunkName":"component---src-templates-blog-post-js","path":"/2024y/invokedynamic/","result":{"data":{"site":{"siteMetadata":{"title":"코딩 주머니"}},"markdownRemark":{"id":"2275afde-24fc-5e5f-a733-7848b131695e","excerpt":"…","html":"<h1 id=\"발단\" style=\"position:relative;\">발단<a href=\"#%EB%B0%9C%EB%8B%A8\" aria-label=\"발단 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>자바와 코틀린에서 람다를 처리하는 방식이 다르다는 것을 알게됐다.<br>\n코틀린을 먼저 확인해보자.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">fun main(args: Array&lt;String&gt;) {\n    val numbers = listOf(1,2,4,5,6,7,8,9)\n    val number = 7\n\n    val result = numbers.filter { it == number }\n}\nprivate fun &lt;T&gt; Iterable&lt;T&gt;.filter(predicate: (T) -&gt; Boolean): Iterable&lt;T&gt; {\n    val destination = arrayListOf&lt;T&gt;()\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}</code>\n        </deckgo-highlight-code>\n<p>위의 확장함수에 람다를 전달하는 코틀린 코드는 아래와 같이 컴파일된다.</p>\n<deckgo-highlight-code language=\"java\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">public final class MainKt {\n   public static final void main(@NotNull String[] args) {\n      ...\n      Iterable result = filter((Iterable)numbers, (Function1)(new Function1() {\n         // $FF: synthetic method\n         // $FF: bridge method\n         public Object invoke(Object var1) {\n            return this.invoke(((Number)var1).intValue());\n         }\n\n         public final boolean invoke(int it) {\n            return it == number;\n         }\n      }));\n   }\n\n   private static final Iterable filter(Iterable $this$filter, Function1 predicate) {\n      ...\n      while(var4.hasNext()) {\n         Object element = var4.next();\n         if ((Boolean)predicate.invoke(element)) {\n            destination.add(element);\n         }\n      }\n      ...\n   }\n}</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">filter()</code>에 전달된 람다가 <code class=\"language-text\">Function1</code> 타입의 인스턴스로 생성되어 <code class=\"language-text\">invoke()</code> 함수를 통해 실행되는 것을 확인할 수 있다.<br>\n이렇게 람다를 함수 유형의 인스턴스로 생성하여 사용하는 것은 단점이 존재한다.</p>\n<ol>\n<li><strong>컴파일러는 익명 클래스에 대응하는 새로운 클래스 파일을 생성화며, 이 클래스를 사용하려면 각각의 클래스를 로드하고 검증하는 과정이 필요하므로 애플리케이션 스타트업의 성능에 악영향을 미친다.</strong></li>\n<li><strong>새로운 익명 클래스는 클래스나 인터페이스의 새로운 서브형식을 만든다.</strong> Comparator를 표현하는 수백 개의 람다가 있다면 결국 수백 가지의 Comparator 서브형식이 생긴다는 의미다.</li>\n</ol>\n<p>코틀린은 자바6 와의 호환성을 위해 기본적으로 람다를 항상 함수 유형의 인스턴스를 생성하여(익명 클래스) 사용하기 때문에 <code class=\"language-text\">inline</code> 키워드를 사용하여 성능상 이점을 누릴 수 있다.<br>\n<code class=\"language-text\">filter()</code> 확장함수에 <code class=\"language-text\">inline</code> 키워드를 추가하면 컴파일러가 람다의 바이트 코드를 삽입하여 주기 때문에 아래와 같이 오버헤드를 줄일 수 있다.</p>\n<deckgo-highlight-code language=\"java\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">public final class MainKt {\n   public static final void main(@NotNull String[] args) {\n      Intrinsics.checkNotNullParameter(args, &quot;args&quot;);\n      List numbers = CollectionsKt.listOf(new Integer[]{1, 2, 4, 5, 6, 7, 8, 9});\n      int number = 7;\n      Iterable $this$filter$iv = (Iterable)numbers;\n      int $i$f$filter = false;\n      ArrayList destination$iv = new ArrayList();\n      Iterator var7 = $this$filter$iv.iterator();\n\n      while(var7.hasNext()) {\n         Object element$iv = var7.next();\n         int it = ((Number)element$iv).intValue();\n         int var10 = false;\n         if (it == number) {\n            destination$iv.add(element$iv);\n         }\n      }\n\n      Iterable result = (Iterable)destination$iv;\n   }\n}</code>\n        </deckgo-highlight-code>\n<h1 id=\"자바-바이트코드-확인하기\" style=\"position:relative;\">자바 바이트코드 확인하기<a href=\"#%EC%9E%90%EB%B0%94-%EB%B0%94%EC%9D%B4%ED%8A%B8%EC%BD%94%EB%93%9C-%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0\" aria-label=\"자바 바이트코드 확인하기 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>코틀린에서는 람다를 사용할 때 생기는 문제를 해결하기 위해 <code class=\"language-text\">inline</code> 키워드를 제공하는 것을 알아보았다.<br>\n그럼 자바는 여전히 함수 인스턴스를 매번 생성해서 사용할까?<br>\n익명 클래스와 람다를 바이트코드로 확인해보자.</p>\n<deckgo-highlight-code language=\"java\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">public class InnerClass {\n    Function&lt;Object, String&gt; toString1 = new Function&lt;Object, String&gt;() {\n        @Override\n        public String apply(Object o) {\n            return o.toString();\n        }\n    };\n    Function&lt;Object, String&gt; toString2 = Object::toString;\n\n    public static void main(String[] args) {\n        InnerClass innerClass = new InnerClass();\n        innerClass.toString1.apply(&quot;test&quot;);\n        innerClass.toString2.apply(&quot;test&quot;);\n    }\n}</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"java\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">public class org.example.InnerClass {\n  java.util.function.Function&lt;java.lang.Object, java.lang.String&gt; toString1;\n  java.util.function.Function&lt;java.lang.Object, java.lang.String&gt; toString2;\n\n  public org.example.InnerClass();\n    Code:\n       0: aload_0\n       1: invokespecial #1      // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V\n       4: aload_0\n       5: new           #2      // class org/example/InnerClass$1\n       8: dup\n       9: aload_0\n      10: invokespecial #3      // Method org/example/InnerClass$1.&quot;&lt;init&gt;&quot;:(Lorg/example/InnerClass;)V\n      13: putfield      #4      // Field toString1:Ljava/util/function/Function;\n      16: aload_0\n      17: invokedynamic #5,  0  // InvokeDynamic #0:apply:()Ljava/util/function/Function;\n      22: putfield      #6      // Field toString2:Ljava/util/function/Function;\n      25: return\n\n  public static void main(java.lang.String[]);\n    Code:\n       0: new           #7      // class org/example/InnerClass\n       3: dup\n       4: invokespecial #8      // Method &quot;&lt;init&gt;&quot;:()V\n       7: astore_1\n       8: aload_1\n       9: getfield      #4      // Field toString1:Ljava/util/function/Function;\n      12: ldc           #9      // String test\n      14: invokeinterface #10,2 // InterfaceMethod java/util/function/Function.apply:(Ljava/lang/Object;)Ljava/lang/Object;\n      19: pop\n      20: aload_1\n      21: getfield      #6      // Field toString2:Ljava/util/function/Function;\n      24: ldc           #9      // String test\n      26: invokeinterface #10,2 // InterfaceMethod java/util/function/Function.apply:(Ljava/lang/Object;)Ljava/lang/Object;\n      31: pop\n      32: return\n}</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">InnerClass$1</code>이라는 이름은 컴파일러가 익명 클래스에 붙인 이름이며, <code class=\"language-text\">new</code> 연산을 통해 메모리를 힙 안에 할당하고, 할당된 위치를 가리키는 참조를 오퍼랜드 스택에 쌓는다.<br>\n그리고 <code class=\"language-text\">invokespecial</code>을 통해 생성자를 호출한다.<br>\n<strong>하지만 람다는 <code class=\"language-text\">invokedynamic</code> 연산만 호출된다.</strong></p>\n<h1 id=\"invokedynamic-이란\" style=\"position:relative;\">invokedynamic 이란?<a href=\"#invokedynamic-%EC%9D%B4%EB%9E%80\" aria-label=\"invokedynamic 이란 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<deckgo-highlight-code language=\"ruby\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">def addtwo(a, b)\n    a + b;\nend</code>\n        </deckgo-highlight-code>\n<p>위의 코드를 컴파일할 때는 a와 b의 형식을 알 수 없듯이 동적 타입 언어 컴파일의 난제는 프로그램이 컴파일된 후 메서드나 함수의 가장 적절한 구현을 선택할 수 있는 런타임 시스템을 구현하는 방법이다.</p>\n<p>자바 7부터 JVM 자체에서 자바 언어뿐만 아니라 다른 언어, 특히 스크립트 언어들과 같이 타입이 고정되어 있지 않은 동적 타입 언어를 지원하기 위해 <code class=\"language-text\">invokedynamic</code>이 추가되었다.<br>\n(이 명령어는 Java 8에서 람다 표현식을 구현하기 위한 기반을 마련했을 뿐만 아니라 동적 언어를 Java 바이트 코드 형식으로 변환하는 데 있어서도 큰 전환점이 되었다.)</p>\n<p>간단하게 <strong>invokedynamic은 특이한 형태의 팩토리 메서드 호출 이라고 생각하면 된다.</strong><br>\n실제 타입은 컴파일 시점에 존재하지 않고 런타임에 필요에 따라 생성되는데, 이 메커니즘을 이해하려면 <code class=\"language-text\">Call sites</code>, <code class=\"language-text\">Method handles</code>, <code class=\"language-text\">Bootstrapping</code>을 이해해야 한다.</p>\n<h2 id=\"call-sites\" style=\"position:relative;\">Call sites<a href=\"#call-sites\" aria-label=\"call sites permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>바이트 코드에서 메서드 호출 명령이 발생하는 위치를 <code class=\"language-text\">call site</code>라고 한다.<br>\n이 메서드 호출에는 다양한 경우의 메서드 호출을 처리하기 위해 (기본적으로) 4가지의 opcode가 존재한다.</p>\n<deckgo-highlight-code language=\"java\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">public class ParentClass {\n    public void printMessage() { System.out.println(&quot;ParentClass&quot;); }\n}\npublic class ChildClass extends ParentClass {\n    @Override\n    public void printMessage() { System.out.println(&quot;ChildClass&quot;); }\n}\n\nabstract class AbstractClass {\n    public void printMessage() { System.out.println(&quot;AbstractClass&quot;); }\n}\npublic class AbstractChildClass extends AbstractClass { }\n\npublic interface Interface {\n    void printMessage();\n}\npublic class ImplementClass implements Interface {\n    @Override\n    public void printMessage() { System.out.println(&quot;ImplementClass&quot;); }\n}\n\npublic class Main {\n\n    public static void printMessage() { System.out.println(&quot;Main&quot;); }\n\n    public static void main(String[] args) {\n        ParentClass parentClass = new ParentClass();\n        parentClass.printMessage();\n\n        ParentClass parentClass1 = new ChildClass();\n        parentClass1.printMessage();\n\n        ChildClass childClass = new ChildClass();\n        childClass.printMessage();\n\n        AbstractClass abstractClass = new AbstractChildClass();\n        abstractClass.printMessage();\n\n        AbstractChildClass abstractClass1 = new AbstractChildClass();\n        abstractClass1.printMessage();\n\n        Interface implementClass = new ImplementClass();\n        implementClass.printMessage();\n\n        ImplementClass implementClass1 = new ImplementClass();\n        implementClass1.printMessage();\n\n        Main.printMessage();\n    }\n}</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"java\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">// javap -v -p -s {class}\nConstant pool:\n  #1 = Methodref          #21.#49        // java/lang/Object.&quot;&lt;init&gt;&quot;:()V\n  #2 = Fieldref           #50.#51        // java/lang/System.out:Ljava/io/PrintStream;\n  #3 = String             #52            // Main\n  #4 = Methodref          #53.#54        // java/io/PrintStream.println:(Ljava/lang/String;)V\n  #5 = Class              #55            // org/example/ParentClass\n  #6 = Methodref          #5.#49         // org/example/ParentClass.&quot;&lt;init&gt;&quot;:()V\n  #7 = Methodref          #5.#56         // org/example/ParentClass.printMessage:()V\n  #8 = Class              #57            // org/example/ChildClass\n  #9 = Methodref          #8.#49         // org/example/ChildClass.&quot;&lt;init&gt;&quot;:()V\n  #10 = Methodref          #8.#56         // org/example/ChildClass.printMessage:()V\n  #11 = Class              #58            // org/example/AbstractChildClass\n  #12 = Methodref          #11.#49        // org/example/AbstractChildClass.&quot;&lt;init&gt;&quot;:()V\n  #13 = Methodref          #59.#56        // org/example/AbstractClass.printMessage:()V\n  #14 = Methodref          #11.#56        // org/example/AbstractChildClass.printMessage:()V\n  #15 = Class              #60            // org/example/ImplementClass\n  #16 = Methodref          #15.#49        // org/example/ImplementClass.&quot;&lt;init&gt;&quot;:()V\n  #17 = InterfaceMethodref #61.#56        // org/example/Interface.printMessage:()V\n  #18 = Methodref          #15.#56        // org/example/ImplementClass.printMessage:()V\n  #19 = Methodref          #20.#56        // org/example/Main.printMessage:()V\n  #20 = Class              #62            // org/example/Main\n  #21 = Class              #63            // java/lang/Object\n  ...\n{\n  public org.example.Main();\n    ...\n\n  public static void printMessage();\n    descriptor: ()V\n    flags: ACC_PUBLIC, ACC_STATIC\n    Code:\n      stack=2, locals=0, args_size=0\n         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;\n         3: ldc           #3                  // String Main\n         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V\n         8: return\n      LineNumberTable:\n        line 5: 0\n\n  public static void main(java.lang.String[]);\n    descriptor: ([Ljava/lang/String;)V\n    flags: ACC_PUBLIC, ACC_STATIC\n    Code:\n      stack=2, locals=8, args_size=1\n         0: new           #5                  // class org/example/ParentClass\n         3: dup\n         4: invokespecial #6                  // Method org/example/ParentClass.&quot;&lt;init&gt;&quot;:()V\n         7: astore_1\n         8: aload_1\n         9: invokevirtual #7                  // Method org/example/ParentClass.printMessage:()V\n        12: new           #8                  // class org/example/ChildClass\n        15: dup\n        16: invokespecial #9                  // Method org/example/ChildClass.&quot;&lt;init&gt;&quot;:()V\n        19: astore_2\n        20: aload_2\n        21: invokevirtual #7                  // Method org/example/ParentClass.printMessage:()V\n        24: new           #8                  // class org/example/ChildClass\n        27: dup\n        28: invokespecial #9                  // Method org/example/ChildClass.&quot;&lt;init&gt;&quot;:()V\n        31: astore_3\n        32: aload_3\n        33: invokevirtual #10                 // Method org/example/ChildClass.printMessage:()V\n        36: new           #11                 // class org/example/AbstractChildClass\n        39: dup\n        40: invokespecial #12                 // Method org/example/AbstractChildClass.&quot;&lt;init&gt;&quot;:()V\n        43: astore        4\n        45: aload         4\n        47: invokevirtual #13                 // Method org/example/AbstractClass.printMessage:()V\n        50: new           #11                 // class org/example/AbstractChildClass\n        53: dup\n        54: invokespecial #12                 // Method org/example/AbstractChildClass.&quot;&lt;init&gt;&quot;:()V\n        57: astore        5\n        59: aload         5\n        61: invokevirtual #14                 // Method org/example/AbstractChildClass.printMessage:()V\n        64: new           #15                 // class org/example/ImplementClass\n        67: dup\n        68: invokespecial #16                 // Method org/example/ImplementClass.&quot;&lt;init&gt;&quot;:()V\n        71: astore        6\n        73: aload         6\n        75: invokeinterface #17,  1           // InterfaceMethod org/example/Interface.printMessage:()V\n        80: new           #15                 // class org/example/ImplementClass\n        83: dup\n        84: invokespecial #16                 // Method org/example/ImplementClass.&quot;&lt;init&gt;&quot;:()V\n        87: astore        7\n        89: aload         7\n        91: invokevirtual #18                 // Method org/example/ImplementClass.printMessage:()V\n        94: invokestatic  #19                 // Method printMessage:()V\n        97: return\n}</code>\n        </deckgo-highlight-code>\n<ul>\n<li><code class=\"language-text\">new</code> : 인자로 지정된 클래스의 새 인스턴스에 필요한 메모리를 힙 안에 할당한다.</li>\n<li><code class=\"language-text\">invokespecial</code> : 생성자 또는 슈퍼 클래스의 생성자를 호출할 때 사용된다.</li>\n<li><code class=\"language-text\">invokevirtual</code> : 상속 관계, 인스턴스의 메서드를 호출할 때 사용되며 동적 디스패치를 통한 런타임 해석을 담당한다.</li>\n<li><code class=\"language-text\">invokeinterface</code> : 인터페이스 관계의 메서드를 호출할 때 사용된다.</li>\n<li><code class=\"language-text\">invokestatic</code> : 정적 메소드를 호출할 때 사용된다.</li>\n</ul>\n<p>자바 바이트코드에서 메서드를 호출하는 invokeinterface, invokespecial, invokestatic, invokevirtual의 4가지 opcode가 존재하며, 이렇게 메서드 호출 명령이 발생하는 위치를 <strong>call site</strong> 라고 한다.<br>\n<code class=\"language-text\">invokedynamic</code>은 <strong>이보다 훨씬 더 나아가 어떤 메서드가 실제로 호출될지 call site별로 결정할 수 있는 메커니즘을 제공한다.</strong><br>\n해당 명령어가 실행되면 JVM은 해당 (실제로 호출하려는 메서드 핸들을 보유한) call site 객체를 찾는다. 만약 이 call site에 도달한 적이 없는 경우 객체를 생성한다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 900px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/87f7a0772e657a29b2c55fe0e4c083c5/8078c/CallSite.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 36.888888888888886%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAABHUlEQVR42p1R7WqDQBD0ORK98+JFEzUaT70mttV6fiRQaKHv/y7T9SgthQZCfwwLN7M7O7cO8zf4Cx4TOD9pmKnHMM4wZsA4TnhuO9zqWeDcHMg3iNMEaZZBlTV6M6LSJyRpBv6fgQtc5sPzBaJ9jGNRkomA6/H7NvxxFd9YtuyGBtfXC97ePyj6ABFIMC5+abkILOxAl3GsPYYVOa+5hOtvCRI8iGi7kEQSYneEzB7BBPEi/OIWXWj1K5cTmE3kRGmOvFAUqYKqT1CVtthGMZKixlGVyBXV8oH+UqMoK0jiDkpbTukGxVKrGrs4gZM1HVqKYnq64jRTrAnjMGGfHKDNhPaltW9mGG3te4MoyXCmy7dda3sWbr5cybDCJ2730Phsf0+UAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"CallSite\"\n        title=\"\"\n        src=\"/static/87f7a0772e657a29b2c55fe0e4c083c5/1cfc2/CallSite.png\"\n        srcset=\"/static/87f7a0772e657a29b2c55fe0e4c083c5/3684f/CallSite.png 225w,\n/static/87f7a0772e657a29b2c55fe0e4c083c5/fc2a6/CallSite.png 450w,\n/static/87f7a0772e657a29b2c55fe0e4c083c5/1cfc2/CallSite.png 900w,\n/static/87f7a0772e657a29b2c55fe0e4c083c5/21482/CallSite.png 1350w,\n/static/87f7a0772e657a29b2c55fe0e4c083c5/d61c2/CallSite.png 1800w,\n/static/87f7a0772e657a29b2c55fe0e4c083c5/8078c/CallSite.png 2218w\"\n        sizes=\"(max-width: 900px) 100vw, 900px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>invokedynamic의 call site는 Java 힙에서 <strong><a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/CallSite.html\">CallSite</a> 객체로</strong> 표현된다.<br>\n람다 표현식은 이 CallSite의 구현 클래스인 <strong>(처음 실행된 후에는 대상 메서드가 변경되지 않는) <code class=\"language-text\">ConstantCallSite</code>를 사용한다.</strong></p>\n<h2 id=\"method-handles\" style=\"position:relative;\">Method Handles<a href=\"#method-handles\" aria-label=\"method handles permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>Java 7은 새로운 API인 <code class=\"language-text\">java.lang.invoke</code>를 도입했다.<br>\n이에 포함되는 <strong><code class=\"language-text\">MethodHandle</code>은 코드가 호출하고자 하는 메서드를 참조하는 클래스이다.</strong><br>\nReflection의 Method 객체와 유사하지만 더 효율적인 리플렉션 메커니즘이라고 볼 수 있다.</p>\n<p>즉, 메서드를 찾고, 조정하고, 호출하기 위한 저수준 메커니즘이다.<br>\n<code class=\"language-text\">MethodHandle</code>을 사용하기 위해서는 4가지를 준비해야 한다.</p>\n<ol>\n<li><strong>Lookup 생성하기</strong></li>\n<li><strong>MethodType 생성하기</strong> : 반환 타입과 매개변수 유형으로 구성되며, 불변이다.</li>\n<li><strong>MethodHandle 찾기</strong> : 원본 클래스와 메서드 이름, MethodType을 Lookup 객체에 제공하여 조회할 수 있다.</li>\n<li><strong>MethodHandle 호출하기</strong></li>\n</ol>\n<deckgo-highlight-code language=\"java\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">public class Main {\n\n    private final List&lt;Integer&gt; numbers;\n\n    public Main(List&lt;Integer&gt; numbers) {\n        this.numbers = numbers;\n    }\n\n    public Integer sum() {\n        return numbers.stream().mapToInt(it -&gt; it).sum();\n    }\n\n    public static void main(String[] args) throws Throwable {\n        // Main의 sum 메서드 실행하기\n        Method sumMethod = Main.class.getDeclaredMethod(&quot;sum&quot;);\n        MethodHandle sum = lookup().unreflect(sumMethod);\n        final Main main = new Main(Arrays.asList(1, 3, 5, 6, 7));\n        Object invoke4 = sum.invoke(main);\n        Object invoke5 = sum.invokeWithArguments(main);\n        Integer invoke6 = (Integer) sum.invokeExact(main);\n        \n        // String의 concat 메서드 실행하기\n        Lookup publicLookup = lookup();\n        MethodType methodType = MethodType.methodType(String.class, String.class);\n        MethodHandle concat = publicLookup.findVirtual(String.class, &quot;concat&quot;, methodType);\n        final String s1 = &quot;who are &quot;;\n        final String s2 = &quot;you?&quot;;\n        Object invoke1 = concat.invoke(s1, s2);\n        Object invoke2 = concat.invokeWithArguments(s1, s2);\n        String invoke3 = (String) concat.invokeExact(s1, s2);\n    }\n}</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"java\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">abstract public class CallSite {\n    static { MethodHandleImpl.initStatics(); }\n\n    // The actual payload of this call site:\n    /*package-private*/\n    MethodHandle target;    // Note: This field is known to the JVM.  Do not change.\n\n    public abstract MethodHandle dynamicInvoker();\n    ...\n}</code>\n        </deckgo-highlight-code>\n<h2 id=\"bootstrapping\" style=\"position:relative;\">Bootstrapping<a href=\"#bootstrapping\" aria-label=\"bootstrapping permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>바이트코드 명령에서 특정 invokedynamic call site가 처음 호출될 때, JVM에는 명령과 연관된 call site 객체가 없기 때문에 어떤 메서드를 대상으로 실행해야 하는지 알지 못한다.<br>\n즉, 이전에 보았던 invokestatic 및 invokespecial의 경우 컴파일 시점에 정확한 호출 대상을 알 수 있지만, invokedynamic은 호출 대상을 모르는 것이다.</p>\n<p><strong>invokedynamic은 <a href=\"https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-4.html#jvms-4.7.23\">BootstrapMethods(BSM)</a>라고하는 동적 특성 호출을 지원하는 추가 정보를 참조한다.</strong><br>\n<strong>특정 invokedynamic call site에 BSM을 연결할 수 있도록</strong> Java 7부터 클래스 파일 형식에 InvokeDynamic라는 새로운 항목 유형이 추가되었다.</p>\n<deckgo-highlight-code language=\"java\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">public class FirstClass {\n    private final Function&lt;String, String&gt; toLowercase = String::toLowerCase;\n    private final Predicate&lt;Character&gt; isUppercase = ch -&gt; ch &gt;= 65 &amp;&amp; ch &lt;= 90;\n\n    public static void main(String[] args) {\n        FirstClass firstClass = new FirstClass();\n        firstClass.toLowercase.apply(&quot;TEST&quot;);\n        firstClass.isUppercase.test(&#39;A&#39;);\n    }\n}</code>\n        </deckgo-highlight-code>\n<details>\n<summary>모든 바이트코드 펼치기</summary>\n<deckgo-highlight-code language=\"java\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">Constant pool:\n   #1 = Methodref          #13.#40        // java/lang/Object.&quot;&lt;init&gt;&quot;:()V\n   #2 = InvokeDynamic      #0:#46         // #0:apply:()Ljava/util/function/Function;\n   #3 = Fieldref           #6.#47         // org/example/FirstClass.toLowercase:Ljava/util/function/Function;\n   #4 = InvokeDynamic      #1:#51         // #1:test:()Ljava/util/function/Predicate;\n   #5 = Fieldref           #6.#52         // org/example/FirstClass.isUppercase:Ljava/util/function/Predicate;\n   #6 = Class              #53            // org/example/FirstClass\n   #7 = Methodref          #6.#40         // org/example/FirstClass.&quot;&lt;init&gt;&quot;:()V\n   #8 = String             #54            // TEST\n   #9 = InterfaceMethodref #55.#56        // java/util/function/Function.apply:(Ljava/lang/Object;)Ljava/lang/Object;\n  #10 = Methodref          #57.#58        // java/lang/Character.valueOf:(C)Ljava/lang/Character;\n  #11 = InterfaceMethodref #59.#60        // java/util/function/Predicate.test:(Ljava/lang/Object;)Z\n  #12 = Methodref          #57.#61        // java/lang/Character.charValue:()C\n  #13 = Class              #62            // java/lang/Object\n  #14 = Utf8               toLowercase\n  #15 = Utf8               Ljava/util/function/Function;\n  #16 = Utf8               Signature\n  #17 = Utf8               Ljava/util/function/Function&lt;Ljava/lang/String;Ljava/lang/String;&gt;;\n  #18 = Utf8               isUppercase\n  #19 = Utf8               Ljava/util/function/Predicate;\n  #20 = Utf8               Ljava/util/function/Predicate&lt;Ljava/lang/Character;&gt;;\n  #21 = Utf8               &lt;init&gt;\n  #22 = Utf8               ()V\n  #23 = Utf8               Code\n  #24 = Utf8               LineNumberTable\n  #25 = Utf8               LocalVariableTable\n  #26 = Utf8               this\n  #27 = Utf8               Lorg/example/FirstClass;\n  #28 = Utf8               main\n  #29 = Utf8               ([Ljava/lang/String;)V\n  #30 = Utf8               args\n  #31 = Utf8               [Ljava/lang/String;\n  #32 = Utf8               firstClass\n  #33 = Utf8               lambda$new$0\n  #34 = Utf8               (Ljava/lang/Character;)Z\n  #35 = Utf8               ch\n  #36 = Utf8               Ljava/lang/Character;\n  #37 = Utf8               StackMapTable\n  #38 = Utf8               SourceFile\n  #39 = Utf8               FirstClass.java\n  #40 = NameAndType        #21:#22        // &quot;&lt;init&gt;&quot;:()V\n  #41 = Utf8               BootstrapMethods\n  #42 = MethodHandle       #6:#63         // invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n  #43 = MethodType         #64            //  (Ljava/lang/Object;)Ljava/lang/Object;\n  #44 = MethodHandle       #5:#65         // invokevirtual java/lang/String.toLowerCase:()Ljava/lang/String;\n  #45 = MethodType         #66            //  (Ljava/lang/String;)Ljava/lang/String;\n  #46 = NameAndType        #67:#68        // apply:()Ljava/util/function/Function;\n  #47 = NameAndType        #14:#15        // toLowercase:Ljava/util/function/Function;\n  #48 = MethodType         #69            //  (Ljava/lang/Object;)Z\n  #49 = MethodHandle       #6:#70         // invokestatic org/example/FirstClass.lambda$new$0:(Ljava/lang/Character;)Z\n  #50 = MethodType         #34            //  (Ljava/lang/Character;)Z\n  #51 = NameAndType        #71:#72        // test:()Ljava/util/function/Predicate;\n  #52 = NameAndType        #18:#19        // isUppercase:Ljava/util/function/Predicate;\n  #53 = Utf8               org/example/FirstClass\n  #54 = Utf8               TEST\n  #55 = Class              #73            // java/util/function/Function\n  #56 = NameAndType        #67:#64        // apply:(Ljava/lang/Object;)Ljava/lang/Object;\n  #57 = Class              #74            // java/lang/Character\n  #58 = NameAndType        #75:#76        // valueOf:(C)Ljava/lang/Character;\n  #59 = Class              #77            // java/util/function/Predicate\n  #60 = NameAndType        #71:#69        // test:(Ljava/lang/Object;)Z\n  #61 = NameAndType        #78:#79        // charValue:()C\n  #62 = Utf8               java/lang/Object\n  #63 = Methodref          #80.#81        // java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n  #64 = Utf8               (Ljava/lang/Object;)Ljava/lang/Object;\n  #65 = Methodref          #82.#83        // java/lang/String.toLowerCase:()Ljava/lang/String;\n  #66 = Utf8               (Ljava/lang/String;)Ljava/lang/String;\n  #67 = Utf8               apply\n  #68 = Utf8               ()Ljava/util/function/Function;\n  #69 = Utf8               (Ljava/lang/Object;)Z\n  #70 = Methodref          #6.#84         // org/example/FirstClass.lambda$new$0:(Ljava/lang/Character;)Z\n  #71 = Utf8               test\n  #72 = Utf8               ()Ljava/util/function/Predicate;\n  #73 = Utf8               java/util/function/Function\n  #74 = Utf8               java/lang/Character\n  #75 = Utf8               valueOf\n  #76 = Utf8               (C)Ljava/lang/Character;\n  #77 = Utf8               java/util/function/Predicate\n  #78 = Utf8               charValue\n  #79 = Utf8               ()C\n  #80 = Class              #85            // java/lang/invoke/LambdaMetafactory\n  #81 = NameAndType        #86:#90        // metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n  #82 = Class              #91            // java/lang/String\n  #83 = NameAndType        #92:#93        // toLowerCase:()Ljava/lang/String;\n  #84 = NameAndType        #33:#34        // lambda$new$0:(Ljava/lang/Character;)Z\n  #85 = Utf8               java/lang/invoke/LambdaMetafactory\n  #86 = Utf8               metafactory\n  #87 = Class              #95            // java/lang/invoke/MethodHandles$Lookup\n  #88 = Utf8               Lookup\n  #89 = Utf8               InnerClasses\n  #90 = Utf8               (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n  #91 = Utf8               java/lang/String\n  #92 = Utf8               toLowerCase\n  #93 = Utf8               ()Ljava/lang/String;\n  #94 = Class              #96            // java/lang/invoke/MethodHandles\n  #95 = Utf8               java/lang/invoke/MethodHandles$Lookup\n  #96 = Utf8               java/lang/invoke/MethodHandles\n{\n  private final java.util.function.Function&lt;java.lang.String, java.lang.String&gt; toLowercase;\n    descriptor: Ljava/util/function/Function;\n    flags: ACC_PRIVATE, ACC_FINAL\n    Signature: #17                          // Ljava/util/function/Function&lt;Ljava/lang/String;Ljava/lang/String;&gt;;\n\n  private final java.util.function.Predicate&lt;java.lang.Character&gt; isUppercase;\n    descriptor: Ljava/util/function/Predicate;\n    flags: ACC_PRIVATE, ACC_FINAL\n    Signature: #20                          // Ljava/util/function/Predicate&lt;Ljava/lang/Character;&gt;;\n\n  public org.example.FirstClass();\n    descriptor: ()V\n    flags: ACC_PUBLIC\n    Code:\n      stack=2, locals=1, args_size=1\n         0: aload_0\n         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V\n         4: aload_0\n         5: invokedynamic #2,  0              // InvokeDynamic #0:apply:()Ljava/util/function/Function;\n        10: putfield      #3                  // Field toLowercase:Ljava/util/function/Function;\n        13: aload_0\n        14: invokedynamic #4,  0              // InvokeDynamic #1:test:()Ljava/util/function/Predicate;\n        19: putfield      #5                  // Field isUppercase:Ljava/util/function/Predicate;\n        22: return\n      LineNumberTable:\n        line 6: 0\n        line 7: 4\n        line 8: 13\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0      23     0  this   Lorg/example/FirstClass;\n\n  public static void main(java.lang.String[]);\n    descriptor: ([Ljava/lang/String;)V\n    flags: ACC_PUBLIC, ACC_STATIC\n    Code:\n      stack=2, locals=2, args_size=1\n         0: new           #6                  // class org/example/FirstClass\n         3: dup\n         4: invokespecial #7                  // Method &quot;&lt;init&gt;&quot;:()V\n         7: astore_1\n         8: aload_1\n         9: getfield      #3                  // Field toLowercase:Ljava/util/function/Function;\n        12: ldc           #8                  // String TEST\n        14: invokeinterface #9,  2            // InterfaceMethod java/util/function/Function.apply:(Ljava/lang/Object;)Ljava/lang/Object;\n        19: pop\n        20: aload_1\n        21: getfield      #5                  // Field isUppercase:Ljava/util/function/Predicate;\n        24: bipush        65\n        26: invokestatic  #10                 // Method java/lang/Character.valueOf:(C)Ljava/lang/Character;\n        29: invokeinterface #11,  2           // InterfaceMethod java/util/function/Predicate.test:(Ljava/lang/Object;)Z\n        34: pop\n        35: return\n      LineNumberTable:\n        line 11: 0\n        line 12: 8\n        line 13: 20\n        line 14: 35\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0      36     0  args   [Ljava/lang/String;\n            8      28     1 firstClass   Lorg/example/FirstClass;\n\n  private static boolean lambda$new$0(java.lang.Character);\n    descriptor: (Ljava/lang/Character;)Z\n    flags: ACC_PRIVATE, ACC_STATIC, ACC_SYNTHETIC\n    Code:\n      stack=2, locals=1, args_size=1\n         0: aload_0\n         1: invokevirtual #12                 // Method java/lang/Character.charValue:()C\n         4: bipush        65\n         6: if_icmplt     22\n         9: aload_0\n        10: invokevirtual #12                 // Method java/lang/Character.charValue:()C\n        13: bipush        90\n        15: if_icmpgt     22\n        18: iconst_1\n        19: goto          23\n        22: iconst_0\n        23: ireturn\n      LineNumberTable:\n        line 8: 0\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0      24     0    ch   Ljava/lang/Character;\n      StackMapTable: number_of_entries = 2\n        frame_type = 22 /* same */\n        frame_type = 64 /* same_locals_1_stack_item */\n          stack = [ int ]\n}\nSourceFile: &quot;FirstClass.java&quot;\nInnerClasses:\n     public static final #88= #87 of #94; //Lookup=class java/lang/invoke/MethodHandles$Lookup of class java/lang/invoke/MethodHandles\nBootstrapMethods:\n  0: #42 invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n    Method arguments:\n      #43 (Ljava/lang/Object;)Ljava/lang/Object;\n      #44 invokevirtual java/lang/String.toLowerCase:()Ljava/lang/String;\n      #45 (Ljava/lang/String;)Ljava/lang/String;\n  1: #42 invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n    Method arguments:\n      #48 (Ljava/lang/Object;)Z\n      #49 invokestatic org/example/FirstClass.lambda$new$0:(Ljava/lang/Character;)Z\n      #50 (Ljava/lang/Character;)Z</code>\n        </deckgo-highlight-code>\n</details>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 900px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/9ae3fccd654513fef2d3095c09ccd3ca/e515d/bsm.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 75.11111111111111%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsTAAALEwEAmpwYAAADOklEQVR42n2TWXPiVhCF/f9/RKqSSio1M3E8GceY8XjDC7sxAiHJWtCCQAgJYbPaYPtLQ2Wq5iGVh1OtbnWf7tv3nj3e1rB+FDz9NzZTVtMRUWDy/vI/eYL3lwl7m0XGLDSZ9R2B/QOcHeaDLv0HBatRYuIb4v+Qt/0ebHNs5pHH1KuxN1/MaA+HtOMR7WSMmmZiU9RIYlFMJ04omxYn9TpN8VX51x4ltCTeGkT/YoASjdC9jhBmMb7eIDRb+OVvuJeHBNUzgkDD9zt4nortdnAclaBxRdgqEiq39DsVBgOLMLIZbBF7dL0qewtTZaLbLA2PrHlPcFWgd3lO2G4z1DQSQ44Zx7zVq4S//4oqSPJHOPuf8C/OyBp1Xk2dd8ui79zJhL7FeD1n9b5hBUziIZ3COW7pGq94TdKsM9XbrE5zjMo33H7eR/l6hFk4Y1gtkt5VeNZbrIU0dLY79CxS2c0sGpPZJknrnkRpkPV84q5DaOhEYY/FXZVlvURUKVI7+IPy/kes8xN6xSsemzU2pvGd0CbpRUz7KenVOV7uCwOZcPCgE0uDsWMxG6espMlKCt8lX/ua4/K3nzn75SfMb3leDZW1oRHaW0LfZrKc8fL6xovc1tTzME5PcAuXu2my+zuWmsoq/zdr2ddGGk3UluxWJxUsPJeXMGDd79P37oXQtXCSLt7Yp2fUcAMVw23SDTXa4teaN9y1izglaeJI3JaLU0t4WYAvNb5YL/XED7EDmXChK2idApp2zcPtZ+xmAfUij3Ke26GaO6B8uI95cYxxc4rbaeApNRw5mSWCaEfKDq2hKu+wKBPOH+kMWnQSHUM5JdSqmPk89Y8fUA+/0P7rM8rBn/iXFzgnJ6SVMk/ynCbZI8MkQhWizrCNGmsYXmlLOEEdKKIIFTWoEzzUUfLHXH36QOP4iG7xBr9Swi3f4pXlUTdFBIHPOE2Jkr4QyjACNe4I4XbCxZNIT0MdPdAa6XhPEePpgl6c0hulxJMnJotnstmSbL5kLHbyNGP1vCGdPYpkdak1RK4merBVyjRGswvo3VvBDYbYrYTcoLZD16/iiL+NfbfbmO1WsNzyrkbvXqO5RUwjxz8ojTDV7F2nHQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"bsm\"\n        title=\"\"\n        src=\"/static/9ae3fccd654513fef2d3095c09ccd3ca/1cfc2/bsm.png\"\n        srcset=\"/static/9ae3fccd654513fef2d3095c09ccd3ca/3684f/bsm.png 225w,\n/static/9ae3fccd654513fef2d3095c09ccd3ca/fc2a6/bsm.png 450w,\n/static/9ae3fccd654513fef2d3095c09ccd3ca/1cfc2/bsm.png 900w,\n/static/9ae3fccd654513fef2d3095c09ccd3ca/21482/bsm.png 1350w,\n/static/9ae3fccd654513fef2d3095c09ccd3ca/e515d/bsm.png 1430w\"\n        sizes=\"(max-width: 900px) 100vw, 900px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>즉, <code class=\"language-text\">#2</code>와 <code class=\"language-text\">#4</code>의 상수는 <code class=\"language-text\">CONSTANT_InvokeDynamic</code> 유형의 상수이며, 이 call site의 bootstrap method는 상수 풀의 <code class=\"language-text\">#42</code> 항목이다.<br>\n<strong>BSM으로 사용될 메서드 핸들은 <code class=\"language-text\">LambdaMetafactory.metafactory(...)</code>이다.</strong></p>\n<deckgo-highlight-code language=\"java\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">public class LambdaMetafactory {\n    /**\n     * 적절한 유형 조정 및 인수의 부분 평가 후 제공된 MethodHandle에 대한 위임을 통해 하나 이상의 인터페이스를 구현하는 간단한 &quot;함수 개체&quot; 생성을 용이하게 합니다.\n     * 일반적으로 Java 프로그래밍 언어의 람다식 및 메서드 참조식 기능을 지원하기 위해 invokedynamic 호출 ​​사이트의 부트스트랩 메서드로 사용됩니다.\n     * 이 메서드에서 반환된 CallSite의 대상이 호출되면 결과 함수 객체는 invokedType의 반환 유형으로 명명된 인터페이스를 구현하고, invokedName으로 지정된 이름과 samMethodType으로 지정된 서명으로 메서드를 선언하는 클래스의 인스턴스입니다.\n     */\n    public static CallSite metafactory(MethodHandles.Lookup caller,\n                                       String invokedName,\n                                       MethodType invokedType,\n                                       MethodType samMethodType,\n                                       MethodHandle implMethod,\n                                       MethodType instantiatedMethodType)\n            throws LambdaConversionException {\n        AbstractValidatingLambdaMetafactory mf;\n        mf = new InnerClassLambdaMetafactory(caller, invokedType,\n                                             invokedName, samMethodType,\n                                             implMethod, instantiatedMethodType,\n                                             false, EMPTY_CLASS_ARRAY, EMPTY_MT_ARRAY);\n        mf.validateMetafactoryArgs();\n        return mf.buildCallSite();\n    }\n    ...\n}</code>\n        </deckgo-highlight-code>\n<p><strong>BSM은 이 정적 메서드를 호출하여 CallSite 객체를 반환하며, invokedynamic 명령이 실행되면 CallSite에 포함된 MethodHandle은 람다의 대상 유형을 구현하는 클래스의 인스턴스를 반환한다.</strong></p>\n<h1 id=\"bsm-만들어보기\" style=\"position:relative;\">BSM 만들어보기<a href=\"#bsm-%EB%A7%8C%EB%93%A4%EC%96%B4%EB%B3%B4%EA%B8%B0\" aria-label=\"bsm 만들어보기 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<deckgo-highlight-code language=\"java\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">public class Ops {\n    public static Integer adder(Integer x, Integer y) {\n        return x + y;\n    }\n    public static String adder(String x, String y) {\n        return x + y;\n    }\n}\n\nclass MethodHandleTest {\n\n    // 이 메서드는 호출된 invokedynamic call site를  adder 메서드에 연결하는 부트스트랩 메서드이다.\n    public static CallSite mybsm(MethodHandles.Lookup callerClass, String dynamicMethodName, MethodType dynamicMethodType) throws Throwable {\n        // adder 메서드에 대한 정적 메서드 핸들을 생성한다.\n        MethodHandle methodHandle = callerClass.findStatic(\n            Ops.class,\n            dynamicMethodName,\n            dynamicMethodType\n        );\n        return new ConstantCallSite(methodHandle);\n    }\n\n    @Test\n    void intAdder() throws Throwable {\n        CallSite adder = mybsm(lookup(), &quot;adder&quot;, MethodType.methodType(Integer.class, Integer.class, Integer.class));\n        MethodHandle methodHandle = adder.dynamicInvoker();\n\n        assertThat(methodHandle.invoke(1, 7)).isEqualTo(8);\n    }\n\n    @Test\n    void stringAdder() throws Throwable {\n        CallSite adder = mybsm(lookup(), &quot;adder&quot;, MethodType.methodType(String.class, String.class, String.class));\n        MethodHandle methodHandle = adder.dynamicInvoker();\n\n        assertThat(methodHandle.invoke(&quot;1&quot;, &quot;7&quot;)).isEqualTo(&quot;17&quot;);\n    }\n\n    @Test\n    void wrongAdder() {\n        assertThatThrownBy(() -&gt;\n            mybsm(lookup(), &quot;adder&quot;, MethodType.methodType(Integer.class, String.class, String.class))\n        ).isExactlyInstanceOf(NoSuchMethodException.class);\n    }\n}</code>\n        </deckgo-highlight-code>\n<blockquote>\n<p><code class=\"language-text\">java.lang.invoke.MethodHandles</code> 및 <code class=\"language-text\">java.lang.invoke.MethodHandle</code> 클래스에는 기존 메서드 핸들을 기반으로 메서드 핸들을 생성하는 다양한 메서드가 포함되어 있다.<br>\n런타임 시스템에서 사용할 수 있는 메서드가 여러 개 있고 각각 다른 인수 유형을 처리하는 경우 부트스트랩 메서드 mybsm은 <strong>dynamicMethodType 인수에 따라 메서드를 동적으로 선택할 수 있다.</strong><br>\ninvokedynamic 명령어는 컴파일러와 런타임 시스템의 동적 언어 구현을 단순화하며, 이는 Java 클래스 및 인터페이스에 특정한 연결 동작이 JVM에 의해 하드와이어링 되는 invokevirtual과 같은 다른 JVM 명령어와 대조된다.</p>\n</blockquote>\n<p>부트스트랩 메서드가 반환하는 <code class=\"language-text\">ConstantCallSite</code> 인스턴스는 호출된 <strong>invokedynamic 명령어</strong>와 <strong>연결할 CallSite</strong>를 의미하며 고유하다. ConstantCallSite 인스턴스의 대상(target)은 영구적이며 절대 변경할 수 없다.</p>\n<p>invokedynamic 명령으로 동적으로 연결된 메서드를 호출하려면 아래의 단계가 필요하다.</p>\n<ol>\n<li><strong>Defining the Bootstrap Method</strong> (부트스트랩 메서드 정의하기)</li>\n<li><strong>Specifying Constant Pool Entries</strong> (상수 풀 항목 지정하기)</li>\n<li><strong>Using the invokedynamic Instruction</strong> (호출된 동적 인스트럭션 사용)</li>\n</ol>\n<h2 id=\"부트스트랩-메서드-정의하기\" style=\"position:relative;\">부트스트랩 메서드 정의하기<a href=\"#%EB%B6%80%ED%8A%B8%EC%8A%A4%ED%8A%B8%EB%9E%A9-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%A0%95%EC%9D%98%ED%95%98%EA%B8%B0\" aria-label=\"부트스트랩 메서드 정의하기 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>JVM이 런타임에 invokedynamic 명령을 '처음'만나면 부트스트랩 메서드를 호출한다.<br>\n이 부트스트랩 메서드는 동적으로 입력된 언어에 대해 컴파일러가 지정한 메서드로, JVM에서 site를 연결하기 위해 한 번 호출된다.<br>\n그리고 호출된 invokedynamic 명령어에 지정된 이름을 실행해야 하는 코드(대상 메서드)와 MethodHandle에 의해 참조되는 메서드를 연결한다.<br>\n부트스트랩 메서드의 반환 유형은 <code class=\"language-text\">java.lang.invoke.CallSite</code>여야 한다.</p>\n<p>즉, CallSite 객체는 호출된 invokedynamic 명령의 연결된 상태와 연결된 메서드 핸들을 나타낸다.<br>\n<strong>JVM이 동일한 호출된 동적 명령어를 다시 실행하면 부트스트랩 메서드를 호출하지 않고 연결된 메서드 핸들을 자동으로 호출한다.</strong></p>\n<p>컴파일러는 람다 식을 캡처하기 위해 생성하는 코드는 람다 식 자체와 해당 식이 할당되는 함수형 인터페이스 유형에 따라 달라진다.<br>\n람다 식을 구현하는 객체를 생성하기 위해 바이트코드를 생성하는 대신(예: 내부 클래스의 생성자 호출), 람다를 구성하는 레시피를 설명하고 실제 구성은 언어 런타임에 위임합니다. 이 레시피는 호출된 동적 명령어의 정적 및 동적 인수 목록에 인코딩됩니다.</p>\n<p>호출된 다이나믹을 사용하면 번역 전략 선택을 런타임까지 연기할 수 있습니다. 런타임 구현은 람다 식을 평가하기 위해 동적으로 전략을 자유롭게 선택할 수 있습니다. 런타임 구현 선택은 람다 구성을 위한 표준화된(즉, 플랫폼 사양의 일부인) API 뒤에 숨겨져 있으므로 정적 컴파일러는 이 API에 대한 호출을 내보낼 수 있으며, JRE 구현은 선호하는 구현 전략을 선택할 수 있습니다. 호출된 동적 메커니즘을 사용하면 이러한 후기 바인딩 접근 방식이 부과할 수 있는 성능 비용 없이 이 작업을 수행할 수 있습니다.</p>\n<p>컴파일러는 람다 표현식을 만나면 먼저 람다 본문을 람다 표현식의 인자 목록과 반환 유형이 일치하는 메서드로 낮추고(설탕 제거), 추가 인자(있는 경우 어휘 범위에서 캡처한 값)를 추가합니다. 람다 표현식이 캡처되는 지점에서 호출된 invokedynamic call site를 생성하고, 호출되면 람다가 변환되는 함수형 인터페이스의 인스턴스를 반환합니다. 이 호출 사이트를 주어진 람다에 대한 람다 팩토리라고 합니다. 람다 팩토리에 대한 동적 인수는 어휘 범위에서 캡처된 값입니다. 람다 팩토리의 부트스트랩 메서드는 Java 언어 런타임 라이브러리에서 람다 메타팩토리라고 하는 표준화된 메서드입니다. 정적 부트스트랩 인수는 컴파일 시점에 람다에 대해 알려진 정보(변환될 함수 인터페이스, 파생된 람다 본문에 대한 메서드 핸들, SAM 유형이 직렬화 가능한지 여부에 대한 정보 등)를 캡처합니다.</p>\n<p>람다 팩토리의 부트스트랩 메서드는 람다 메타팩토리라고 하는 Java 언어 런타임 라이브러리의 표준화된 메서드입니다. 정적 부트스트랩 인수는 컴파일 시점에 람다에 대해 알려진 정보(변환될 함수 인터페이스, 디서깅된 람다 본문에 대한 메서드 핸들, SAM 유형이 직렬화 가능한지 여부에 대한 정보 등)를 캡처합니다.</p>\n<p>메서드 참조는 람다 표현식과 동일한 방식으로 처리되지만, 대부분의 메서드 참조를 새 메서드로 디서깅할 필요가 없으며 참조된 메서드의 상수 메서드 핸들을 로드하여 메타팩토리로 전달하면 됩니다.</p>\n<p><code class=\"language-text\">invokedynamic</code>은 메서드를 호출할 때 <strong>더 깊은 수준의 재전송과 동적 언어에 의존하는 로직이 대상 호출을 결정할 수 있는 기능을 제공한다.</strong></p>\n<p>실제 호출할 메서드를 결정하는 언어 종속적 로직을 구현하는 부트스트랩 메서드의 형태로 구성된다.<br>\n부트스트랩 메서드는 연결된 CallSite를 반환한다.<br>\n두 개의 int로 add 메서드를 호출하면 이후로 이어지는 호출에도 두 개의 int가 전달된다.<br>\n결과적으로 매 호출마다 호출할 메서드를 다시 찾을 필요가 없다.<br>\n호출 사이트는 언제 호출 연결을 다시 계산해야 하는지 정의하는 로직을 포함할 수 있다.</p>\n<p><code class=\"language-text\">invokedynamic</code>으로 람다 표현식을 바이트코드로 변환하는 작업을 런타임까지 고의로 지연했다.<br>\n즉, 이 같은 방식으로 람다 표현식을 구현하는 코드의 생성을 런타임으로 미룰 수 있다.<br>\n이러한 설계 덕분에 다음과 같은 장점을 얻게 된다.</p>\n<ol>\n<li>람다 표현식의 바디를 바이트코드로 변환하는 작업이 독립적으로 유지된다.\n<ul>\n<li>따라서 변환 작업이 동적으로 바뀌거나 나중에 JVM 구현에서 이를 더 최적화하거나 변환 작업을 고칠 수 있다.</li>\n<li>변환 작업은 독립적이므로 바이트코드의 과거버전 호환성을 염려할 필요가 없다.</li>\n</ul>\n</li>\n<li>람다 덕분에 추가적인 필드나 정적 초기자 등의 오버헤드가 사라진다.</li>\n<li>상태 없는(캡처하지 않는) 람다에서 람다 객체 인스턴스를 만들고, 캐시하고, 같은 결과를 반환할 수 있다.\n<ul>\n<li>자바 8 이전에도 사람들은 이런 방식을 사용했다.</li>\n<li>예를 들어, 정적 final 변수에 특정 Comparator 인스턴스를 선언할 수 있다.</li>\n</ul>\n</li>\n<li>람다를 처음 실행할 때만 반환과 결과 연결 작업이 실행되므로 추가적인 성능 비용이 들지 않는다.\n<ul>\n<li>즉, 두 번째 호출부터는 이전 호출에서 연결된 구현을 바로 이용할 수 있다.</li>\n</ul>\n</li>\n</ol>\n<p>상태를 포함하지 않는 람다는 컴파일러가 람다 표현식과 같은 시그니처를 갖는 메서드를 생성한다.<br>\n만약 상태를 포함한다면 그 상태를 람다 표현식의 인수에 캡처한 각 변수를 추가하는 것이다.</p>\n<h1 id=\"참고\" style=\"position:relative;\">참고<a href=\"#%EC%B0%B8%EA%B3%A0\" aria-label=\"참고 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<ul>\n<li><a href=\"https://docs.oracle.com/javase/8/docs/technotes/guides/vm/multiple-language-support.html\">Java Virtual Machine Support for Non-Java Languages</a></li>\n<li><a href=\"https://homoefficio.github.io/2019/01/31/Back-to-the-Essence-Java-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EC%97%90%EC%84%9C-%EC%8B%A4%ED%96%89%EA%B9%8C%EC%A7%80-2/\">Back to the Essence - Java 컴파일에서 실행까지 - (2)</a></li>\n<li><a href=\"https://blogs.oracle.com/javamagazine/post/behind-the-scenes-how-do-lambda-expressions-really-work-in-java\">Behind the scenes: How do lambda expressions really work in Java?</a></li>\n<li><a href=\"https://blogs.oracle.com/javamagazine/post/understanding-java-method-invocation-with-invokedynamic\">Understanding Java method invocation with invokedynamic</a></li>\n<li><a href=\"https://blogs.oracle.com/javamagazine/post/mastering-the-mechanics-of-java-method-invocation\">Mastering the mechanics of Java method invocation</a></li>\n<li><a href=\"https://dzone.com/articles/dismantling-invokedynamic\">Dismantling invokedynamic</a></li>\n<li><a href=\"https://cr.openjdk.org/~briangoetz/lambda/lambda-translation.html\">Translation of Lambda Expressions</a></li>\n<li><a href=\"https://www.baeldung.com/java-method-handles\">Baeldung : Method Handles in Java</a></li>\n<li><a href=\"https://www.baeldung.com/kotlin/inline-functions\">Inline Functions in Kotlin</a></li>\n<li><a href=\"https://d2.naver.com/helloworld/1230\">JVM Internal</a></li>\n<li><a href=\"https://m.yes24.com/Goods/Detail/77125987\">모던 자바 인 액션</a> : 부록 D</li>\n<li><a href=\"https://jcp.org/en/jsr/detail?id=292\">JSR 292: Supporting Dynamically Typed Languages on the JavaTM Platform</a></li>\n<li><a href=\"https://discuss.kotlinlang.org/t/why-kotlin-decompiler-generates-null-instance/10426\">Why Kotlin decompiler generates null.INSTANCE</a></li>\n</ul>","frontmatter":{"title":"invokedynamic 이란? (작성 중)","date":"June 08, 2024","description":null,"tags":["java"]},"tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EB%B0%9C%EB%8B%A8\">발단</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%9E%90%EB%B0%94-%EB%B0%94%EC%9D%B4%ED%8A%B8%EC%BD%94%EB%93%9C-%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0\">자바 바이트코드 확인하기</a></p>\n</li>\n<li>\n<p><a href=\"#invokedynamic-%EC%9D%B4%EB%9E%80\">invokedynamic 이란?</a></p>\n<ul>\n<li><a href=\"#call-sites\">Call sites</a></li>\n<li><a href=\"#method-handles\">Method Handles</a></li>\n<li><a href=\"#bootstrapping\">Bootstrapping</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#bsm-%EB%A7%8C%EB%93%A4%EC%96%B4%EB%B3%B4%EA%B8%B0\">BSM 만들어보기</a></p>\n<ul>\n<li><a href=\"#%EB%B6%80%ED%8A%B8%EC%8A%A4%ED%8A%B8%EB%9E%A9-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%A0%95%EC%9D%98%ED%95%98%EA%B8%B0\">부트스트랩 메서드 정의하기</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%B0%B8%EA%B3%A0\">참고</a></p>\n</li>\n</ul>"},"previous":{"fields":{"slug":"/2024y/bookReview/bookReview/"},"frontmatter":{"title":"2024년 기록"}},"next":null},"pageContext":{"id":"2275afde-24fc-5e5f-a733-7848b131695e","previousPostId":"459e967c-8067-5121-a9e4-07e0de4508d6","nextPostId":null}},"staticQueryHashes":["230163734","3589320610"],"slicesMap":{}}