{"componentChunkName":"component---src-templates-blog-post-js","path":"/2024y/testcontainers/","result":{"data":{"site":{"siteMetadata":{"title":"코딩 주머니"}},"markdownRemark":{"id":"ea381821-0e81-57aa-a137-69da08df90d1","excerpt":"CI/CD를 고민하면서 서로 의존 관계에 있는 서비스들은 통합 테스트를 어떻게 진행할지 생각해본적이 있다.  위의 그림에서 A 서비스 를 수정하고 배포한다고 가정할 때 사용자의 요청을 처리하기 위해 이해관계에 놓여있는 B 서비스와 DB…","html":"<p>CI/CD를 고민하면서 서로 의존 관계에 있는 서비스들은 통합 테스트를 어떻게 진행할지 생각해본적이 있다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 773px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/da0ac8e27aa0636db1e07073b18aeda4/612f7/mocking.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 64.44444444444444%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAABaUlEQVR42o2Th67CMAxF+/8fBxKIVQpllkKB7sW6z9cQVMETEMmqmjjH1yMWflx5nsNxHGw2G3ieh/l8jvV6rWe32+3pZ30DGeckSZ6gVquFNE31vwn7CfigIokiBRC83+8Rx/FT4Ufga0RdZYl0t4MzGCAIAjXCIwnyBrxcLgp5Ne6zbkVRoBRzRyNUoqoU+PF41Muu6yq8qir15ZnFQ26YwpuoTIe23W6xE3OnU2RSN/oY4OFwwEgCGdXj8RgWHa7XK7Isw2QywXA4VMhqtVJ4p9NRJaydCW6Cso70s21bJ2CxWMCiY13XCmWaxuhIAI0XAzYiDFE8wFyh/C+XSz0nR4FUdj6f35pCJb7v39MRxd12G7UoKwUSCoDrdDrdSyINo9H3+xw+vjG73O/Dly8DMQM24a3L/45JQ21zsAmicqaaS+ebL8XYzy+FjSCIY9Tr9XSPKr8O9qe3zG7OZjN9fuwqh/sV+Ad6CO3tvGsMGwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"mocking\"\n        title=\"\"\n        src=\"/static/da0ac8e27aa0636db1e07073b18aeda4/612f7/mocking.png\"\n        srcset=\"/static/da0ac8e27aa0636db1e07073b18aeda4/3684f/mocking.png 225w,\n/static/da0ac8e27aa0636db1e07073b18aeda4/fc2a6/mocking.png 450w,\n/static/da0ac8e27aa0636db1e07073b18aeda4/612f7/mocking.png 773w\"\n        sizes=\"(max-width: 773px) 100vw, 773px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>위의 그림에서 <strong>A 서비스</strong> 를 수정하고 배포한다고 가정할 때 사용자의 요청을 처리하기 위해 이해관계에 놓여있는 B 서비스와 DB는 대부분 <code class=\"language-text\">모킹</code>으로 처리할 것이다.<br>\n개인적으로 모킹을 좋아하지 않는다. 필요하다면 모킹을 사용하긴 하지만 모킹 라이브러리를 추가하지 않기 위해 추상 계층, 위임을 활용하는 편이다.</p>\n<p>이번에 <a href=\"https://jdalma.github.io/2024y/refactoring/refactoring1\">리팩토링</a>을 진행하면서 통합 테스트를 작성하게 되었는데, 위와 같은 고민을 해소해주는 <strong>Testcontainers</strong> 를 접하게 되었다.</p>\n<h1 id=\"testcontainers란\" style=\"position:relative;\">Testcontainers란?<a href=\"#testcontainers%EB%9E%80\" aria-label=\"testcontainers란 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<ul>\n<li>출처: <a href=\"https://testcontainers.com/guides/introducing-testcontainers/\">What is Testcontainers, and why should you use it?</a>, <a href=\"https://testcontainers.com/getting-started/\">What is Testcontainers</a></li>\n</ul>\n<blockquote>\n<p>단위 테스트는 데이터베이스, 메시징 시스템 등과 같은 외부 서비스와 분리하여 비즈니스 로직 및 구현 세부 사항을 테스트하는 데 도움이 되지만, 애플리케이션 코드의 대부분은 여전히 이러한 외부 서비스와 통합되어 있을 수 있습니다.<br>\n<strong>애플리케이션에 대한 완전한 확신을 가지려면 단위 테스트와 함께 통합 테스트를 작성하여 애플리케이션이 완벽하게 작동하는지 확인해야 합니다.</strong><br>\n테스트 컨테이너는 데이터베이스, 메시지 브로커 등과 같은 <strong>애플리케이션 종속성을 Docker 컨테이너에서 실행하여 이러한 문제를 해결하고 실제 서비스와 대화하고 테스트 코드에 프로그래밍 방식의 API를 제공함으로써 안정적이고 반복 가능한 테스트를 실행할 수 있도록 도와줍니다.</strong></p>\n</blockquote>\n<p>테스트를 실행하는 환경에서 아래의 세 개 중 한 개만 준비되어 있으면 사용 가능하다.</p>\n<ol>\n<li>Docker Desktop</li>\n<li>Docker Engine on Linux</li>\n<li>Testcontainers Cloud</li>\n</ol>\n<p>흐름은 세 단계로 나뉜다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 820px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/03d8ef8e3709462dcc384bda0d75506e/9f82e/test-workflow.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 39.55555555555556%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABwklEQVR42lVSW2sTQRTeXy2+i88Bi2DV5KEgRVCsxhtWfTAIUrWpSStx3WZJE9sktjt7nfvM55mVFj3Dmct3zvedmcNEWSXnpwVHVXKf5wpFbsBygcUiQ1kKaO1QVxJNo8CUQVEprFYleYGTrKLcBnnBvW40eK3m0bIRbHiRQ3Ph68LifGmRpmsM3o+xOssQbL3McHFeIDUSZyS2//kYXz5N8DXLkVcNFZMenIpzyaJZssq2N1/h3kbf3+k8xvggaUWsDzkWXBqMhw0ORzWMtBDKUQxwlPPi4Qd0bz3FfeJ2bz/HaJhm0XGyZA+6b3DjWtff7ezg23AKyoeyBtq5Vnzwumnd0wiYdhbGOzx79BGbnSe4eb3nt3u7GO1PWSSkYYEUf595RT0K9mvqEI81kiON9IdGvyfIZbsPWIil8d9inEskk3m4A6QyLJLStI1yznln6TnWYneHYUbk09RivXA42hM43OPtPmCLxGL87jes1rDOw4UpCJJWZKxjl4JhLWuOrZcDqqZwaUnyE3E8uTpro/H2oA+hOf7lBq2obnRKF0PDtefCgFqAqlZ0NldeVoIw+R92Ql+sojVwauIGjaD1B09TUsDkPM/RAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"test workflow\"\n        title=\"\"\n        src=\"/static/03d8ef8e3709462dcc384bda0d75506e/9f82e/test-workflow.png\"\n        srcset=\"/static/03d8ef8e3709462dcc384bda0d75506e/3684f/test-workflow.png 225w,\n/static/03d8ef8e3709462dcc384bda0d75506e/fc2a6/test-workflow.png 450w,\n/static/03d8ef8e3709462dcc384bda0d75506e/9f82e/test-workflow.png 820w\"\n        sizes=\"(max-width: 820px) 100vw, 820px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ol>\n<li><strong>테스트 실행 전</strong>: 테스트 컨테이너 API를 사용하여 필요한 서비스(데이터베이스, 메시징 시스템 등)를 Docker 컨테이너로 시작한다.</li>\n<li><strong>테스트 실행 중</strong>: 이러한 컨테이너화된 서비스를 사용하여 테스트를 실행한다.</li>\n<li><strong>테스트 실행 후</strong>: 테스트가 성공적으로 실행되었는지 또는 실패가 있었는지 여부에 관계없이 Testcontainers가 컨테이너를 파기한다.</li>\n</ol>\n<p>즉, <strong>Dokcer 컨테이너를 코드 레벨에서 제어하여 테스트의 생명 주기에 맞게 컨테이너를 생성하고 종료하는 것이다.</strong><br>\n현재 사내에서는 내부 Docker 레지스트리를 구축하여 모든 애플리케이션과 인프라를 이미지로 관리하고 있기 때문에 적용하기에 알맞다고 생각했다.</p>\n<h1 id=\"testcontainers-사용해보기\" style=\"position:relative;\">Testcontainers 사용해보기<a href=\"#testcontainers-%EC%82%AC%EC%9A%A9%ED%95%B4%EB%B3%B4%EA%B8%B0\" aria-label=\"testcontainers 사용해보기 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>기존에는 필요한 인프라를 로컬에 Docker 컨테이너를 직접 실행시켜놓고 애플리케이션의 프로파일을 <code class=\"language-text\">local</code>, <code class=\"language-text\">test</code> 등으로 구분하여 사용 중이였다.<br>\n먼저 local 테스트 환경에서 세션을 관리하는 Redis를 아래의 그림과 같이 Testcontainer를 적용해 보았다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 900px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/23d4417a3a3bffeeeccced6dabae796f/d4377/testcontainers.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 38.666666666666664%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABa0lEQVR42nWRz06DQBDGeRcfwJtnPXjyYDzrTa8+gzeeoj5HjQnGNJ6MMR5MjE0sofxpaUspdGEpu8vnDi3QSzeBDLMzv++bwYA+SlXICoWNqFBVFQ4dtbt7/PzB08cvln6EwJlBlLKtMaimVMA6F2CZ0DFBOwgJ7ItUJJ5twAqJOOHghe7hogPSazUc4u/+Ft/XV0h9vyEddMpiBtt8wNfFKbx+H2qr1AFjDXw9O8Hb5TlYOGuBUkqkaYo4juu40WEpx/vdDZ6Pj+BaLy2Q7oxNoe3nHGVZQgiJXH9zzuvmxWKBXq8H0zTh75zneY5VvNY1ekVppkeWWCdM94p6NYbneWCMdePo2HGcFqqUqt1RcRRFGI/HKIqi3S+dJEngum6dN6bTKcIwhNQK1EhOKEfP/s/Isgzz+RyTyUSDl7p+uwKajGppLYPBAIZt2wiCoIaRG3IwGo3aERsojUo5uiNws1MCUp6ELMvCPxNPXLuKB6NGAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"testcontainers\"\n        title=\"\"\n        src=\"/static/23d4417a3a3bffeeeccced6dabae796f/1cfc2/testcontainers.png\"\n        srcset=\"/static/23d4417a3a3bffeeeccced6dabae796f/3684f/testcontainers.png 225w,\n/static/23d4417a3a3bffeeeccced6dabae796f/fc2a6/testcontainers.png 450w,\n/static/23d4417a3a3bffeeeccced6dabae796f/1cfc2/testcontainers.png 900w,\n/static/23d4417a3a3bffeeeccced6dabae796f/d4377/testcontainers.png 1294w\"\n        sizes=\"(max-width: 900px) 100vw, 900px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>먼저 Docker 컨테이너를 생성하는 코드를 보자.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">// [3]\nclass RedisTestContainers: ApplicationContextInitializer&lt;ConfigurableApplicationContext&gt; {\n\n    override fun initialize(applicationContext: ConfigurableApplicationContext) {\n        redis.start()\n\n        val redisContainerIP = &quot;spring.redis.host=${redis.host}&quot;\n        val redisContainerPort = &quot;spring.redis.port=${redis.getMappedPort(REDIS_PORT)}&quot; // [2]\n\n        TestPropertySourceUtils.addInlinedPropertiesToEnvironment(\n            applicationContext,\n            redisContainerIP,\n            redisContainerPort\n        )\n    }\n\n    companion object {\n        private const val REDIS_IMAGE = &quot;redis:latest&quot;\n        private const val REDIS_PORT = 6379\n        private val redis = RedisContainer(DockerImageName.parse(REDIS_IMAGE))\n            .withExposedPorts(REDIS_PORT) // [1]\n    }\n}</code>\n        </deckgo-highlight-code>\n<ul>\n<li><code class=\"language-text\">[1]</code> : Redis의 이미지 정보와 Redis의 컨테이너 내부 포트를 지정한다.</li>\n<li><code class=\"language-text\">[2]</code> : Testcontainers를 통하여 컨테이너를 실행시키면 호스트의 <strong>랜덤 포트</strong>로 컨테이너가 실행되기 때문에 Property를 동적으로 변경하기 위함이다.</li>\n<li><code class=\"language-text\">[3]</code> : <code class=\"language-text\">[2]</code>번을 수행하기 위한 훅을 제공하는 콜백 인터페이스인 <code class=\"language-text\">ApplicationContextInitializer</code>를 구현하였다.\n<ul>\n<li>ApplicationContext가 준비되고 빈 정의가 로드되기 전에 ApplicationContextInitializer가 호출된다.</li>\n<li><a href=\"https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.spring-application.application-events-and-listeners\">Application Events and Listeners</a>, <a href=\"https://www.baeldung.com/spring-tests-override-properties#testPropertySourceUtils\">TestPropertySourceUtils</a></li>\n</ul>\n</li>\n</ul>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">@SpringBootTest(&quot;spring.profiles.active=test&quot;)\n@AutoConfigureMockMvc\n@ContextConfiguration(initializers = [RedisTestContainers::class])\nclass IntegrationTest: FunSpec() {\n\n    @Autowired\n    private lateinit var redisTemplate: StringRedisTemplate\n    @Autowired\n    private lateinit var mockMvc: MockMvc\n\n    private val key = &quot;spring:session:sessions:expires:test&quot;\n    private val value = &quot;{\\&quot;username\\&quot;:\\&quot;hjjeong\\&quot;}&quot;\n    private val cookie = Cookie(&quot;SESSION&quot;, &quot;test&quot;)\n\n    init {\n        extension(SpringExtension)\n\n        beforeSpec {\n            redisTemplate.opsForValue().set(key, value)\n        }\n\n        test(&quot;GET ...&quot;) {\n            val mvcResult = mockMvc.perform(MockMvcRequestBuilders.get(&quot;{url}&quot;).cookie(cookie))\n                .andExpect { status().isOk }\n                .andDo(MockMvcResultHandlers.print())\n                .andReturn()\n            // ...\n        }\n    }\n}</code>\n        </deckgo-highlight-code>\n<p>위의 <code class=\"language-text\">test</code>를 실행하면 Redis 컨테이너가 실행되고 테스트가 실행되기 전에 세션을 준비하고 통합 테스트가 실행된다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 900px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/994421475ee9f757b592d55baeb67cf0/e04e6/container.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 8.88888888888889%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAhElEQVR42iWN2w6CMBBE/Q9oUaRQoC23cA0hGF988P9/57jqw8nMJLM7l2J7Ue5vrt1J0j1I2kNUfHOg3Yz2q7Chyp67H8jCSJx7VBG41b101h+pG7DdwsWuT6rpROWOOKuITf1Hsg67PFtQtiEyARMmCjmKjEfblrydUd8xIfUjbtz5ABnXPIOclXXdAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"container\"\n        title=\"\"\n        src=\"/static/994421475ee9f757b592d55baeb67cf0/1cfc2/container.png\"\n        srcset=\"/static/994421475ee9f757b592d55baeb67cf0/3684f/container.png 225w,\n/static/994421475ee9f757b592d55baeb67cf0/fc2a6/container.png 450w,\n/static/994421475ee9f757b592d55baeb67cf0/1cfc2/container.png 900w,\n/static/994421475ee9f757b592d55baeb67cf0/21482/container.png 1350w,\n/static/994421475ee9f757b592d55baeb67cf0/d61c2/container.png 1800w,\n/static/994421475ee9f757b592d55baeb67cf0/e04e6/container.png 2152w\"\n        sizes=\"(max-width: 900px) 100vw, 900px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>컨테이너/네트워크/볼륨/이미지를 제거할 수 있도록 도와주는 <code class=\"language-text\">ryuk</code> 컨테이너와 지정한 <code class=\"language-text\">redis</code> 컨테이너가 생성되었다.<br>\nhost 포트는 둘 다 랜덤 포트로 생성된 것을 확인할 수 있다.</p>\n<p>로그도 확인해보자.</p>\n<deckgo-highlight-code  terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">-- 스프링 테스트 로그 --\norg.testcontainers.DockerClientFactory   : Docker host IP address is localhost\norg.testcontainers.DockerClientFactory   : Connected to docker: \n  Server Version: 24.0.2\n  API Version: 1.43\n  Operating System: Docker Desktop\n  Total Memory: 7851 MB\ntc.testcontainers/ryuk:0.4.0             : Creating container for image: testcontainers/ryuk:0.4.0\no.t.utility.RegistryAuthLocator          : Credential helper/store (docker-credential-desktop) does not have credentials for https://index.docker.io/v1/\ntc.testcontainers/ryuk:0.4.0             : Container testcontainers/ryuk:0.4.0 is starting: 9c8f4b440c407a6233d0b39fc70a6ac381f056d4856c9c22499df410eb28eb00\ntc.testcontainers/ryuk:0.4.0             : Container testcontainers/ryuk:0.4.0 started in PT1.244S\no.t.utility.RyukResourceReaper           : Ryuk started - will monitor and terminate Testcontainers containers on JVM exit\norg.testcontainers.DockerClientFactory   : Checking the system...\norg.testcontainers.DockerClientFactory   : ✔︎ Docker server version should be at least 1.6.0\ntc.redis:latest                          : Creating container for image: redis:latest\ntc.redis:latest                          : Container redis:latest is starting: fff1342e14fbe959761d419a2624df282f38b74719d86cdb39fedae51d052d40\ntc.redis:latest                          : Container redis:latest started in PT0.201S\n\n-- 도커 이벤트 로그 --\ncontainer create (image=testcontainers/ryuk:0.6.0 ...)\nnetwork connect (name=bridge, type=bridge)\ncontainer start (image=testcontainers/ryuk:0.6.0 ...)\nvolume create (driver=local)\ncontainer create (image=redis:latest ...)\nnetwork connect (name=bridge, type=bridge)\nvolume mount (destination=/data, driver=local, propagation=, read/write=true)\ncontainer start (image=redis:latest ...)\n\n[테스트 진행]\n\ncontainer kill (image=testcontainers/ryuk:0.6.0 ...)\ncontainer kill (image=redis:latest ...)\nnetwork disconnect (name=bridge, type=bridge)\nvolume unmount (driver=local)\ncontainer die (image=redis:latest ...)\nvolume destroy (driver=local)\ncontainer destroy (image=redis:latest ...)\nnetwork disconnect (name=bridge, type=bridge)\ncontainer die (image=testcontainers/ryuk:0.6.0 ...)\ncontainer destroy (image=testcontainers/ryuk:0.6.0 ...)</code>\n        </deckgo-highlight-code>\n<p>컨테이너가 생성되고 소멸되는 것들을 볼 수 있다.</p>\n<h1 id=\"applicationcontextinitializer-사용하지-않는-방법\" style=\"position:relative;\">ApplicationContextInitializer 사용하지 않는 방법<a href=\"#applicationcontextinitializer-%EC%82%AC%EC%9A%A9%ED%95%98%EC%A7%80-%EC%95%8A%EB%8A%94-%EB%B0%A9%EB%B2%95\" aria-label=\"applicationcontextinitializer 사용하지 않는 방법 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">@SpringBootTest(&quot;spring.profiles.active=test&quot;)\n@AutoConfigureMockMvc\nclass IntegrationTest: FunSpec() {\n\n    @Autowired\n    private lateinit var redisTemplate: StringRedisTemplate\n    @Autowired\n    private lateinit var mockMvc: MockMvc\n\n    private val key = &quot;spring:session:sessions:expires:test&quot;\n    private val value = &quot;{\\&quot;username\\&quot;:\\&quot;hjjeong\\&quot;}&quot;\n    private val cookie = Cookie(&quot;SESSION&quot;, &quot;test&quot;)\n\n    init {\n        extension(SpringExtension)\n\n        beforeSpec {\n            redisTemplate.opsForValue().set(key, value)\n        }\n\n        test(&quot;GET ...&quot;) {\n            val mvcResult = mockMvc.perform(MockMvcRequestBuilders.get(&quot;{url}&quot;).cookie(cookie))\n                .andExpect { status().isOk }\n                .andDo(MockMvcResultHandlers.print())\n                .andReturn()\n            // ...\n        }\n    }\n\n    companion object {\n        private const val REDIS_IMAGE = &quot;redis:latest&quot;\n        private const val REDIS_PORT = 6379\n\n        @JvmStatic\n        @Container\n        private val REDIS = RedisContainer(DockerImageName.parse(REDIS_IMAGE)).withExposedPorts(REDIS_PORT).apply {\n            this.start()\n        }\n\n        @JvmStatic\n        @DynamicPropertySource\n        private fun registerRedisProperties(registry: DynamicPropertyRegistry) {\n            registry.add(&quot;spring.redis.host&quot;, REDIS::getHost)\n            registry.add(&quot;spring.redis.port&quot;) { REDIS.getMappedPort(REDIS_PORT).toString() }\n        }\n    }\n}</code>\n        </deckgo-highlight-code>\n<p>나는 Redis 컨테이너를 생성하는 로직을 테스트 코드와 분리하고 싶어서 <code class=\"language-text\">ApplicationContextInitializer</code>를 구현하였지만 테스트 코드와 같이 관리하고 싶을 땐 위와 같이 작성할 수 있다.<br>\n<code class=\"language-text\">@DynamicPropertySource</code>를 통해 동적으로 Property를 수정할 수 있다.</p>\n<h1 id=\"정리\" style=\"position:relative;\">정리<a href=\"#%EC%A0%95%EB%A6%AC\" aria-label=\"정리 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>테스트 코드로 필요한 Docker 컨테이너를 생성하여 운영과 동일한 환경에서 테스트가 가능한 것을 확인할 수 있다.<br>\n이 글에서는 Redis를 대체하였지만 <strong>실제 의존하고 있는 서비스들을 컨테이너로 실행시켜서 운영과 동일한 환경을 세팅하여 테스트를 진행할 수 있다는 것이 큰 장점으로 보인다.</strong><br>\n테스트가 전혀 작성되어 있지 않은 환경에서 Testcontainers를 적용해보았다. 팀원들을 설득시키기 충분할 정도로 강력한 도구로 보이며 다음에는 Testcontainers를 적용한 실제 통합 테스트 작성기를 쓰도록 노력해봐야 겠다.</p>\n<p>사용 사례는 <a href=\"https://helloworld.kurly.com/blog/delivery-testContainer-apply/\">컬리의 TestContainers로 유저시나리오와 비슷한 통합테스트 만들어 보기</a>를 참고하라.</p>","frontmatter":{"title":"테스트 불모지에 Testcontainers 심기","date":"April 07, 2024","description":null,"tags":["testcontainers","integration test"]},"tableOfContents":"<ul>\n<li><a href=\"#testcontainers%EB%9E%80\">Testcontainers란?</a></li>\n<li><a href=\"#testcontainers-%EC%82%AC%EC%9A%A9%ED%95%B4%EB%B3%B4%EA%B8%B0\">Testcontainers 사용해보기</a></li>\n<li><a href=\"#applicationcontextinitializer-%EC%82%AC%EC%9A%A9%ED%95%98%EC%A7%80-%EC%95%8A%EB%8A%94-%EB%B0%A9%EB%B2%95\">ApplicationContextInitializer 사용하지 않는 방법</a></li>\n<li><a href=\"#%EC%A0%95%EB%A6%AC\">정리</a></li>\n</ul>"},"previous":{"fields":{"slug":"/2024y/postprocessor/"},"frontmatter":{"title":"빈 후처리기를 이용한 프록시 생성에 대해"}},"next":{"fields":{"slug":"/2024y/bookReview/bookReview/"},"frontmatter":{"title":"2024년 책,강의 서평"}}},"pageContext":{"id":"ea381821-0e81-57aa-a137-69da08df90d1","previousPostId":"83e68652-9a78-5344-a893-30311c9782dd","nextPostId":"459e967c-8067-5121-a9e4-07e0de4508d6"}},"staticQueryHashes":["230163734","3589320610"],"slicesMap":{}}