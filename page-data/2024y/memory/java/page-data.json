{"componentChunkName":"component---src-templates-blog-post-js","path":"/2024y/memory/java/","result":{"data":{"site":{"siteMetadata":{"title":"코딩 주머니"}},"markdownRemark":{"id":"3a318d02-1787-5671-a5fd-c17cbd315ab5","excerpt":"언어 레벨에서 동시성 문제를 해결할 때  키워드나 블록을 사용하게 되는데, 단순히 객체들의 모니터에 대한 잠금을 기준으로 동기화 된다고 이해하고 있다. 이번 글을 통해 조금 더 자세하게 알아보자. JVM 밑바닥까지 파헤치기 12,13장과 김영한의 실전 자바 - 고급…","html":"<p>언어 레벨에서 동시성 문제를 해결할 때 <code class=\"language-text\">syncrhonized</code> 키워드나 블록을 사용하게 되는데, 단순히 객체들의 모니터에 대한 잠금을 기준으로 동기화 된다고 이해하고 있다.<br>\n이번 글을 통해 조금 더 자세하게 알아보자. <a href=\"https://www.yes24.com/product/goods/126564592\">JVM 밑바닥까지 파헤치기</a> 12,13장과 <a href=\"https://www.inflearn.com/course/%EA%B9%80%EC%98%81%ED%95%9C%EC%9D%98-%EC%8B%A4%EC%A0%84-%EC%9E%90%EB%B0%94-%EA%B3%A0%EA%B8%89-1/dashboard\">김영한의 실전 자바 - 고급 1편, 멀티스레드와 동시성</a>을 참고하였다.</p>\n<h1 id=\"공유-메모리-멀티-프로세서-시스템\" style=\"position:relative;\">공유 메모리 멀티 프로세서 시스템<a href=\"#%EA%B3%B5%EC%9C%A0-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%A9%80%ED%8B%B0-%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C-%EC%8B%9C%EC%8A%A4%ED%85%9C\" aria-label=\"공유 메모리 멀티 프로세서 시스템 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>CPU는 프로세서의 처리 속도와 메모리 I/O 속도의 격차 문제를 완화하기 위해 둘 사이에 캐시 계층(하나 이상)을 활용한다.<br>\n필요한 데이터를 캐시에 복사해두어 작업을 빠르게 수행하고, 작업이 완료되면 결과 데이터를 캐시에서 메인 메모리로 동기화하기에 프로세서는 메모리의 느린 I/O를 기다릴 필요가 없어진다.</p>\n<deckgo-highlight-code  terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">프로세서 &lt;-&gt; 캐시 &lt;-&gt;\n프로세서 &lt;-&gt; 캐시 &lt;-&gt;  캐시 일관성 프로토콜  &lt;-&gt; 메인 메모리\n프로세서 &lt;-&gt; 캐시 &lt;-&gt;</code>\n        </deckgo-highlight-code>\n<p>이 멀티 프로세서 시스템에서는 <strong>프로세서 각각이 자신만의 캐시를 갖춘 채 똑같은 메인 메모리를 공유한다.</strong><br>\n그렇기에 <strong>여러 프로세서가 메인 메모리의 같은 영역을 보며 작업하더라도 프로세서별 캐시 데이터는 서로 다를 수 있다.</strong><br>\n이 경우 데이터를 메인 메모리로 동기화할 때 어느 프로세서의 데이터를 기준으로 삼아야 할까?</p>\n<p>이 일관성 문제를 해결하기 위해서는 메인 메모리를 이용할 때 정해진 프로토콜을 따라야 하며, JVM은 자체 메모리 모델을 가지고 있다.<br>\n('메모리 모델'은 특정 프로토콜을 이용하여 특정 메모리나 캐시를 읽고 쓰는 절차를 말한다.)</p>\n<h1 id=\"자바-메모리-모델\" style=\"position:relative;\">자바 메모리 모델<a href=\"#%EC%9E%90%EB%B0%94-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%AA%A8%EB%8D%B8\" aria-label=\"자바 메모리 모델 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>JVM은 자체 메모리 모델을 가졌기 때문에 플랫폼에 상관없이 메모리를 일관된 방식으로 사용할 수 있다.</p>\n<deckgo-highlight-code  terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">자바 스레드 &lt;-&gt; 작업 메모리 &lt;-&gt;\n자바 스레드 &lt;-&gt; 작업 메모리 &lt;-&gt;\n자바 스레드 &lt;-&gt; 작업 메모리 &lt;-&gt; 저장, 읽기 &lt;-&gt; 메인 메모리\n자바 스레드 &lt;-&gt; 작업 메모리 &lt;-&gt;\n자바 스레드 &lt;-&gt; 작업 메모리 &lt;-&gt;</code>\n        </deckgo-highlight-code>\n<p>자바 메모리 모델은 일관성 문제, 동시성 문제를 해결하기 위해 메모리 접근 규칙을 엄격하게 정의해놓았다.<br>\n즉, <strong>가상 머신의 메모리에서 변수에 값을 저장하고 가져오는 저수준의 세세한 정보를 정의한것이다.</strong><br>\n(위에서 말한 변수는 스레드별 고유 지역을 활용하는 지역 변수와 메서드 매개변수를 제외한 변수를 의미한다.)</p>\n<ol>\n<li>작업 메모리에는 해당 스레드가 사용하는 변수가 저장된 메인 메모리의 복사본이 담긴다.</li>\n<li>스레드가 변수를 읽고 쓰는 모든 연산은 작업 메모리에서 수행되며 메인 메모리를 직접 읽고 쓸 수 없다.</li>\n<li>스레드간 서로의 작업 메모리에 접근할 수 없으며 반드시 메인 메모리를 거쳐 값을 전송해야 한다.</li>\n</ol>\n<p>그렇다면 메인 메모리에 접근하기 위한 방법은 무엇일까?</p>\n<h1 id=\"메모리-간-상호-작용\" style=\"position:relative;\">메모리 간 상호 작용<a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B0%84-%EC%83%81%ED%98%B8-%EC%9E%91%EC%9A%A9\" aria-label=\"메모리 간 상호 작용 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>메인 메모리와 작업 메모리 사이의 프로토콜, 즉 메인 메모리에서 작업 메모리로 변수를 복사하고 작업 메모리의 내용을 메인 메모리로 다시 동기화하는 구체적인 방법을 자바 메모리 모델은 여덟 가지로 정의했다.<br>\n(각 단계의 연산이 원자적으로 이루어지도록 보장해야 한다.)</p>\n<ol>\n<li><strong>잠금</strong> (lock) : 메인 메모리에 존재하는 변수를 특정 스레드만 사용할 수 있는 상태로 만든다.</li>\n<li><strong>잠금 해제</strong> (unlock) : 잠겨 있는 변수를 잠금 해제한다.</li>\n<li><strong>읽기</strong> (read) : 뒤이어 수행되는 적재 연산을 위해 메인 메모리의 변숫값을 특정 스레드의 작업 메모리로 전송한다.</li>\n<li><strong>적재</strong> (load) : 읽기 연산으로 메인 메모리에서 얻어온 값을 작업 메모리의 변수에 복사해 넣는다.</li>\n<li><strong>사용</strong> (use) : 작업 메모리의 변숫값을 실행 엔진으로 전달한다. 가상 머신이 변숫값을 사용하는 바이트 코드 명령어를 만날 때마다 실행된다.</li>\n<li><strong>할당</strong> (assign) : 실행 엔진에서 받은 값을 작업 메모리의 변수에 할당한다. 가상 머신이 변수에 값을 할당하는 바이트코드 명령어를 만날 때마다 실행된다.</li>\n<li><strong>저장</strong> (store) : 뒤이어 수행되는 쓰기 연산을 위해 작업 메모리의 변숫값을 메인 메모리로 전송한다.</li>\n<li><strong>쓰기</strong> (write) : 저장 연산으로 작업 메모리에서 얻어온 값을 메인 메모리의 변수에 기록한다.</li>\n</ol>\n<p>이 여덟 가지의 기본 연산을 수행할 때 지켜야하는 규칙들도 존재하지만, 여기서는 메모리 간 상호작용을 위해 원자적으로 지원하는 연산이 있다고만 이해하자.<br>\n이런 연산이 존재한다는 것을 이해하였으면 가시성 문제를 이해할 수 있다.</p>\n<h1 id=\"가시성-문제\" style=\"position:relative;\">가시성 문제<a href=\"#%EA%B0%80%EC%8B%9C%EC%84%B1-%EB%AC%B8%EC%A0%9C\" aria-label=\"가시성 문제 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>스레드는 특정 변수가 필요하다면 메인 메모리에서 <code class=\"language-text\">읽기</code> 작업 후 <code class=\"language-text\">적재</code> 작업으로 정보를 읽어오고, 변수 갱신이 필요하다면 다른 스레드가 동기화된 변수를 가져가도록 메인 메모리에 저장하기 위해 <code class=\"language-text\">저장</code> 작업 후 <code class=\"language-text\">쓰기</code> 작업이 필요하다는 것을 알아보았다.<br>\n하지만 스레드의 작업 메모리간 동기화가 보장되지 않아 문제가 발생하는 경우가 존재하는데, 이 문제를 <strong>가시성 문제</strong> 라고 한다.</p>\n<deckgo-highlight-code language=\"java\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">/**\n * volatile 키워드 없이 발생하는 메모리 가시성 문제 예제\n * 문제: 메인 스레드가 runnable을 false로 변경해도,\n *      워커 스레드는 CPU 캐시에 저장된 true 값을 계속 읽어서 무한 루프에 빠짐\n */\npublic class VolatileTest {\n    private boolean runnable = true;\n\n    public void work() {\n        System.out.println(&quot;[워커 스레드] 작업 시작&quot;);\n        long count = 0;\n        while (runnable) {\n            count++;\n        }\n        System.out.println(&quot;[워커 스레드] 작업 종료! 총 카운트: &quot; + count);\n    }\n\n    public void stop() {\n        System.out.println(&quot;[메인 스레드] 중지 신호 전송 (runnable = false)&quot;);\n        runnable = false;\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        VolatileTest test = new VolatileTest();\n        Thread worker = new Thread(test::work, &quot;Worker&quot;);\n        worker.start();\n\n        Thread.sleep(1000);\n\n        test.stop();\n\n        // 5초 더 대기하며 스레드가 종료되는지 확인\n        System.out.println(&quot;[메인 스레드] 5초 동안 대기 중...&quot;);\n        Thread.sleep(5000);\n\n        if (worker.isAlive()) {\n            System.out.println(&quot;[메인 스레드] 워커 스레드가 여전히 실행 중!&quot;);\n        } else {\n            System.out.println(&quot;[메인 스레드] ✓ 워커 스레드가 정상 종료됨&quot;);\n        }\n    }\n}\n\n// [워커 스레드] 작업 시작\n// [메인 스레드] 중지 신호 전송 (runnable = false)\n// [메인 스레드] 5초 동안 대기 중...\n// [메인 스레드] 워커 스레드가 여전히 실행 중!</code>\n        </deckgo-highlight-code>\n<p>메인 스레드는 <code class=\"language-text\">count</code>를 1씩 증가시키는 자식 스레드를 생성하고 500ms후에 자식 스레드가 종료될 수 있도록 <code class=\"language-text\">runnable</code> 상태를 false로 변경하기에 자식 스레드가 종료될 것이라고 예상할 수 있다.<br>\n하지만 위의 예제에서 <strong>자식 스레드가 종료되지 않거나 종료되더라도 출력되는 count의 값이 서로 다르다.</strong></p>\n<deckgo-highlight-code  terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">task runnable false, count = 535399566\nThread-0 end, count = 600000000</code>\n        </deckgo-highlight-code>\n<p>이유는 각 스레드가 참조하고 있는 <code class=\"language-text\">runnable</code>변수가 서로 다르기 때문이다. 메인 스레드가 메인 메모리에 반영하는 시점이 언제인지, 자식 스레드가 메인 메모리에서 변수를 재조회할 시점이 언제인지 보장할 수 없는 것이다.<br>\n주로 컨텍스트 스위칭이 발생할 때 작업 메모리(캐시)도 함께 갱신되는데, 이 부분도 환경에 따라 달라질 수 있다.<br>\n이런 가시성 문제의 경우 <code class=\"language-text\">runnable</code> 변수에 <code class=\"language-text\">volatile</code> 키워드만 작성해주면 해결된다.</p>\n<deckgo-highlight-code  terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">task runnable false, count = 419842762\nThread-0 end, count = 419842762</code>\n        </deckgo-highlight-code>\n<p>그렇다면 <code class=\"language-text\">volatile</code> 키워드가 무슨 역할을 하는 것일까?</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 846px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/98336d403ea5248918648d835509ad1f/5b481/volatileBytecode.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 10.222222222222223%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAdElEQVR42lWMwQ7CIBAF+/9/Z28S9WACjYEgaLuFSjvdGi8eJrPvsNOJG/CnnmgdU8q845MmM5QKh6ua4yz4FLH+waBkGZH1g7Tly6QU3d2iTzEEgjHks2G8XMnKKsJWCtsvWNSvWXDB09sb9+Q10DRU/4I7biaZYEnk1C0AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"volatileBytecode\"\n        title=\"\"\n        src=\"/static/98336d403ea5248918648d835509ad1f/5b481/volatileBytecode.png\"\n        srcset=\"/static/98336d403ea5248918648d835509ad1f/3684f/volatileBytecode.png 225w,\n/static/98336d403ea5248918648d835509ad1f/fc2a6/volatileBytecode.png 450w,\n/static/98336d403ea5248918648d835509ad1f/5b481/volatileBytecode.png 846w\"\n        sizes=\"(max-width: 846px) 100vw, 846px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>(바이트 코드에 직접적인 흔적을 찾을 수 있을 줄 알았지만.. 로우 레벨의 영역이라고 한다. <a href=\"https://stackoverflow.com/questions/16898367/how-to-decompile-volatile-variable-in-java\">참고</a>)<br>\n<a href=\"https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.5-200-A.1\">field flags</a>의 내용을 확인하면 <code class=\"language-text\">ACC_VOLATILE - Declared volatile; cannot be cached.</code> 내용을 확인할 수 있다.<br>\n즉, <strong>물리적 저장소 관점에서 보면 각 스레드의 작업 메모리 내 volatile 변수들도 일치하지 않을 수 있다. 다만 사용하기 전에 매번 새로 고치므로 일관되지 않은 값을 사용할 일이 없다는 것이다.</strong><br>\n이렇듯 메모리 가시성 문제는 <strong>멀티스레드 환경에서 한 스레드가 변경한 값이 다른 스레드에서 보지 못하는 문제를 뜻한다.</strong></p>\n<p>하지만 <code class=\"language-text\">volatile</code>을 사용하여도 아래와 같은 동시성 문제는 해결할 수 없다.</p>\n<deckgo-highlight-code language=\"java\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">public class Counter {\n\n    volatile int count = 0;\n\n    public void increase() {\n        count++;\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        final Counter counter = new Counter();\n        final ExecutorService executorService = Executors.newFixedThreadPool(20);\n        for (int i = 0 ; i &lt; 10_000; i++) {\n            executorService.submit(counter::increase);\n        }\n        executorService.awaitTermination(2, TimeUnit.SECONDS);\n        executorService.shutdown();\n    }\n}</code>\n        </deckgo-highlight-code>\n<p>언뜻 보면 <code class=\"language-text\">count</code>는 정상적으로 증가할 것이라고 보이지만 실제로 10000이 되지 못한다. 그 이유는 바이트 코드를 보면 알 수 있다.</p>\n<deckgo-highlight-code  terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">public void increase();\ndescriptor: ()V\nflags: (0x0001) ACC_PUBLIC\nCode:\n    stack=3, locals=1, args_size=1\n        0: aload_0\n        1: dup\n        2: getfield      #7                  // Field count:I\n        5: iconst_1\n        6: iadd\n        7: putfield      #7                  // Field count:I\n        10: return</code>\n        </deckgo-highlight-code>\n<p>2번부터 7번까지 count와 1을 스택에 로드하여 두 개의 정수를 합한 결과를 count 필드에 저장하게 된다.<br>\n<code class=\"language-text\">volatile</code> 키워드 덕분에 다른 스레드에서 저장한 값은 바로 확인할 수 있지만, 변수를 로드하고 저장하는 사이에 다른 스레드가 값을 저장하여 현재 스레드가 참조하고 있는 값이 변경 전의 값이 될 수 있기 때문이다.<br>\n이 문제는 새로운 해결 방법을 적용해야 한다.</p>\n<h1 id=\"동시성-문제\" style=\"position:relative;\">동시성 문제<a href=\"#%EB%8F%99%EC%8B%9C%EC%84%B1-%EB%AC%B8%EC%A0%9C\" aria-label=\"동시성 문제 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>만약 두 번의 출금이 한 개의 계좌에 동시에 일어난다고 가정해보자.</p>\n<deckgo-highlight-code language=\"java\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">class Account {\n    private volatile long balance;\n\n    public Account(long balance) {\n        this.balance = balance;\n    }\n\n    public void withdraw(long amount) {\n        if (this.balance &lt; amount) {\n            return;\n        }\n        this.balance -= amount;\n    }\n}\n\nclass WithdrawTask implements Runnable {\n    private final Account account;\n    private final long amount;\n\n    public WithdrawTask(Account account, long amount) {\n        this.account = account;\n        this.amount = amount;\n    }\n\n    @Override\n    public void run() {\n        this.account.withdraw(amount);\n    }\n}\n\n@Test\nvoid test() throws InterruptedException {\n    Account account = new Account(5000);\n\n    Thread thread1 = new Thread(new WithdrawTask(account, 3000));\n    Thread thread2 = new Thread(new WithdrawTask(account, 4000));\n\n    thread1.start();\n    thread2.start();\n\n    thread1.join();\n    thread2.join();\n\n    Assertions.assertThat(account.getBalance()).isIn(1000L, 2000L);\n}</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">balance</code>변수에 <code class=\"language-text\">volatile</code> 키워드를 작성하였기에 5000원이 들어있는 계좌에 3000원, 4000원의 출금 태스크를 실행한 결과는  정상적인 결과인 1000원 또는 2000원이 남아있을 것이라고 기대할 수 있다. 하지만 실제로는 두 번의 출금이 모두 실행되어 -2000원이 남게된다.</p>\n<p><code class=\"language-text\">volatile</code> 키워드는 한 스레드에서 변수를 수정하였을 때 다른 스레드에서 이 변수의 값을 바로 알아차릴 수 있도록 가시성 문제만을 해결하는 것이다. 위와 같이 두 스레드가 한 변수에 업데이트하는 조건에만 의존하여 변수의 값을 업데이트하는 문제는 다른 문제이다.<br>\n즉, <code class=\"language-text\">if (this.balance &lt; amount)</code> 조건이 실행되는 시점에 실제로 5000원이 있었고, 두 스레드가 모두 <code class=\"language-text\">balance</code>를 업데이트하는 로직을 실행하도록 되었기에 문제가 되는 것이다.<br>\n<code class=\"language-text\">volatile</code> 키워드로 다른 스레드의 업데이트한 값은 실시간으로 참조 가능하기에 -2000원이 되는 것이다.</p>\n<p>한 마디로 <strong>변수를 조회하는 시점과 업데이트 하는 시점을 한 개의 임계영역으로 지정해야 하는 것이다.</strong><br>\n아래와 같이 <code class=\"language-text\">synchronized</code> 키워드를 메서드에 작성하면 이 메서드를 실행할 수 있는 메서드는 한 개로 제한되며, 나머지 스레드는 먼저 실행 중인 스레드가 끝날 때까지 기다리게 된다.</p>\n<deckgo-highlight-code language=\"java\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">public synchronized void withdraw(long amount) {\n    if (this.balance &lt; amount) {\n        return;\n    }\n    this.balance -= amount;\n}</code>\n        </deckgo-highlight-code>\n<p>이 <code class=\"language-text\">synchronized</code> 키워드를 메서드에 작성하면 아래와 같이 <code class=\"language-text\">ACC_SYNCHRONIZED</code> flag가 추가된다.</p>\n<deckgo-highlight-code  terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">public synchronized void withdraw(long);\n\n    descriptor: (J)V\n    flags: (0x0021) ACC_PUBLIC, ACC_SYNCHRONIZED\n    ...</code>\n        </deckgo-highlight-code>\n<p><a href=\"https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.6\">method flags</a>를 참조하면 <code class=\"language-text\">ACC_SYNCHRONIZED - Declared synchronized; invocation is wrapped by a monitor use.</code> <strong>메서드 실행 함수가 monitor를 사용하도록 래핑되는 것을 알 수 있다.</strong><br>\n<code class=\"language-text\">block synchronized</code>를 확인해보자.</p>\n<deckgo-highlight-code language=\"java\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">public void withdraw(long amount) {\n    synchronized (this) {\n        if (this.balance &lt; amount) {\n            return;\n        }\n        this.balance -= amount;\n    }\n}</code>\n        </deckgo-highlight-code>\n<p>위의 메소드를 역어셈블러로 확인해보면 새로운 intruction이 등장한다.</p>\n<deckgo-highlight-code  terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">3: monitorenter\n4: aload_0\n5: getfield      #7     // Field balance:J\n8: lload_1\n9: lcmp\n10: ifge          16    // 잔액 차감 로직 실행               \n13: aload_3\n14: monitorexit</code>\n        </deckgo-highlight-code>\n<p>잔액 차감 로직 전후에 <code class=\"language-text\">monitorenter</code>와 <code class=\"language-text\">monitorexit</code>을 볼 수 있다.<br>\n<a href=\"https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-6.html#jvms-6.5.monitorenter\">jvm spec</a>을 참고해보면 <strong>Object는 모니터와 연결되어 있으며, 모니터는 소유자가 있는 경우에만 잠긴다. 스레드는 이 모니터의 소유권을 얻으려고 시도하며 시도에 성공한다면 모니터 락 카운터 값을 0에서 1로 설정하고 해당 스레드가 모니터의 소유자가 된다. 다른 스레드는 이 모니터 락 카운터 값이 0이 될 때까지 차단된다.</strong></p>\n<ol>\n<li>같은 스레드라면 <code class=\"language-text\">synchronized</code>로 동기화된 블록에 다시 진입할 수 있다. 즉, 락을 이미 소유한 스레드는 동기화된 블록에 여러 번 진입해도 블록되지 않는다.</li>\n<li><code class=\"language-text\">synchronized</code>로 동기화된 블록은 락 소유자가 작업을 마치고 락을 해제할 때까지 다른 스레드의 진입을 무조건 차단한다. 그렇기에 락을 소유한 스레드에 문제가 발생해도 강제할 방법이 없다. 또한 락을 기다리는 다른 스레드를 인터럽트해 깨울 방법도 없다.</li>\n</ol>\n<p><strong>핵심은 메모리간 상호 작용에서 알아본 잠금과 잠금 해제 연산을 직접 사용자에게 제공하지 않고, 한 단계 추상화된 바이트코드 명령어인  <code class=\"language-text\">monitorenter</code>와 <code class=\"language-text\">monitorexit</code>을 이용하도록 하는 것이다.</strong></p>\n<h1 id=\"정리\" style=\"position:relative;\">정리<a href=\"#%EC%A0%95%EB%A6%AC\" aria-label=\"정리 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>무심코 사용하던 <code class=\"language-text\">volatile</code>과 <code class=\"language-text\">synchronized</code>를 왜 사용하는지, 사용하면 어떻게 되는지에 대해 조금 알게 되었다.<br>\n언어 레벨에서 가장 일반적이면서 가장 중요한 동시성 보장을 위해 상호 배제 동기화인 <code class=\"language-text\">synchronized</code>를 제공하긴 하지만 <code class=\"language-text\">synchronized</code> 단점을 개선하기 위해 JDK 1.5부터 <code class=\"language-text\">java.util.concurrent</code>가 추가되었다.<br>\n상호 배제 동기화는 비관적 동시성 전략에 속하기에 경합이 실제로 벌어지는지와 상관없이 락을 건다. 그렇게 되면 사용자 모드에서 커널 모드로 전환되고, 락 카운터를 계산하고, 블록된 스레드를 깨워야 하는지 확인하는 작업이 뒤따른다.</p>\n<p>더 유연한 낙관적 동시성 전략도 있다. 이 전략은 잠재적으로 위험할 수 있더라도 일단 작업을 진행하며 충돌이 발생하면 보완 조치를 취하는 것이다.</p>\n<ol>\n<li>TAS(test-and-set) : 검사와 지정</li>\n<li>FAA(fetch-and-add) : 페치와 증가</li>\n<li>Swap : 교환</li>\n<li>CAS(compare-and-swap) : 비교와 교환</li>\n<li>LL/SC(load-linked/store-conditional) : 적재와 저장</li>\n</ol>\n<p>위의 내용도 추가로 학습해보자.</p>","frontmatter":{"title":"가시성 문제와 동시성 문제 이해하기","date":"2024-12-04","update":"2025-10-29","description":null,"tags":["concurrency","visibility"]},"tableOfContents":"<ul>\n<li><a href=\"#%EA%B3%B5%EC%9C%A0-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%A9%80%ED%8B%B0-%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C-%EC%8B%9C%EC%8A%A4%ED%85%9C\">공유 메모리 멀티 프로세서 시스템</a></li>\n<li><a href=\"#%EC%9E%90%EB%B0%94-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%AA%A8%EB%8D%B8\">자바 메모리 모델</a></li>\n<li><a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B0%84-%EC%83%81%ED%98%B8-%EC%9E%91%EC%9A%A9\">메모리 간 상호 작용</a></li>\n<li><a href=\"#%EA%B0%80%EC%8B%9C%EC%84%B1-%EB%AC%B8%EC%A0%9C\">가시성 문제</a></li>\n<li><a href=\"#%EB%8F%99%EC%8B%9C%EC%84%B1-%EB%AC%B8%EC%A0%9C\">동시성 문제</a></li>\n<li><a href=\"#%EC%A0%95%EB%A6%AC\">정리</a></li>\n</ul>"},"previous":{"fields":{"slug":"/2024y/architecture/architecture/"},"frontmatter":{"title":"소프트웨어 아키텍처에 대한 고민"}},"next":{"fields":{"slug":"/2024y/retrospect/"},"frontmatter":{"title":"2024년 회고"}}},"pageContext":{"id":"3a318d02-1787-5671-a5fd-c17cbd315ab5","previousPostId":"dbf1ab36-6a3d-505c-b589-4ce212c8e71c","nextPostId":"d2b091ba-31d3-544b-bf88-c2cbdb0bf6d0"}},"staticQueryHashes":["230163734","3589320610"],"slicesMap":{}}