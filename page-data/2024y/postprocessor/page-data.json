{"componentChunkName":"component---src-templates-blog-post-js","path":"/2024y/postprocessor/","result":{"data":{"site":{"siteMetadata":{"title":"코딩 주머니"}},"markdownRemark":{"id":"83e68652-9a78-5344-a893-30311c9782dd","excerpt":"스프링의 프록시 방식으로 AOP를 생성하는 가장 기본적인 방법을 이해하기 위해서는 사전지식이 필요하다. Reflection Java Dynamic Proxy CGLIB ProxyFactory FactoryBean ProxyFactoryBean…","html":"<p>스프링의 프록시 방식으로 AOP를 생성하는 가장 기본적인 방법을 이해하기 위해서는 사전지식이 필요하다.</p>\n<ol>\n<li>Reflection</li>\n<li>Java Dynamic Proxy</li>\n<li>CGLIB</li>\n<li>ProxyFactory</li>\n<li>FactoryBean</li>\n<li>ProxyFactoryBean</li>\n</ol>\n<p><strong>스프링을 더 깊게 이해하기 위해서는 필수적인 선수 지식이라고 생각한다.</strong><br>\n이 글에서는 스프링 AOP를 사용하는 법, 포인트 컷, 어드바이스를 자세하게 설명하진 않으며, 스프링의 빈 후처리기를 통해 프록시가 어떻게 자동으로 생성되는지를 중점으로 다룬다.<br>\n이 글을 통해 프록시가 무엇인지, 프록시를 관리하고 생성할 때 불편한 방법들을 스프링은 어떻게 해결했는지 알 수 있을 것이다.<br>\n차근차근 단계별로 알아보자.</p>\n<h1 id=\"1단계-java-reflection\" style=\"position:relative;\">1단계: Java Reflection<a href=\"#1%EB%8B%A8%EA%B3%84-java-reflection\" aria-label=\"1단계 java reflection permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>자바의 리플렉션(Reflection)은 런타임 시에 클래스의 속성, 메소드, 생성자 등의 메타데이터를 조회하여 활용할 수 있는 강력한 기능이다.<br>\n즉 <strong>런타임 시에 동적으로 객체를 생성하고, 가시성에 관계없이 메소드를 호출하거나, 필드에 접근할 수 있다.</strong></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 900px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 50.22222222222222%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAECBAX/xAAUAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHWcbIIYv8A/8QAGhAAAgIDAAAAAAAAAAAAAAAAAQMQETEyM//aAAgBAQABBQJmizaxg9o//8QAFhEAAwAAAAAAAAAAAAAAAAAAEBFB/9oACAEDAQE/Aax//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAGhAAAQUBAAAAAAAAAAAAAAAAEAABAhEhQf/aAAgBAQAGPwKWquhj/8QAGxABAAICAwAAAAAAAAAAAAAAAQARECExQYH/2gAIAQEAAT8hd0p8lQGgdkCbNs1M4rP/2gAMAwEAAgADAAAAEI8v/8QAFhEBAQEAAAAAAAAAAAAAAAAAARAR/9oACAEDAQE/EE2H/8QAFhEBAQEAAAAAAAAAAAAAAAAAAQAR/9oACAECAQE/EAC2/8QAHBABAQACAgMAAAAAAAAAAAAAAREAITGBEEFR/9oACAEBAAE/EEGwahE3995T0cV9PcuAAQ5Ql6wACKkOFbcNaPH/2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"javalang\"\n        title=\"\"\n        src=\"/static/ba3e3f3cd9ce3e367559bba7dca13048/8e1fc/javalang.jpg\"\n        srcset=\"/static/ba3e3f3cd9ce3e367559bba7dca13048/863e1/javalang.jpg 225w,\n/static/ba3e3f3cd9ce3e367559bba7dca13048/20e5d/javalang.jpg 450w,\n/static/ba3e3f3cd9ce3e367559bba7dca13048/8e1fc/javalang.jpg 900w,\n/static/ba3e3f3cd9ce3e367559bba7dca13048/a2510/javalang.jpg 1000w\"\n        sizes=\"(max-width: 900px) 100vw, 900px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n<a href=\"https://www.geeksforgeeks.org/reflection-in-java/\">출처 geeksforgeeks</a></p>\n<ul>\n<li>필드(목록) 가져오기</li>\n<li>메소드(목록) 가져오기</li>\n<li>상위 클래스 가져오기</li>\n<li>인터페이스(목록) 가져오기</li>\n<li>어노테이션 가져오기</li>\n<li>생성자 가져오기</li>\n<li>...</li>\n</ul>\n<p>이 리플렉션을 사용하는 것은 <strong>메타 프로그래밍</strong> 이라고 하며 위와 같은 행위를 할 수 있다.<br>\n자바의 모든 클래스는 그 클래스 자체의 구성 정보를 담은 <code class=\"language-text\">Class 타입</code>의 오브젝트를 하나씩 갖고 있다.<br>\n<code class=\"language-text\">Class</code> 오브젝트를 이용하면 <strong>클래스 코드에 대한 메타 정보</strong> 를 가져오거나 <strong>객체를 조작</strong> 할 수 있다.<br>\n테스트 코드로 확인해보자.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">data class Address(\n    private val state: String,\n    private val city: String\n)\n\ndata class Person(\n    private val name: String,\n    var age: Int,\n    private val address: Address\n) {\n    constructor(name: String, age: Int): this(name, age, Address(&quot;empty&quot;, &quot;empty&quot;))\n\n    @Throws(IllegalArgumentException::class)\n    constructor(age: Int): this(&quot;Admin&quot;, age, Address(&quot;Admin&quot;, &quot;Admin&quot;))\n\n    fun greeting() = &quot;안녕하세요.&quot;\n}\n\ndescribe(&quot;Person 클래스&quot;) {\n    val personClass: Class&lt;Person&gt; = Person::class.java\n\n    it(&quot;Constructor를 통해 Person 만들기&quot;) {\n        val constructors: Array&lt;Constructor&lt;Person&gt;&gt;  = personClass.constructors as Array&lt;Constructor&lt;Person&gt;&gt;\n        constructors[0].toString() shouldBe \n            &quot;public _22_Reflection.ReflectionTest\\$1\\$Person(java.lang.String,int)&quot;\n        constructors[1].toString() shouldBe \n            &quot;public _22_Reflection.ReflectionTest\\$1\\$Person(int) throws java.lang.IllegalArgumentException&quot;\n        \n        val nameAndAgeConstructor = constructors[0]\n        val ageConstructor = constructors[1]\n\n        nameAndAgeConstructor.newInstance(&quot;Reflection&quot;, 10) shouldBe Person(&quot;Reflection&quot;, 10)\n        ageConstructor.newInstance(10) shouldBe Person(10)\n    }\n\n    it(&quot;Field로 객체 내부 멤버변수 조회하기&quot;) {\n        val fields: Array&lt;Field&gt; = personClass.declaredFields\n        fields[0].toString() shouldBe \n            &quot;private final java.lang.String _22_Reflection.ReflectionTest$1\\$Person.name&quot;\n        fields[1].toString() shouldBe \n            &quot;private int _22_Reflection.ReflectionTest$1\\$Person.age&quot;\n        fields[2].toString() shouldBe \n            &quot;private final _22_Reflection.ReflectionTest$1\\$Address _22_Reflection.ReflectionTest$1\\$Person.address&quot;\n\n        val person = Person(100)\n\n        fields.forEach { it.trySetAccessible() }\n\n        val nameField = fields[0]\n        val ageField = fields[1]\n        val addressField = fields[2]\n\n        nameField.get(person) shouldBe &quot;Admin&quot;\n        ageField.get(person) shouldBe 100\n        addressField.get(person) shouldBe Address(&quot;Admin&quot;, &quot;Admin&quot;)\n    }\n\n    it(&quot;Method 정보로 객체 실행하기&quot;) {\n        val methods: Array&lt;Method&gt; = personClass.methods\n\n        val getAgeMethod = methods.find { it.name == &quot;getAge&quot; }!!\n        val setAgeMethod = methods.find { it.name == &quot;setAge&quot; }!!\n        val greetingMethod = methods.find { it.name == &quot;greeting&quot; }!!\n\n        val person = Person(100)\n\n        person.age shouldBe 100\n        getAgeMethod.invoke(person) shouldBe 100\n\n        setAgeMethod.invoke(person, 50)\n\n        person.age shouldBe 50\n        getAgeMethod.invoke(person) shouldBe 50\n\n        greetingMethod.invoke(person) shouldBe &quot;안녕하세요.&quot;\n    }\n}</code>\n        </deckgo-highlight-code>\n<p>위와 같이 <code class=\"language-text\">Class</code> 정보를 이용하여 실제 인스턴스를 조작하거나 생성할 수 있다. (더 자세한 예제는 <a href=\"https://github.com/jdalma/kotlin-playground/blob/main/src/test/kotlin/_22_Reflection/ReflectionTest.kt\">여기</a>를 확인하자.)</p>\n<p>리플렉션을 간단하게 확인해보았는데 강력한 기능이라는 것을 느낄 수 있다.<br>\n이 강력한 기능을 통해 자바에서는 <strong><a href=\"https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/proxy.html\">Dynamic Proxy Class API</a></strong> 를 제공한다.<br>\n다이나믹 프록시에 대해 확인하기 전에 먼저 프록시에 대해 알아보자.</p>\n<h1 id=\"2단계-proxy란\" style=\"position:relative;\">2단계: Proxy란?<a href=\"#2%EB%8B%A8%EA%B3%84-proxy%EB%9E%80\" aria-label=\"2단계 proxy란 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>단순히 확장성을 고려해서 한 가지 기능을 분리한다면 아래와 같이 전형적인 전략 패턴(<code class=\"language-text\">condition: (Member) -> Boolean</code>)을 사용할 수 있을 것이다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">fun register(member: Member, condition: (Member) -&gt; Boolean) {\n    if(condition(member)) {\n        // business logic\n    }\n}</code>\n        </deckgo-highlight-code>\n<p>하지만 여러 곳에서 동일한 기능이 필요하다면 아주 번거로워질 것이다. 대표적으로 옛날 방식의 커넥션 관리가 있다.</p>\n<deckgo-highlight-code language=\"java\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">public void accountTransfer(String fromId, String toId, int money) throws SQLException {\n    Connection con = dataSource.getConnection();\n    try {\n        con.setAutoCommit(false);\n        bizLogic(con, fromId, toId, money); // 핵심 기능\n        con.commit();\n    } catch (Exception e) {\n        con.rollback();\n        throw new IllegalStateException(e);\n    } finally {\n        release(con);\n    }\n}</code>\n        </deckgo-highlight-code>\n<p>핵심 기능인 <code class=\"language-text\">bizLogic()</code>을 실행시키기 위한 부가기능이 많이 존재한다.<br>\n이 문제를 <strong>위임</strong> 을 통해 해결하면 어떨까?</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 574px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/8218e1b1fc9598014689df3fa9c112af/86389/proxy.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 76.88888888888889%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsTAAALEwEAmpwYAAACTElEQVR42o2Ue2/aMBTF+f4fYf9smjRNk6ZO6ya1GqylokAoCRCgaEB5bQyVlkdGbMd2Es6u3U6l60O90pHj6OaXe31PksEjsd1u7drtdpHP55HNZjGdTu39OI4fVZIkds3giTAJURRBa20TDczcM/uHUpSjbf6TQAMxySYWiwW6vQHW68DuU4LfNnEvpJTPV/gPuF4t0W2d4HLiIhUTbOVP0i9oNoLeDK22MYdS+mXAhI+wZRWAe9DLEsY/9jEhJRsHEC4QOojXHmQkkEnT1J7PrkwYmFLKXqugSUB6MPKhFg78w7fwvr4B7+WhBgXIUQHJqoxIhMgEQYAwDO9N9/8KxdLH/OIQV+Msrr0DxNUzKBIvFcGKJYSnBfDBEaRiyCyXSzDGrMz1arWiw19jMBjQfoHL+TV6/gHalfdwjl+j/OEV0paPuFlHYtZWA5F7Btb7fgMUQthKjOf6/T6GwyFGoxHa7Tbq9TouLoaolfYw9D9h3PmC8ckelOdhkj3E7CiHq8IJpFu9A85mM2uLzWZjfWRGb2ReZCrWcYpgVkX4Ow9JA9k0c1SRC+f9O/h7H9HZ/wxdcxH2cjdA06Jp97kp67BDk6ShiBp4h8AETNs+kmaDWm9AVCtg/dsKX2IbHZwDfyoWys+PoWoeonoVsu5CNsguu2e4a5WHwDvbWCDzLJAXHfCyA1GuWLEiTbtPLcvwZRXGYko+K1KFVcTzU7B2jsBHtzoG63wjY7eoQvX8t2yGdPMXSSD5AlE4g+KXZPg5lNzVFeVpcCHwF+EObsU94YOyAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"proxy\"\n        title=\"\"\n        src=\"/static/8218e1b1fc9598014689df3fa9c112af/86389/proxy.png\"\n        srcset=\"/static/8218e1b1fc9598014689df3fa9c112af/3684f/proxy.png 225w,\n/static/8218e1b1fc9598014689df3fa9c112af/fc2a6/proxy.png 450w,\n/static/8218e1b1fc9598014689df3fa9c112af/86389/proxy.png 574w\"\n        sizes=\"(max-width: 574px) 100vw, 574px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">interface UserService {\n    fun accountTransfer(fromId: String, toId: String, money: Int)\n}\n\nclass UserServiceProxy (\n    private val userServiceTarget: UserService\n): UserService {\n    override fun accountTransfer(fromId: String, toId: String, money: Int) {\n        // 부가기능\n        userServiceTarget.accountTransfer(...)\n        // 부가기능\n    }\n}\n\nclass UserServiceTarget: UserService {\n    override fun accountTransfer(fromId: String, toId: String, money: Int) {\n        // 핵심 기능\n    }\n}</code>\n        </deckgo-highlight-code>\n<p>위임을 통해 부가기능은 마치 <strong>자신이 핵심 기능 클래스인 것처럼 꾸며서, 클라이언트가 자신을 거쳐서 핵심 기능을 사용하도록 만드는 것이다.</strong><br>\n클라이언트는 인터페이스를 통해서만 핵심 기능을 사용하게 하여, 부가기능은 자신도 같은 인터페이스를 구현한 뒤에 자신이 그 사이에 끼어들어 타깃을 직접 제어하는 것이다.</p>\n<p>이렇게 마치 <code class=\"language-text\">자신이 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 것</code>을 대리자,대리인 과 같은 역할을 한다고 해서 <strong>프록시</strong> 라고 부르며, 프록시를 통해 최종적으로 요청을 위임받아 처리하는 실제 오브젝트를 <strong>타깃</strong> 이라고 부른다.</p>\n<ol>\n<li>타깃과 동일한 인터페이스를 구현하고</li>\n<li>클라이언트와 타깃 사이에 존재하면서</li>\n<li>기능의 부가 또는 접근 제어를 담당하면 모두 <strong>프록시</strong> 라고 볼 수 있다.</li>\n</ol>\n<p>이 <strong>프록시의 사용 목적에 따라 디자인 패턴에서는 다른 패턴으로 구분된다.</strong></p>\n<h3>데코레이터 패턴</h3>\n<p><strong>타깃에 부가적인 기능을 런타임에 동적으로 부여하기 위해 프록시를 사용하는 패턴을 말한다.</strong><br>\n대표적으로 <a href=\"https://github.com/jdalma/footprints/blob/main/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/%EA%B5%AC%EC%A1%B0_%EA%B4%80%EB%A0%A8.md#%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-%ED%8C%A8%ED%84%B4\">자바 IO패키지의 InputStream 구현 클래스</a>이다.</p>\n<p>프록시로서 동작하는 각 데코레이터는 위임하는 대상에도 인터페이스로 접근하기 때문에 자신이 최종 타깃으로 위임하는지, 아니면 다음 단계의 데코레이터 프록시로 위임하는지 알지 못한다.<br>\n그래서 데코레이터의 다음 위임 대상은 인터페이스로 선언하고 생성자나 수정자 메소드를 통해 위임 대상을 외부에서 런타임 시에 주입받을 수 있도록 만들어야 한다.<br>\n프록시가 꼭 한 개로 제한되지 않으며, 여러 개의 프록시를 <strong>순서를 정해서 단계적으로 위임하는 구조로 만들어야 한다.</strong><br>\n데코레이터는 스스로 존재할 수 없고 항상 꾸며줄 대상이 있어야 하며 <strong>타겟에 대한 기능을 확장시키는 개념이다.</strong></p>\n<p>위의 <code class=\"language-text\">UserServiceTarget</code>에 부가기능을 제공하는 <code class=\"language-text\">UserServiceProxy</code>를 추가한 것도 데코레이터 패턴을 적용했다고 볼 수 있다.</p>\n<h3>프록시 패턴</h3>\n<p><strong>클라이언트와 타깃 사이에서 대리 역할을 맡는 오브젝트를 두는 방법을 총칭하는 것이다.</strong><br>\n디자인 패턴에서 말하는 프록시 패턴은 <strong>프록시를 사용하는 방법 중에 타깃에 대한 접근 방법을 제어하려는 목적을 가진 경우</strong> 를 가리킨다.<br>\n즉, 프록시 패턴의 프록시는 타깃의 기능을 확장하거나 추가하지 않고 클라이언트가 타깃에 대한 접근 권한을 제어하거나 접근하는 방식을 변경해주는 것이다.</p>\n<p>위에서 봤던 <strong>실제 타깃 오브젝트를 만드는 대신 프록시를 넘겨주는 것, 그리고 프록시의 메소드를 통해 타깃을 사용하려고 시도하면, 그떄 프록시가 타깃 오브젝트를 (생성하고) 요청을 위임해주는 식이다.</strong><br>\n대표적으로 <code class=\"language-text\">Collections.unmodifiableCollection()</code>을 통해 만들어지는 객체가 전형적인 접근 권한 제어용 프록시라고 볼 수 있다.</p>\n<deckgo-highlight-code language=\"java\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">public static &lt;T&gt; Collection&lt;T&gt; unmodifiableCollection(Collection&lt;? extends T&gt; c) {\n    if (c.getClass() == UnmodifiableCollection.class) {\n        return (Collection&lt;T&gt;) c;\n    }\n    return new UnmodifiableCollection&lt;&gt;(c);\n}</code>\n        </deckgo-highlight-code>\n<p>이렇게 프록시 패턴은 타깃의 기능 자체에는 관여하지 않으면서 접근하는 방법을 제어해주는 프록시를 <code class=\"language-text\">이용</code>하는 것이다.</p>\n<blockquote>\n<p>위임을 통한 프록시를 생성하여 부가기능과 핵심 기능을 분리했지만 프록시를 만드는 일은 번거롭고 타깃 인터페이스에 의존적이여서 타깃이 여러 개라면 인터페이스 API가 수정될 수 밖에 없을 것이다.</p>\n</blockquote>\n<h1 id=\"3단계-proxy-생성-방법\" style=\"position:relative;\">3단계: Proxy 생성 방법<a href=\"#3%EB%8B%A8%EA%B3%84-proxy-%EC%83%9D%EC%84%B1-%EB%B0%A9%EB%B2%95\" aria-label=\"3단계 proxy 생성 방법 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<h2 id=\"java-dynamic-proxy\" style=\"position:relative;\">Java Dynamic Proxy<a href=\"#java-dynamic-proxy\" aria-label=\"java dynamic proxy permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>일일이 프록시 클래스를 정의하는 것은 한계가 있다는 것을 알 수 있다.<br>\n이 한계를 <strong>프록시처럼 동작하는 오브젝트를 동적으로 생성하는 JDK의 다이내믹 프록시</strong> 와 <strong>리플렉션</strong> 으로 해결할 수 있다.</p>\n<p>이 프록시는 두 가지 기능으로 구성된다.</p>\n<ol>\n<li><strong>타깃과 같은 메소드를 구현하고 있다가 메소드가 호출되면 타깃 오브젝트로 위임한다.</strong></li>\n<li><strong>지정된 요청에 대해서는 부가기능을 수행한다.</strong></li>\n</ol>\n<p>다이나믹 프록시를 이용해 프록시를 만들어보자.</p>\n<blockquote>\n<p><code class=\"language-text\">Hello</code> 인터페이스를 구현한 프록시를 만들어보자.<br>\n프록시에는 데코레이터 패턴을 적용해서 타깃인 <code class=\"language-text\">HelloTarget</code>에 부가기능을 추가해보자.<br>\n리턴하는 문자를 모두 대문자로 바꾸는 부가기능을 만들어보자.</p>\n</blockquote>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">interface Hello {\n    fun sayHello(name: String): String\n    fun sayHi(name: String): String\n    fun sayThankYou(name: String): String\n}\ninterface Goodbye {\n    fun sayGoodbye(name: String): String\n    fun sayThankYou(name: String): String\n}\nclass HelloTarget: Hello {\n    override fun sayHello(name: String): String = &quot;Hello $name&quot;\n    override fun sayHi(name: String): String = &quot;Hi $name&quot;\n    override fun sayThankYou(name: String): String = &quot;Hello Thank You $name&quot;\n}\n\nclass GoodbyeTarget: Goodbye {\n    override fun sayGoodbye(name: String): String = &quot;Goodbye $name&quot;\n    override fun sayThankYou(name: String): String = &quot;Goodbye Thank You $name&quot;\n}\n\nclass UppercaseHandler(\n    helloTarget: Hello,\n    goodbyeTarget: Goodbye\n): InvocationHandler {\n\n    private val lookupTarget = mapOf(\n        Hello::class.java to helloTarget,\n        Goodbye::class.java to goodbyeTarget,\n    )\n\n    override fun invoke(proxy: Any, method: Method, args: Array&lt;out Any&gt;): Any {\n        val result: String = method.invoke(lookupTarget[method.declaringClass], *args) as String\n        return result.uppercase()\n    }\n}\n\n&quot;Hello 동적 프록시 테스트하기&quot; {\n    val proxy = Proxy.newProxyInstance(\n        javaClass.classLoader,\n        arrayOf(Hello::class.java, Goodbye::class.java),\n        UppercaseHandler(HelloTarget(), GoodbyeTarget())\n    )\n\n    (proxy is HelloTarget) shouldBe false\n    (proxy is GoodbyeTarget) shouldBe false\n    (proxy is Hello) shouldBe true\n    (proxy is Goodbye) shouldBe true\n\n    val hello = proxy as Hello\n    hello.sayHello(&quot;admin&quot;) shouldBe &quot;HELLO ADMIN&quot;\n    hello.sayHi(&quot;admin&quot;) shouldBe &quot;HI ADMIN&quot;\n    hello.sayThankYou(&quot;admin&quot;) shouldBe &quot;HELLO THANK YOU ADMIN&quot;\n\n    val goodbye = proxy as Goodbye\n    goodbye.sayGoodbye(&quot;admin&quot;) shouldBe &quot;GOODBYE ADMIN&quot;\n    goodbye.sayThankYou(&quot;admin&quot;) shouldBe &quot;HELLO THANK YOU ADMIN&quot;\n}</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">Proxy.newProxyInstance()</code>로 중요한 두 가지의 값을 전달해야 한다.</p>\n<ol>\n<li><code class=\"language-text\">InvocationHandler</code>를 구현한 부가기능을 가진 <strong>프록시</strong></li>\n<li><code class=\"language-text\">Hello</code>와 <code class=\"language-text\">Goodbye</code>와 같은 <strong>인터페이스</strong></li>\n</ol>\n<p>런타임 중에 주어진 인터페이스들을 구현하는 프록시 인스턴스를 생성하며, 프록시 인스턴스는 하나의 <code class=\"language-text\">InvocationHandler</code> 인스턴스와 연결된다.<br>\n프록시 인스턴스에 대한 모든 메소드 호출은 <code class=\"language-text\">InvocationHandler</code>의 <code class=\"language-text\">invoke()</code> 메소드로 호출되며, 여기서 타갯 메소드를 호출하기 전에 <strong>추가 기능을 가로채거나 추가할 수 있다.</strong></p>\n<blockquote>\n<p>리플렉션 메소드인 invoke()를 이용해 타깃 오브젝트의 메소드를 호출할 때는 타깃 오브젝트에서 발생하는 예외가 <code class=\"language-text\">InvocationTargetException</code>으로 한 번 포장돼서 전달된다.<br>\n따라서 InvocationTargetException으로 받은 후 <code class=\"language-text\">getTargetException()</code> 메소드로 <strong>중첩되어 있는 예외를 가져와야 한다.</strong></p>\n</blockquote>\n<p><code class=\"language-text\">Method</code>를 이용한 타깃의 오브젝트의 메소드 호출을 구분하거나 <code class=\"language-text\">args</code> 인자들의 정보를 확인하거나 조작할 수 있다.<br>\n리플렉션의 매우 유연하고 막강한 기능을 사용하여 동적 프록시를 조금 더 편하게 만들어보았다.<br>\n하지만 인터페이스 기반이라는 단점이 있다. 이 단점을 해결하는 CGLIB에 대해 알아보자.</p>\n<h2 id=\"cglibcode-generation-library\" style=\"position:relative;\">CGLIB(Code Generation Library)<a href=\"#cglibcode-generation-library\" aria-label=\"cglibcode generation library permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>자바 클래스의 바이트코드를 런타임에 조작하여 새로운 클래스나 객체를 동적으로 생성하고 수정할 수 있는 강력한 라이브러리다.<br>\n이 라이브러리는 스프링 AOP 프레임워크, ORM 툴, 그리고 다양한 테스팅 라이브러리 등에서 널리 사용되고 있다.<br>\n<strong>클래스 기반으로 타겟 객체의 클래스를 상속 받아 새로운 서브 클래스로 프록시를 생성하는 방식이다.</strong><br>\n인터페이스가 없는 클래스에도 적용할 수 있기에 자바의 동적 프록시의 단점을 해결한다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">open class Person: Hello, Goodbye {\n    open fun greeting() = &quot;안녕하세요!&quot;\n    override fun sayHello(name: String): String = &quot;Hello $name&quot;\n    override fun sayHi(name: String): String = &quot;Hi $name&quot;\n    override fun sayThankYou(name: String): String = &quot;Thank you $name&quot;\n    override fun sayGoodbye(name: String): String = &quot;Goodbye $name&quot;\n}\n\nclass MyMethodInterceptor: MethodInterceptor {\n    override fun intercept(proxy: Any, method: Method, args: Array&lt;out Any&gt;, methodProxy: MethodProxy): Any =\n        // 프록시의 슈퍼클래스의 타겟 메서드를 호출한다.\n        &quot;(Intercepted) &quot; + methodProxy.invokeSuper(proxy, args)\n}\n\n&quot;Person 클래스 Cglib 테스트&quot; {\n    val proxy = Enhancer.create(\n        Person::class.java,\n        MyMethodInterceptor()\n    )\n\n    (proxy is Hello) shouldBe true\n    (proxy is Goodbye) shouldBe true\n    (proxy is Person) shouldBe true\n\n    val person = proxy as Person\n    person.greeting() shouldBe &quot;(Intercepted) 안녕하세요!&quot;\n    person.sayHello(&quot;admin&quot;) shouldBe &quot;(Intercepted) Hello admin&quot;\n    person.sayHi(&quot;admin&quot;) shouldBe &quot;(Intercepted) Hi admin&quot;\n    person.sayThankYou(&quot;admin&quot;) shouldBe &quot;(Intercepted) Thank you admin&quot;\n    person.sayGoodbye(&quot;admin&quot;) shouldBe &quot;(Intercepted) Goodbye admin&quot;\n}</code>\n        </deckgo-highlight-code>\n<p>프록시 클래스는 구체적인 클래스와 인터페이스의 서브 클래스이므로, 모든 메서드를 가로챌 수 있다.<br>\n인터페이스를 구현하지 않는 클래스를 프록시하고 싶을 때 유용하다.<br>\n하지만 CGLIB을 통하여 프록시를 생성할 때 지켜야하는 규칙들이 있다.</p>\n<ol>\n<li><strong>클래스를 상속하고 메서드를 오버라이드 하기 때문에 클래스와 메서드가 final이 선언되어 있지 않아야 한다.</strong></li>\n<li><strong>기본 생성자가 꼭 있어야 한다.</strong></li>\n</ol>\n<p>CGLIB은 자바 동적 프록시에 비해 추가적인 기능도 제공한다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">class MyFixedValue: FixedValue {\n    override fun loadObject(): Any = &quot;Intercepted and always return \\&quot;Fixed\\&quot;&quot;\n}\n\nclass MyCallbackFilter : CallbackFilter {\n    override fun accept(method: Method): Int =\n        when(method.name) {\n            &quot;greeting&quot; -&gt; 1 // FixedValue 콜백 사용\n            else -&gt; 0       // MethodInterceptor 사용\n        }\n\n}\n\n&quot;Person 클래스 Cglib Callback, FixedValue 테스트&quot; {\n    val proxy = Enhancer.create(\n        Person::class.java,\n        arrayOf(Hello::class.java, Goodbye::class.java),\n        MyCallbackFilter(),\n        arrayOf&lt;Callback&gt;(MyMethodInterceptor(), MyFixedValue())\n    )\n\n    val person = proxy as Person\n    person.greeting() shouldBe &quot;Intercepted and always return \\&quot;Fixed\\&quot;&quot;\n    person.sayHello(&quot;admin&quot;) shouldBe &quot;(Intercepted) Hello admin&quot;\n    person.sayHi(&quot;admin&quot;) shouldBe &quot;(Intercepted) Hi admin&quot;\n    person.sayThankYou(&quot;admin&quot;) shouldBe &quot;(Intercepted) Thank you admin&quot;\n    person.sayGoodbye(&quot;admin&quot;) shouldBe &quot;(Intercepted) Goodbye admin&quot;\n}</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">Enhancer.create()</code>에서 전달하는 Callback 순서대로 (<code class=\"language-text\">arrayOf&lt;Callback>(MyMethodInterceptor(), MyFixedValue())</code>) <code class=\"language-text\">CallbackFilter</code>에서 어떤 콜백을 실행할지 지정할 수 있다.</p>\n<h1 id=\"4단계-프록시의-구현체-생성-방법을-선택하는-proxyfactory\" style=\"position:relative;\">4단계: 프록시의 구현체 생성 방법을 선택하는 ProxyFactory<a href=\"#4%EB%8B%A8%EA%B3%84-%ED%94%84%EB%A1%9D%EC%8B%9C%EC%9D%98-%EA%B5%AC%ED%98%84%EC%B2%B4-%EC%83%9D%EC%84%B1-%EB%B0%A9%EB%B2%95%EC%9D%84-%EC%84%A0%ED%83%9D%ED%95%98%EB%8A%94-proxyfactory\" aria-label=\"4단계 프록시의 구현체 생성 방법을 선택하는 proxyfactory permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>스프링에서 제공하는 AOP 프록시용 팩토리는 인터페이스가 있을 때는 JDK 동적 프록시를 사용하고, 그렇지 않은 경우에는 CGLIB을 사용한다.<br>\n이제는 부가기능을 적용할 때 <code class=\"language-text\">Advice (부가기능)</code>만 지정해주면된다. <code class=\"language-text\">InvocationHandler</code>나 <code class=\"language-text\">MethodInterceptor</code>를 알 필요가 없다.<br>\n프록시 팩토리가 내부에서 JDK 동적 프록시일 경우 InvocationHandler가 Advice를 호출하도록 하고, CGLIB인 경우 MethodInterceptor가 Advice를 호출하도록 기능을 개발해두었기 때문이다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">interface Hello {\n    fun sayHello(name: String): String\n    fun sayHi(name: String): String\n    fun sayThankYou(name: String): String\n}\n\nopen class Person: Hello {\n    open fun greeting() = &quot;안녕하세요!&quot;\n    override fun sayHello(name: String): String = &quot;Hello $name&quot;\n    override fun sayHi(name: String): String = &quot;Hi $name&quot;\n    override fun sayThankYou(name: String): String = &quot;Thank you $name&quot;\n}\n\nopen class ConcretePerson {\n    open fun greeting() = &quot;Concrete 안녕하세요!&quot;\n    open fun sayHello(name: String): String = &quot;Concrete Hello $name&quot;\n    open fun sayHi(name: String): String = &quot;Concrete Hi $name&quot;\n    fun sayThankYou(name: String): String = &quot;Concrete Thank you $name&quot;\n}\n\nclass MyMethodInterceptor1: MethodInterceptor {\n    override fun invoke(invocation: MethodInvocation): String = \n        &quot;(Intercepted1)&quot; + invocation.proceed()\n}\n\nclass MyMethodInterceptor2: MethodInterceptor {\n    override fun invoke(invocation: MethodInvocation): String = \n        &quot;(Intercepted2)&quot; + invocation.proceed()\n}\n\n&quot;인터페이스가 있으면 JDK 동적 프록시 사용&quot; {\n    val proxyFactory: ProxyFactory = ProxyFactory(Person())\n    proxyFactory.addAdvice(MyMethodInterceptor1())\n    proxyFactory.addAdvice(MyMethodInterceptor2())\n\n    shouldThrowExactly&lt;ClassCastException&gt; { proxyFactory.proxy as Person }\n\n    val proxy = proxyFactory.proxy as Hello\n\n    proxy.javaClass.toString() shouldBe &quot;class jdk.proxy2.\\$Proxy7&quot;\n\n    proxy.sayHello(&quot;admin&quot;) shouldBe &quot;(Intercepted1)(Intercepted2)Hello admin&quot;\n    proxy.sayHi(&quot;admin&quot;) shouldBe &quot;(Intercepted1)(Intercepted2)Hi admin&quot;\n    proxy.sayThankYou(&quot;admin&quot;) shouldBe &quot;(Intercepted1)(Intercepted2)Thank you admin&quot;\n}\n\n&quot;구체 클래스만 있으면 CGLIB 사용&quot; {w\n    val proxyFactory: ProxyFactory = ProxyFactory(ConcretePerson())\n    proxyFactory.addAdvice(MyMethodInterceptor1())\n    proxyFactory.addAdvice(MyMethodInterceptor2())\n\n    val proxy = proxyFactory.proxy as ConcretePerson\n\n    proxy.javaClass.toString() shouldBe &quot;class ConcretePerson$\\$SpringCGLIB$$0&quot;\n\n    proxy.greeting() shouldBe &quot;(Intercepted1)(Intercepted2)Concrete 안녕하세요!&quot;\n    proxy.sayHello(&quot;admin&quot;) shouldBe &quot;(Intercepted1)(Intercepted2)Concrete Hello admin&quot;\n    proxy.sayHi(&quot;admin&quot;) shouldBe &quot;(Intercepted1)(Intercepted2)Concrete Hi admin&quot;\n    // open 되지 않은 메서드는 프록시가 실행되지 않는다.\n    proxy.sayThankYou(&quot;admin&quot;) shouldBe &quot;Concrete Thank you admin&quot;\n}\n\n&quot;인터페이스가 있어도 클래스 기반 CGLIB 프록시 사용&quot; {\n    val proxyFactory: ProxyFactory = ProxyFactory(Person())\n    proxyFactory.isProxyTargetClass = true\n    proxyFactory.addAdvice(MyMethodInterceptor1())\n    proxyFactory.addAdvice(MyMethodInterceptor2())\n\n    val proxy = proxyFactory.proxy as Person\n\n    proxy.javaClass.toString() shouldBe &quot;class Person$\\$SpringCGLIB$$0&quot;\n\n    proxy.greeting() shouldBe &quot;(Intercepted1)(Intercepted2)안녕하세요!&quot;\n    proxy.sayHello(&quot;admin&quot;) shouldBe &quot;(Intercepted1)(Intercepted2)Hello admin&quot;\n    proxy.sayHi(&quot;admin&quot;) shouldBe &quot;(Intercepted1)(Intercepted2)Hi admin&quot;\n    proxy.sayThankYou(&quot;admin&quot;) shouldBe &quot;(Intercepted1)(Intercepted2)Thank you admin&quot;\n}</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code  terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">-- JDK 동적 프록시를 사용하는 경우\ninvoke:36, MyMethodInterceptor1\ninvoke:35, MyMethodInterceptor1\nproceed:184, ReflectiveMethodInvocation (org.springframework.aop.framework)\ninvoke:220, JdkDynamicAopProxy (org.springframework.aop.framework)\nsayHello:-1, $Proxy7 (jdk.proxy2)\n\n-- CGLIB을 사용하는 경우\ninvoke:36, MyMethodInterceptor1\ninvoke:35, MyMethodInterceptor1\nproceed:184, ReflectiveMethodInvocation (org.springframework.aop.framework)\nproceed:765, CglibAopProxy$CglibMethodInvocation (org.springframework.aop.framework)\nintercept:717, CglibAopProxy$DynamicAdvisedInterceptor (org.springframework.aop.framework)\ngreeting:-1, Person$$SpringCGLIB$$0</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"java\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">@FunctionalInterface\npublic interface MethodInterceptor extends Interceptor {\n\t@Nullable\n\tObject invoke(@Nonnull MethodInvocation invocation) throws Throwable;\n}</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">invoke()</code>의 파라미터인 <code class=\"language-text\">MethodInvocation</code> 내부에는 <strong>다음 메서드를 호출하는 방법</strong>, <strong>현재 프록시 객체 인스턴스</strong>, <strong>args</strong>, <strong>메서드 정보</strong>등이 포함되어 있다.<br>\nTarget이 MethodInvocation안에 포함되어 있기 때문에 이전 방법과 다르게 프록시 내부에서 Target을 신경쓰지 않아도 된다.</p>\n<p>스프링 부트는 AOP를 적용할 때 기본적으로 <code class=\"language-text\">proxyTargetClass=true</code>로 설정해서 사용하기 때문에 <strong>인터페이스가 있어도 CGLIB을 사용해서 구체 클래스를 기반으로 프록시를 생성한다.</strong></p>\n<h1 id=\"5단계-factorybean\" style=\"position:relative;\">5단계: FactoryBean<a href=\"#5%EB%8B%A8%EA%B3%84-factorybean\" aria-label=\"5단계 factorybean permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>스프링을 대신해서 오브젝트의 생성 로직을 담당하도록 만들어진 특별한 빈이다.<br>\n생성할 프록시가 다른 빈을 주입 받을 필요가 있거나 스프링의 기능을 사용해야 한다면 스프링 빈으로 등록해야 한다.<br>\n이때 <strong>스프링은 <code class=\"language-text\">FactoryBean</code> 인터페이스를 구현한 클래스가 Bean의 클래스로 지정되면 <code class=\"language-text\">getObject()</code>를 통해 오브젝트를 가져오고, 이를 빈 오브젝트로 사용한다.</strong></p>\n<ul>\n<li>복잡한 초기화가 필요한 빈을 생성 시</li>\n<li>AOP 프록시와 같이 런타임에 생성되는 프록시 객체를 스프링 빈으로 등록할 때</li>\n</ul>\n<p>이런 경우 유용하게 사용할 수 있다.<br>\n<code class=\"language-text\">@Transactional</code>과 같은 역할을 하는 특정 패턴의 메서드는 정상 처리가 되었다면 commit을 하고 예러가 발생되면 rollback하는 프록시를 만들어보자.<br>\n아래의 예제를 확인해보자.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">/**\n * 프록시로 등록할 인터페이스와 구현체\n */\ninterface Hello {\n    fun sayGreeting(name: String): String\n    fun sayHello(name: String): String\n    fun sayHi(name: String): String\n    fun sayThankYou(name: String): String\n}\nopen class Person: Hello {\n    open fun greeting() = &quot;안녕하세요!&quot;\n    override fun sayGreeting(name: String) = &quot;안녕하세요! $name&quot;\n    override fun sayHello(name: String): String = &quot;Hello $name&quot;\n    override fun sayHi(name: String): String = &quot;Hi $name&quot;\n    override fun sayThankYou(name: String): String = &quot;Thank you $name&quot;\n}\n\n/**\n * 등록할 프록시를 스프링에서 관리할 수 있도록 빈으로 등록하는 FactoryBean 구현체\n * 범용적으로 대상은 Any로 했고, Class 타입도 * 이다.\n */\nclass PersonFactoryBean(\n    private val target: Any,\n    private val `interface`: Class&lt;*&gt;\n): FactoryBean&lt;Any&gt; {\n\n    // 인터페이스 기반이 아닌 Person 구현체의 프록시를 생성하기 ProxyFactory로 프록시를 생성\n    // ProxyFactory로 프록시를 생성하기 위해서는 (TransactionMethodInterceptor와 같은) 부가기능은 org.aopalliance.intercept.MethodInterceptor를 구현해야 한다.\n    override fun getObject() = ProxyFactory(target).apply {\n        this.addAdvice(TransactionMethodInterceptor(&quot;say&quot;))\n        this.isProxyTargetClass = true\n    }.proxy\n\n    override fun getObjectType(): Class&lt;*&gt; = `interface`\n}\n\n/**\n * 부가기능을 정의한 MethodInterceptor 구현체이다.\n * 메소드 이름이 주입받은 pattern으로 시작하는 메소드만 부가기능을 실행하도록 한다.\n */\nclass TransactionMethodInterceptor(\n    private val target: Any,\n    private val pattern: String\n): MethodInterceptor {\n\n    override fun invoke(invocation: MethodInvocation) =\n        if (invocation.method.name.startsWith(pattern)) invokeInTransaction(invocation)\n        else invocation.proceed()\n\n    private fun invokeInTransaction(invocation: MethodInvocation): String =\n        try {\n            &quot;(Commit)&quot; + invocation.proceed()\n        } catch (e: InvocationTargetException) {\n            throw e.targetException\n        }\n}\n\n/**\n * Hello와 Person 빈을 등록할 때 프록시로 감싼 빈으로 등록한다.\n */\n@Configuration\nclass AppConfig {\n    @Bean\n    fun hello() = PersonFactoryBean(Person(), Hello::class.java)\n    @Bean\n    fun person() = PersonFactoryBean(Person(), Person::class.java)\n}\n\n@SpringBootTest(&quot;spring.profiles.active=local&quot;, classes = [AppConfig::class])\nclass FactoryBeanTest(\n    private val context: ApplicationContext,\n    private val hello: Hello,\n    private val person: Person\n): AnnotationSpec() {\n\n    private val NAME: String = &quot;admin&quot;\n\n    init {\n        extension(SpringExtension)\n    }\n\n    @Test\n    @DisplayName(&quot;인터페이스 기반 프록시&quot;)\n    fun interfaceProxy() {\n        hello.sayGreeting(NAME) shouldBe &quot;(Commit)안녕하세요! admin&quot;\n        hello.sayHello(NAME) shouldBe &quot;(Commit)Hello admin&quot;\n        hello.sayHi(NAME) shouldBe &quot;(Commit)Hi admin&quot;\n        hello.sayThankYou(NAME) shouldBe &quot;(Commit)Thank you admin&quot;\n    }\n\n    @Test\n    @DisplayName(&quot;클래스 기반 프록시&quot;)\n    fun concreteProxy() {\n        person.greeting() shouldBe &quot;안녕하세요!&quot;\n        person.sayGreeting(NAME) shouldBe &quot;(Commit)안녕하세요! admin&quot;\n        person.sayHello(NAME) shouldBe &quot;(Commit)Hello admin&quot;\n        person.sayHi(NAME) shouldBe &quot;(Commit)Hi admin&quot;\n        person.sayThankYou(NAME) shouldBe &quot;(Commit)Thank you admin&quot;\n    }\n\n    @Test\n    @DisplayName(&quot;팩토리 빈과 빈을 직접 조회하기&quot;)\n    fun searchFactoryBean() {\n        val factoryBean = context.getBean(&quot;&amp;person&quot;, PersonFactoryBean::class.java)\n        (factoryBean.`object` is Person) shouldBe true\n        (factoryBean.`object` is Hello) shouldBe true\n\n        val helloBean = context.getBean(&quot;hello&quot;, Hello::class.java)\n        helloBean.sayGreeting(NAME) shouldBe &quot;(Commit)안녕하세요! admin&quot;\n        helloBean.sayHello(NAME) shouldBe &quot;(Commit)Hello admin&quot;\n        helloBean.sayHi(NAME) shouldBe &quot;(Commit)Hi admin&quot;\n        helloBean.sayThankYou(NAME) shouldBe &quot;(Commit)Thank you admin&quot;\n\n        val personBean = context.getBean(&quot;person&quot;, Person::class.java)\n        personBean.greeting() shouldBe &quot;안녕하세요!&quot;\n        personBean.sayGreeting(NAME) shouldBe &quot;(Commit)안녕하세요! admin&quot;\n        personBean.sayHello(NAME) shouldBe &quot;(Commit)Hello admin&quot;\n        personBean.sayHi(NAME) shouldBe &quot;(Commit)Hi admin&quot;\n        personBean.sayThankYou(NAME) shouldBe &quot;(Commit)Thank you admin&quot;\n\n        System.identityHashCode(hello) shouldBe System.identityHashCode(helloBean)\n        System.identityHashCode(person) shouldBe System.identityHashCode(personBean)\n    }\n}</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">say</code>로 시작하는 메서드의 반환값에 <code class=\"language-text\">(Commit)</code> 문자열을 추가하여 반환하는 부가기능을 <code class=\"language-text\">TransactionMethodInterceptor</code>로 정의하여 빈을 등록할 때 <code class=\"language-text\">PersonFactoryBean</code>을 통해 프록시로 감싼 빈을 등록하였다.</p>\n<p>하지만 빈을 직접 등록해야 하는 불편함이 있다.</p>\n<ul>\n<li><strong>한 번에 여러 개의 클래스에 공통적인 부가기능을 제공해야 한다면?</strong> 비즈니스 로직을 담은 많은 클래스의 메소드에 부가기능을 적용하려 한다면 팩토리 빈의 설정 코드도 같이 늘어난다.</li>\n<li><strong>하나의 타깃에 여러 개의 부가기능을 적용해야 한다면?</strong> 프록시를 생성하는 FactoryBean 구현체마다 advice를 직접 추가해줘야 한다.</li>\n</ul>\n<p>이렇게 번거로운 작업을 없애고 프록시를 모든 타깃에 적용 가능한 싱글톤 빈으로 만드는 방법을 알아보자.</p>\n<h1 id=\"6단계-부가기능을-구현하는-차이점\" style=\"position:relative;\">6단계: 부가기능을 구현하는 차이점<a href=\"#6%EB%8B%A8%EA%B3%84-%EB%B6%80%EA%B0%80%EA%B8%B0%EB%8A%A5%EC%9D%84-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94-%EC%B0%A8%EC%9D%B4%EC%A0%90\" aria-label=\"6단계 부가기능을 구현하는 차이점 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>이때까지 작성한 예제를 보면 어떤 부가기능은 <code class=\"language-text\">java.lang.reflect.InvocationHandler</code>를 구현하였고 어떤 부가기능은 <code class=\"language-text\">org.aopalliance.intercept.MethodInterceptor</code>를 구현하였다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">class MyInvocationHandler(\n    private val target: Any\n): InvocationHandler {\n    override fun invoke(proxy: Any, method: Method, args: Array&lt;out Any&gt;): Any =\n        method.invoke(target, *args)\n}</code>\n        </deckgo-highlight-code>\n<p>자바에서 제공하는 <code class=\"language-text\">InvocationHandler</code>는 타겟이 달라지거나 메서드 선정 조건이 달라진다면 여러 프록시가 공유할 수 없었다.<br>\n즉, <strong>부가기능 내부에서 타겟과 메소드 선정을 함께하고 있기 떄문에 오브젝트 차원에서 특정 타깃을 위한 프록시에 제한된다는 것이다.</strong></p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">class MyMethodInterceptor: MethodInterceptor {\n    override fun invoke(invocation: MethodInvocation) = invocation.proceed()\n}</code>\n        </deckgo-highlight-code>\n<p>그에 반해, <code class=\"language-text\">MethodInterceptor.invoke()</code>는 <code class=\"language-text\">MethodInvocation</code>을 통해 타깃 오브젝트에 대한 의존이 사라졌다.<br>\n그 이유는 <strong>스프링이 aopaliance에서 제공하는 <code class=\"language-text\">MethodInvocation</code>을 확장하고 구현하여 타겟에 대한 정보, 메서드, 인자, 부가기능 등을 가진 Advice를 필드에 가지고 있기 때문이다.</strong></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 900px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/7aadce2fa23bdf9b8bbf54caeb6bb450/f02b9/methodInvocation.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 74.66666666666667%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAACNElEQVR42p1T23baMBDkJ3pOW8DYsm6WbxhsY64hKcZA2v//nOmuCD1tnpI+DFgraTQ7Go2CUOAjkErBWI1yUWCxrNC0NbquRVnmvs6YRQKjjxIaazAOQiyIaLvd4jwMuFxvcFmJL18n0EZDxPJzhKxgGkSYEHEgQ4wnAbpVic26QpJYhCL+OKFNDKazCI5aXHUddvsDDk9H5EWBKI69wuizCplQWYs0L9BsWsyrJUIi+T6dQen/IIykgjIJTJJCOwepLazLEEQSii5NyDdCPvmB90SPOm8olyW1ucflcsVwHdD3Pc7nM1yaQZPCPx5GxBzRhjukx4wmuZ1HXXBsyEdlFWItYXMDaUiZoboziMnDKXGNeKHQym/+Gya3UM74w/hknSbo9ms8v/xAT5FhvJxOOJHC3eGJyCk2JGTEzMFbHO7tcRxmEJaIpMC38RRjMn0WRoiVpoAbaOv8bSvyUJOnsTQ+SiyMCJVv7+GXtBmKqsaybgkrNKvO36q0OYr5AnWzQrWsUbcNvZjGfy/rhuYqIpTvCUPyY46qWeNIGXs6HLGlvM2rBUxKz2218fnb7vZ47n/6/81252t100IQ14h/2KNQSI+AWjMRecbvlyBYNY2VuIPrbEEQJx6T4D7mllncKIwFsqrFYXekGJxx6ge8DldcCP1wwUAR4beb5DUO+2f8ut1wvb36tf158PPrzc6L8oTcqnYJbOYIqYdJHRGkHq7IaJzQjf+75o77Op5nMr7c3z4hutFSsVmrAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"methodInvocation\"\n        title=\"\"\n        src=\"/static/7aadce2fa23bdf9b8bbf54caeb6bb450/1cfc2/methodInvocation.png\"\n        srcset=\"/static/7aadce2fa23bdf9b8bbf54caeb6bb450/3684f/methodInvocation.png 225w,\n/static/7aadce2fa23bdf9b8bbf54caeb6bb450/fc2a6/methodInvocation.png 450w,\n/static/7aadce2fa23bdf9b8bbf54caeb6bb450/1cfc2/methodInvocation.png 900w,\n/static/7aadce2fa23bdf9b8bbf54caeb6bb450/21482/methodInvocation.png 1350w,\n/static/7aadce2fa23bdf9b8bbf54caeb6bb450/f02b9/methodInvocation.png 1554w\"\n        sizes=\"(max-width: 900px) 100vw, 900px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>즉, 이제 부가기능을 정의하던 <code class=\"language-text\">MethodInterceptor</code>는 부가기능 자체에만 집중할 수 있게 되므로 많은 곳에서 재사용할 수 있게 되었다.<br>\n<code class=\"language-text\">ProxyFactoryBean</code>은 MethodInterceptor 방식을 사용하고 있다.</p>\n<h1 id=\"7단계-proxyfactorybean\" style=\"position:relative;\">7단계: ProxyFactoryBean<a href=\"#7%EB%8B%A8%EA%B3%84-proxyfactorybean\" aria-label=\"7단계 proxyfactorybean permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 900px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/5a003b0806e77a553858c5dfeea16347/0a867/proxyFactory.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 76.88888888888889%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAIAAABr+ngCAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB9UlEQVR42oVTi46qMBT0M1ToAyjlVYoCgsq6SiKCPBR3c///V+5B1s2N7uYmQ0Pazpkz03aCif4NhDVNZ74MgkW4StZxnALgJ0nWnvBh9d/NgMkTWTd4kqbbLKuquu7aqqlPZVVWdRwnKnolY01FVEFUvUNRyQBEpjOEDU0lZDpVYeZVdiBT3bQc6QnpesL1pC+XnDsGs2xHwKQvF54nKTVemQPZtPx0V+V53t3+nOv2eu03m8zz/CzLzk19vfXQNgTxszJ8BApjysSaMnfcNI6Gw3WT/aj5HJimMdMOGPc0zYDYGOcwkl8afiJr0abYH46X7nLtP/vbx+322bUXxxWQ4n/ICOuaziEnA6SjPXcC07RM0xmVwcWvnu+2dUqHTSoixHDgSIeTU8mYCNUYjHf+V5Wx6ARTQ1WxjHZvh1NVlW13aZqubQdA8kVxgkNbvSWHQw6GznXT9x9V3bwfC87tydgVMx3b8V3Xh2sYbksZroW/8IPI9QKdWdyGVSFEEG5iKRdwHWxXQDvfnqFJpKh4pmBkCIVwBZuIWpialHkKNmZzNJ2BDzJT0HyOwRRIPjwTfZHk2+y9LM+A4niEhl2QiHbZ7nA6VSOKomyadr/PH54f0TkigrsZRavVanhM8So1uW17oQzCMIrHGUCSbpbLaEz7L5HHkj0uA11lAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"proxyFactory\"\n        title=\"\"\n        src=\"/static/5a003b0806e77a553858c5dfeea16347/1cfc2/proxyFactory.png\"\n        srcset=\"/static/5a003b0806e77a553858c5dfeea16347/3684f/proxyFactory.png 225w,\n/static/5a003b0806e77a553858c5dfeea16347/fc2a6/proxyFactory.png 450w,\n/static/5a003b0806e77a553858c5dfeea16347/1cfc2/proxyFactory.png 900w,\n/static/5a003b0806e77a553858c5dfeea16347/0a867/proxyFactory.png 986w\"\n        sizes=\"(max-width: 900px) 100vw, 900px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>Pointcut과 Advice를 재사용할 수 있는 <code class=\"language-text\">MethodInterceptor</code>에 대해 알아보았다. <strong>스프링은 Pointcut과 Advice를 사용하여 프록시 오브젝트를 생성해주는 기술을 추상화한 팩토리 빈을 제공한다.</strong><br>\n(ProxyFactory와 비슷한 기능을 제공하지만 <code class=\"language-text\">FactoryBean</code>을 추가로 구현하는 것이다.)</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">@Configuration\nclass AppConfig {\n    @Bean\n    fun personProxyFactoryBean() = ProxyFactoryBean().apply {\n        this.setTarget(Person())\n        this.addAdvisor(advisor())\n        this.isProxyTargetClass = true\n    }\n\n    // Pointcut과 Advice를 묶어서 Advisor 타입으로 전달하는 이유는\n    // 여러 개의 어드바이스와 포인트컷이 추가될 수 있기 때문에 &quot;이 포인트컷은 이 어드바이스에 적용한다&quot; 라고 알리기 위해서다\n    @Bean\n    fun advisor() = DefaultPointcutAdvisor(pointcut(), advice())\n\n    @Bean\n    fun pointcut() = NameMatchMethodPointcut().apply {\n        this.setMappedName(&quot;sayH*&quot;)\n    }\n\n    @Bean\n    fun advice() = MethodInterceptor { it: MethodInvocation -&gt;\n        &quot;intercept!!! &quot; + (it.proceed() as String)\n    }\n}\n\n@SpringBootTest(&quot;spring.profiles.active=local&quot;, classes = [AppConfig::class])\nclass FactoryBeanTest(\n    private val context: ApplicationContext,\n    private val person: Person\n): AnnotationSpec() {\n\n    private val NAME: String = &quot;admin&quot;\n\n    init {\n        extension(SpringExtension)\n    }\n\n    @Test\n    @DisplayName(&quot;ProxyFactoryBean 테스트&quot;)\n    fun proxyFactoryBean() {\n        person.greeting() shouldBe &quot;안녕하세요!&quot;\n        person.sayGreeting(NAME) shouldBe &quot;안녕하세요! admin&quot;\n        person.sayHello(NAME) shouldBe &quot;intercept!!! Hello admin&quot;\n        person.sayHi(NAME) shouldBe &quot;intercept!!! Hi admin&quot;\n        person.sayThankYou(NAME) shouldBe &quot;Thank you admin&quot;\n        shouldThrow&lt;java.lang.RuntimeException&gt; { person.throwException() }\n            .message shouldBe &quot;예외 테스트!&quot;\n\n        val proxyFactoryBean = context.getBean(&quot;&amp;personProxyFactoryBean&quot;, ProxyFactoryBean::class.java)\n        val person2 = proxyFactoryBean.`object` as Person\n\n        person2.greeting() shouldBe &quot;안녕하세요!&quot;\n        person2.sayGreeting(NAME) shouldBe &quot;안녕하세요! admin&quot;\n        person2.sayHello(NAME) shouldBe &quot;intercept!!! Hello admin&quot;\n        person2.sayHi(NAME) shouldBe &quot;intercept!!! Hi admin&quot;\n        person2.sayThankYou(NAME) shouldBe &quot;Thank you admin&quot;\n        shouldThrow&lt;java.lang.RuntimeException&gt; { person2.throwException() }\n            .message shouldBe &quot;예외 테스트!&quot;\n\n        System.identityHashCode(person) shouldBe System.identityHashCode(person2)\n    }\n}\n\ninterface Hello {\n    fun sayGreeting(name: String): String\n    fun sayHello(name: String): String\n    fun sayHi(name: String): String\n    fun sayThankYou(name: String): String\n    fun throwException(): Nothing\n}\n\nopen class Person: Hello {\n    open fun greeting() = &quot;안녕하세요!&quot;\n    override fun sayGreeting(name: String): String = &quot;안녕하세요! $name&quot;\n    override fun sayHello(name: String): String = &quot;Hello $name&quot;\n    override fun sayHi(name: String): String = &quot;Hi $name&quot;\n    override fun sayThankYou(name: String): String = &quot;Thank you $name&quot;\n    override fun throwException(): Nothing = throw RuntimeException(&quot;예외 테스트!&quot;)\n}</code>\n        </deckgo-highlight-code>\n<p>Pointcut과 Advice는 여러 프록시에서 공유가 가능하도록 만들 수 있기 때문에 스프링의 싱글톤 빈으로 등록이 가능하다.<br>\n그렇기에 <strong>프록시를 생성할 때 사용되는 Pointcut과 Advice는 스프링의 DI로 주입하여 사용 할 수 있다.</strong><br>\nInvocationHandler와 다르게 부가기능 구현체는 클라이언트로부터 받는 요청을 일일이 전달받을 필요가 없어졌다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 566px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/dcf33ea9b90e862da3f1d6cc895f319e/6fe44/proxyFactoryBean.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 97.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAIAAAAf7rriAAAACXBIWXMAAAsTAAALEwEAmpwYAAACpUlEQVR42nVT246bMBDN/39Epb626kVqH9qHStvV3nJvkt0NkBBCMMQBE3zBEDA2dZJNGiL1aLAMzBnNHB+3qPHTaX+z7r+gyY86j1Rd1+qw1A1cvR7RUszLkc1DS9KVEtmBu88Uosx4qiNltNjtjt+VOpdSB3JdE8aDDZLqX3Uhle3Tu771MJjddo2JHeblW09S7kvoR29a0xUZzcKhtXl1yZZkGnmWQUQtKKZe2nkJRjYyofBRXuwyhLkdiskiNgGbgqz1NEU3g+X9CDw8b2DMKUkwTgCMLdudWWYQrG177rirALGUET8kr4G8HXo9C3XmvMVymRY129U0l6KSx7Z5Xi38xPGipR87IFqAOKb7sXUCTgUr9smYi9Zp+jcN1AlFKQuhdJTVfq0Os54UuxCswT6BEJxl/Cz+Ua19XCS3Lio1KmCMOefHfVVVyTbWh3d9zvV/cO4wToUD087I1oe3weVZlzey9oairtIm0cE8Javzbz3t3Kc+3FoL4AXRwieYVycTHsgVg8vHz87jV/P2I+h/r0Wq9g4TtZIJzZ4t13MXhjG1Z6bjQZKpBlkVtIBj6vbYqr+Dz7UsylKgOAbAc1xg+tz2SXc0M11kAE4y2SAfZ4Mw2G7RhbdFJcqiqvXAIcJgHYUxcdb0uu1CyJAqD+VBIkIipJR5nvtBsIEQ+PCpMxwO+p1OZzwavBjzazLNqoFNe7Ntd86ma5GwnGcZYwwnCQhCw/aiMDSt2Xrtr4IoSUWTnMun1819b97+dXfz48ZodzPfS1MeRSFm+Qom2vDa8Txl/holrGyQ07yyQrUEKWs//H7/7s+nD2TQi+MtwTja0vHU0Vd6PJ5on+j7EdMmWStUClmWVVWWSofQIY4ySlUHiK8gDiIGNsSFRAt0Nslf+8E0xD0MQgQAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"proxyFactoryBean\"\n        title=\"\"\n        src=\"/static/dcf33ea9b90e862da3f1d6cc895f319e/6fe44/proxyFactoryBean.png\"\n        srcset=\"/static/dcf33ea9b90e862da3f1d6cc895f319e/3684f/proxyFactoryBean.png 225w,\n/static/dcf33ea9b90e862da3f1d6cc895f319e/fc2a6/proxyFactoryBean.png 450w,\n/static/dcf33ea9b90e862da3f1d6cc895f319e/6fe44/proxyFactoryBean.png 566w\"\n        sizes=\"(max-width: 566px) 100vw, 566px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li><code class=\"language-text\">[1]</code> : <code class=\"language-text\">CglibAopProxy.ProxyCallbackFilter</code>에서 등록된 Pointcut을 통해 부가기능 대상인지 확인한다.</li>\n<li><code class=\"language-text\">[2,3]</code> : <code class=\"language-text\">CglibAopProxy.DynamicAdvisedInterceptor</code>에서 부가기능들을 관리하고 실행시키는 역할을 한다.</li>\n<li><code class=\"language-text\">[4]</code> : <code class=\"language-text\">CglibMethodInvocation</code> → <code class=\"language-text\">ReflectiveMethodInvocation</code> 에서 부가기능과 타겟을 실행한다.</li>\n</ul>\n<blockquote>\n<p>실제 위임 대상인 타깃 오브젝트의 레퍼런스를 갖고 있고, 이를 이용해 타깃 메소드를 직접 호출하는 것은 프록시가 메소드 호출에 따라 만드는 <code class=\"language-text\">Invocation Callback</code>의 역할이다.<br>\n재사용 가능한 기능을 만들어두고 \"바뀌는 부분 (콜백 오브젝트와 메소드 호출정보)\"만 외부에서 주입해서 이를 \"작업 흐름 (부가기능 부여)\" 중에 사용하도록 하는 전형적인 <strong>템플릿/콜백</strong> 구조다.</p>\n</blockquote>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 900px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/7e1adceb41d12b5a1870848a720e632c/966a0/proxyFactoryBean2.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 42.66666666666667%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAABnUlEQVR42lVSiXLbIBD1/39cZzpNkzRumsq2LEACBIhD6HhdcOvGK+0sy7Bv3x4HfJJly3BJIy0e8xIQ5umuMfuqie5jprslYps1ltBVWzT7Kw7Yd4LaK2AJ8GnDiVkw6bFu/5OlmCC4AGccQz9AjgpGtwjeYZAjRkPJHCPAT1KYxbyhuSp8fT1BSIs0ZyiloLWCEAKMMfR9DzNZTLYjVRgGSqA0AvmHZAVRJccHAuDwk0OeZ1xlwPOvHg1z4JzXoK7rcLlcwDpWGWp5roBC9MSSWuU4DvbyhEm8U4BErwSMM8Rqhmgljk8faN7OaJoGMcbKrIArKes7O7bwTlMFmkp2N8DHkmkQU8T5vcXzlx9Q/YicaFDOwRhTSy9MNQFY6p2nnoVppHaMMNYhTn8B9zIY+iP1MIUZ3YlDXAds635PlnOGLFUQywI4EsMylOgt9EhnR7GTeGRYpjyvqZ738u3bzeJm/0nx4xqx0Irtq79vyRr7R8DCNOVY1XmD1+PLXV/evqPjLe1npL0sK7VSQMbAf+Pj5zd05yOCE/gDaGCzCYB3nTsAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"proxyFactoryBean2\"\n        title=\"\"\n        src=\"/static/7e1adceb41d12b5a1870848a720e632c/1cfc2/proxyFactoryBean2.png\"\n        srcset=\"/static/7e1adceb41d12b5a1870848a720e632c/3684f/proxyFactoryBean2.png 225w,\n/static/7e1adceb41d12b5a1870848a720e632c/fc2a6/proxyFactoryBean2.png 450w,\n/static/7e1adceb41d12b5a1870848a720e632c/1cfc2/proxyFactoryBean2.png 900w,\n/static/7e1adceb41d12b5a1870848a720e632c/966a0/proxyFactoryBean2.png 944w\"\n        sizes=\"(max-width: 900px) 100vw, 900px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>Pointcut과 Advice, 이 둘을 묶는 Advisor 각각 빈으로 등록하여 중복을 제거할 수 있게 되었다.<br>\n하지만 <strong>부가기능의 적용이 필요한 타깃 오브젝트마다 거의 비슷한 내용의 ProxyFactoryBean 빈 설정정보를 직접 작성해줘야하는 단점이 있다.</strong><br>\n타겟을 제외하면 빈 클래스의 종류, Advice, Pointcut의 설정이 거의 동일하며 빈으로 관리가 가능한데 이러한 중복을 제거할 수 있는 방법은 없을까?</p>\n<h1 id=\"8단계-빈-후처리기를-이용한-자동-프록시-생성기\" style=\"position:relative;\">8단계: 빈 후처리기를 이용한 자동 프록시 생성기<a href=\"#8%EB%8B%A8%EA%B3%84-%EB%B9%88-%ED%9B%84%EC%B2%98%EB%A6%AC%EA%B8%B0%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9E%90%EB%8F%99-%ED%94%84%EB%A1%9D%EC%8B%9C-%EC%83%9D%EC%84%B1%EA%B8%B0\" aria-label=\"8단계 빈 후처리기를 이용한 자동 프록시 생성기 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>이제 스프링에서 프록시를 자동으로 생성하는 방법에 대해 알아볼 차례다.<br>\n말 그대로 <strong>스프링 빈 오브젝트로 만들어지고 난 후에, 빈 오브젝트를 다시 가공할 수 있게 해주는 것이다.</strong><br>\n<code class=\"language-text\">BeanPostProcessor</code>를 직접 구현한 아래의 예제를 보자.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">/**\n * 생성자로 pattern을 주입받아 빈의 이름이 해당 pattern으로 시작하는 빈만 프록시를 감싸서 반환하고 그렇지 않으면 빈 자체를 반환한다.\n */\nclass ClassLogTracePostProcessor(\n    private val pattern: String,\n    private val advisor: Advisor\n): BeanPostProcessor {\n\n    private val log = logger()\n    override fun postProcessBeforeInitialization(bean: Any, beanName: String): Any {\n        log.info(&quot;[before] pattern = $pattern, beanName = $beanName, bean = ${bean.javaClass}&quot;)\n        return bean\n    }\n\n    override fun postProcessAfterInitialization(bean: Any, beanName: String): Any {\n        log.info(&quot;[after] pattern = $pattern, beanName = $beanName, bean = ${bean.javaClass}&quot;)\n        if(!beanName.startsWith(pattern)) return bean\n\n        val proxy = ProxyFactory(bean).apply {\n            this.addAdvisor(advisor)\n            this.isProxyTargetClass = true\n        }.proxy\n\n        log.info(&quot;[after - proxy] target = ${bean.javaClass}, proxy = ${proxy.javaClass}&quot;)\n        return proxy\n    }\n}\n\n@Configuration\nclass PostProcessorConfig {\n    @Bean\n    fun classLogTracePostProcessor() = ClassLogTracePostProcessor(&quot;p&quot;, advisor())\n    @Bean\n    fun advisor() = DefaultPointcutAdvisor(pointcut(), advice())\n    @Bean\n    fun pointcut() = NameMatchMethodPointcut().apply {\n        this.setMappedName(&quot;sayH*&quot;)\n    }\n    @Bean\n    fun advice() = MethodInterceptor { it: MethodInvocation -&gt;\n        &quot;intercept!!! &quot; + (it.proceed() as String)\n    }\n    @Bean\n    fun hello(): Hello = Person()\n    @Bean\n    fun person(): Person = Person()\n}\n\n@SpringBootTest(&quot;spring.profiles.active=local&quot;, classes = [PostProcessorConfig::class])\nclass MemberServiceTest(\n    private val hello: Hello,\n    private val person: Person\n): AnnotationSpec() {\n\n    private val NAME: String = &quot;admin&quot;\n\n    init {\n        extension(SpringExtension)\n    }\n\n    @Test\n    fun beanPostProcessor() {\n        hello.sayGreeting(NAME) shouldBe &quot;안녕하세요! admin&quot;\n        hello.sayHello(NAME) shouldBe &quot;Hello admin&quot;\n        hello.sayHi(NAME) shouldBe &quot;Hi admin&quot;\n        hello.sayThankYou(NAME) shouldBe &quot;Thank you admin&quot;\n\n        person.greeting() shouldBe &quot;안녕하세요!&quot;\n        person.sayGreeting(NAME) shouldBe &quot;안녕하세요! admin&quot;\n        person.sayHello(NAME) shouldBe &quot;intercept!!! Hello admin&quot;\n        person.sayHi(NAME) shouldBe &quot;intercept!!! Hi admin&quot;\n        person.sayThankYou(NAME) shouldBe &quot;Thank you admin&quot;\n\n        hello.javaClass.toString() shouldBe &quot;class Person&quot;\n        person.javaClass.toString() shouldBe &quot;class Person$\\$SpringCGLIB$$0&quot;\n    }\n}</code>\n        </deckgo-highlight-code>\n<p>BeanPostProcessor를 통해 빈의 이름이 <code class=\"language-text\">p</code>로 시작하는 빈만 프록시를 감싸서 반환하도록 하였고, Pointcut을 통해 <code class=\"language-text\">sayH</code>로 시작하는 메서드만 부가기능이 실행되도록 지정하였다.<br>\n위의 테스트 코드를 보면 <code class=\"language-text\">hello</code>로 등록된 빈은 프록시가 적용되지 않았고, <code class=\"language-text\">person</code>으로 등록된 빈만 프록시가 적용되었고 <code class=\"language-text\">sayH</code>로 시작하는 메서드만 부가기능이 실행되는 것을 확인할 수 있다.</p>\n<deckgo-highlight-code  terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">[before] pattern = p, beanName = hello, bean = class Person\n[after] pattern = p, beanName = hello, bean = class Person\n[before] pattern = p, beanName = person, bean = class Person\n[after] pattern = p, beanName = person, bean = class Person\n[after - proxy] target = class Person, proxy = class Person$$SpringCGLIB$$0</code>\n        </deckgo-highlight-code>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 900px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 75.11111111111111%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsTAAALEwEAmpwYAAADgklEQVR42kWUW08bVxSF+SV97w/pP6jUh6p96UMfqt4rRVVBIUJqBVHUpkmUNKoCBQoUCIGWQoOpgTiAsQ2+GzMY29gY3y9jsD22Z+br9pi2Iy3tM3POWbPXXvucAdo1LLSqoPWRVAJEAy7Ojr0oYY/1njjxE4t6SZwGOY0cUiucQ1fFbJVlr6BdtXgG/iOkAea1FU+iPrweFz6Pm6D3iKDPS+w4RPL4WBAh7HZTzWdlfUfWGxK7Foep9Qj1OkYxQ+P5KtqqDW3NTmfuOUbiGUZtEqP0DIrjVHIPeVn+CVt1AnttgqXSY14GhmBpCNM120+qWxdCSZtanoZjj4LNTsn+ipZrF/V8kUJilnxsimZumXJhie30HKvRCdZPJtgqLBKROfYF4x/Q3Z9GVcv/SlYl8RaaWaetX8FVBT1fQsvkaAn0fFHWtEAXiQ2Zb0ppDJFpitzek3TTfjFMIXN2Q2hIlolLOMrB2gZsPoKejIMZidNojik8NhtbuRqvsxUc2TKbmQrZ8A74X8DsZ3Qc45RLWQYMo4ppO4NPduFOAL56iukdoxm5Tyv8I1rwLsXwE578ts7gYY5hT8bCF6483hX58cxHGDtPMRpFug2RXEqd0fnuEEIZyV2TLB2YsQB5n5MzxwYp5zadeAhzb4Pr8gX1XIJGKWXB0DXLZV1gGr0uaTBQy6XoPvCLvJS4dIWeTqKHvegRPy2/h25vHPLRTR1L2WoYWgWjLTXuVmldROn4XXDuxVSOrEREstRwN4n55QHcdhL+OsXEIKzcM/njB5gfMRn/GH6e32KmcIeZ1CgzF3d5fvkt9x9/yJvv/Mrbn69QSCXAsd43xTBV9FwRM5hGDZU4dRcJbMUJbicIbMc5d6vE4wq+tA3fuR133EY0vYliX8QVK/LumJNbUz7qjj/7hKYuLpvSDvROSv0GUhOu/ofZlpJI63Tke7cp0zX0gNuq4bLjjPdGHeT+WugTjhwE+PSVl8H9ILf2QwztHlJw3YOoOK78AsokHXH6kU/h+6jKg5MKDyN5vrk9y1tDDt54f42F/Ti6c6NPOB1RGNk7YmTHyfD2AaO7bvLRBbrKArXwAqqgGZ3n71OF+UiapXCS5dMMi5PrjA3P4f59E2JizOsbQkuuOKhexlAvlP7NIQe+3azTlFPTEHS0a+t26daz0gxZ9EbhZp/ERg6zlJZY5h9pvCe/RbS6HQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"beanLifeCycle\"\n        title=\"\"\n        src=\"/static/55450b89cb04be0a1dc878607f8d65e2/1cfc2/beanLifeCycle.png\"\n        srcset=\"/static/55450b89cb04be0a1dc878607f8d65e2/3684f/beanLifeCycle.png 225w,\n/static/55450b89cb04be0a1dc878607f8d65e2/fc2a6/beanLifeCycle.png 450w,\n/static/55450b89cb04be0a1dc878607f8d65e2/1cfc2/beanLifeCycle.png 900w,\n/static/55450b89cb04be0a1dc878607f8d65e2/d0143/beanLifeCycle.png 1025w\"\n        sizes=\"(max-width: 900px) 100vw, 900px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n<a href=\"https://bootcamptoprod.com/spring-bean-life-cycle-explained/\">출처</a></p>\n<p><strong>빈 후처리기는 빈의 생명주기에 대한 두 가지 단계의 훅을 제공한다.</strong><br>\n스프링은 이 빈 후처리기를 통해 프록시를 자동으로 생성하는 여러가지의 후처리기를 제공한다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 900px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/d9e7026e412a532600e73302b41bac23/f726e/autoProxyCreator.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 36.44444444444444%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAABUUlEQVR42j1R25aDIBDzL/bmBVEEW1QUQXt2a/f/fyobPO0+5DAmQ8iMWVlJ/EOks0ZeVBCyxewXtNogL8WpF2WNr0JAEg3r8XpFWDy8m6HqFi37spdZVTenmbEj1njD1Q6Y3AQfAuK2YZhS7altWIYJdqQ+ezi/wtE01abtkBU0y9ProjnPhH5iU9jZHM4LQioUr0eZ3KgOi/ecIGKJEX7lydpdLDLDVH2CeIKxbS3hlMZsLEZlcOE4Tvcn5zqNpVMICTSOWuPasYeaaRSyoRIQfL3h/mT1BOuWSRQbVKsxcA2RKdZ1x23/hhu5M6ZuCcsAFfdZnJDIurzEG5f8SeGjqAmO1nQY5gXjEjGuN9YBQvV4p2YmD+tWDM7jQmPN6UrezU9D/pQ7/9Bj2/EIEb9xx88asHPBBxMd5A5yB7m7f/KJo5a+E/+YHBomlQyR8Adx58995AQnBgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"autoProxyCreator\"\n        title=\"\"\n        src=\"/static/d9e7026e412a532600e73302b41bac23/1cfc2/autoProxyCreator.png\"\n        srcset=\"/static/d9e7026e412a532600e73302b41bac23/3684f/autoProxyCreator.png 225w,\n/static/d9e7026e412a532600e73302b41bac23/fc2a6/autoProxyCreator.png 450w,\n/static/d9e7026e412a532600e73302b41bac23/1cfc2/autoProxyCreator.png 900w,\n/static/d9e7026e412a532600e73302b41bac23/21482/autoProxyCreator.png 1350w,\n/static/d9e7026e412a532600e73302b41bac23/d61c2/autoProxyCreator.png 1800w,\n/static/d9e7026e412a532600e73302b41bac23/f726e/autoProxyCreator.png 2610w\"\n        sizes=\"(max-width: 900px) 100vw, 900px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>기본적으로 <code class=\"language-text\">DefaultAdvisorAutoProxyCreator</code>을 빈으로 등록하여 빈 후처리기 가공 시점에 프록시를 자동으로 생성하도록 할 수 있다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">@Bean\nfun defaultAdvisorAutoProxyCreator() = DefaultAdvisorAutoProxyCreator().apply {\n    this.isProxyTargetClass = true\n}</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">BeanFactoryAdvisorRetrievalHelper.findAdvisorBeans()</code>을 통해 <strong><code class=\"language-text\">Advisor.class</code> 타입을 구현하는 모든 빈을 찾고 빈으로 등록된 모든 구현 클래스(타겟)들을 순회하면서 대상선별을 통하여 프록시를 적용한다.</strong><br>\n스프링 AOP (<code class=\"language-text\">org.springframework.boot:spring-boot-starter-aop</code>) 의존성을 추가한다면 이것조차 작성하지 않아도 된다.<br>\n의존성을 추가하면 자동으로 <code class=\"language-text\">AnnotationAwareAspectJAutoProxyCreator</code> 빈 후처리기가 등록되어 빈으로 등록된 Advisor와 <code class=\"language-text\">@AspectJ</code>로 선언된 Advisor도 처리한다.</p>\n<p>이제는 Advisor만 빈으로 등록한다면 자동으로 모든 빈들을 순회하면서 Pointcut에 해당하는 대상이라면 Advice를 적용한 프록시를 등록한다.<br>\n프록시 생성 단계와 사용 단계의 Pointcut을 구분할 수 있어야 한다.</p>\n<ul>\n<li><strong>생성 단계: 프록시 적용 여부 판단</strong>\n<ul>\n<li>AutoProxyCreator는 Pointcut을 사용해서 <strong>해당 빈의 프록시를 생성할 필요가 있는지 없는지 체크한다.</strong></li>\n<li>클래스와 메서드 조건을 모두 비교한다. Pointcut 하나하나에 매칭하여 해당되는 것이 하나라도 있으면 프록시를 생성한다.</li>\n<li>10개의 메서드 중에 하나만 Pointcut 조건에 만족해도 프록시 적용 대상이 된다.</li>\n</ul>\n</li>\n<li><strong>사용 단계: 어드바이스 적용 여부 판단</strong>\n<ul>\n<li>프록시가 호출되었을 때 부가 기능인 <strong>Advice를 적용할지 판단한다.</strong></li>\n</ul>\n</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 786px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/7f59b67ba794d27885536bf20de85e70/321ea/postProcessor.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 37.77777777777778%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABr0lEQVR42i2SW2+bQBSE+f9/p1LVh1Z9qSJHfmhc3+rYrmPAhthmIcACe4GvxziLRmcXRrMz5xA0pqS1Fc0nWlfTeY22Jc4bbFHQZjdsrjB5jqsqvOBebVmO1VUl5uNDUBCoCm5VT9N5mtYSXxvCtCbJNMv1C4e/G6r1inzyhF7MeU8S3qKIYxhyyzJet1uiOKbUGlNXBMuTY3V2IqS53hR/dhee50e2seIY7Tj/O6Cmz4TfvpI9/SINIwpxk6YpoYju93t2IprIWUuK4PvklZ/TPVmNrEGex7rXWiu8bsBZtMT2jabrOmpxMnKGgVzakIpr3/dYcRnMw47ZseFSelrjmK7OTBcx8504iPYoId+UYiMurpnCqgPbyRfSxQ+6PCI+JZwksnVOLmwIkgJOqqdqe7llIFXtiFvZURQXnK7RQnyXSJ2xDF0hgwox6shgq884j1x3buB7Ue6NwHLf98MDTt7p9jG53oqQxO6Nkb18d17Oftx7acEI4dynHhjfkuVXVpsls8Vv3uIDxnc0phZhP5Kt9MzI79G3nQzlyHr2IpgR7nbiSkvvauHUI/c/rcZei1tWxqsAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"postProcessor\"\n        title=\"\"\n        src=\"/static/7f59b67ba794d27885536bf20de85e70/321ea/postProcessor.png\"\n        srcset=\"/static/7f59b67ba794d27885536bf20de85e70/3684f/postProcessor.png 225w,\n/static/7f59b67ba794d27885536bf20de85e70/fc2a6/postProcessor.png 450w,\n/static/7f59b67ba794d27885536bf20de85e70/321ea/postProcessor.png 786w\"\n        sizes=\"(max-width: 786px) 100vw, 786px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ol>\n<li>등록되어 있는 빈 후처리기가 있다면 스프링 컨테이너는 빈 생성 후 빈 후처리기에게 빈을 전달한다.</li>\n<li>(일반적인) 빈 후처리기는 빈으로 등록된 모든 Advisor내의 Pointcut을 이용해 빈으로 등록된 모든 빈들을 <strong>프록시 적용 대상인지 확인한다.</strong></li>\n<li>적용 대상이면 (내장된) 프록시 생성기에게 <strong>현재 빈에 대한 프록시를 만들고, 만들어진 프록시에 어드바이저를 연결한다.</strong></li>\n<li>빈 후처리기는 스프링 컨테이너에게 전달받은 빈이 아니라 <strong>프록시를 컨테이너에게 돌려준다.</strong></li>\n</ol>\n<h1 id=\"스프링-aop-맛보기\" style=\"position:relative;\">스프링 AOP 맛보기<a href=\"#%EC%8A%A4%ED%94%84%EB%A7%81-aop-%EB%A7%9B%EB%B3%B4%EA%B8%B0\" aria-label=\"스프링 aop 맛보기 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>프록시를 생성할 때 직접 빈으로 등록해주지 않고 Advisor만 등록하여도 빈 후처리기가 프록시를 생성해준다는 것을 배웠다.<br>\n하지만 Pointcut, Advice, Advisor를 재활용하기 위해서는 각각 빈으로 직접 등록해줘야 하다는 단점이 있다.</p>\n<p>이것도 Spring의 <code class=\"language-text\">@Aspect</code>가 해결해준다. 간단한 예제를 보자.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">@Aspect\n@Component\nclass MyAspect {\n\n    /**\n     * execution: 메소드 실행 조인 포인트에 대한 매칭을 지정합니다.\n     * *: 메소드의 반환 타입을 나타내며, 여기서는 모든 반환 타입을 의미합니다.\n     * *..*.*: 첫 번째 *는 모든 패키지를 의미하며, ..는 패키지의 모든 서브 패키지를 포함한다는 의미입니다. 두 번째 *는 모든 클래스를 의미합니다.\n     * sayH*: 메소드 이름이 sayH로 시작하는 것을 의미합니다. *는 그 뒤에 오는 어떤 문자열과도 매칭될 수 있음을 나타냅니다.\n     * (..): 메소드의 파라미터를 나타내며, 여기서는 어떤 타입과 어떤 개수의 파라미터도 허용한다는 의미입니다.\n     */\n    @Around(&quot;execution(* *..*.*sayH*(..))&quot;)\n    fun execute(joinPoint: ProceedingJoinPoint): Any {\n        println(&quot;MyAspect!!!&quot;)\n        return joinPoint.proceed()\n    }\n}\n</code>\n        </deckgo-highlight-code>\n<ul>\n<li><strong>JoinPoint</strong>\n<ul>\n<li>어드바이스가 적용될 수 있는 위치를 말한다</li>\n<li>스프링의 프록시 AOP에서 조인 포인트는 메소드의 실행 단계 뿐이다</li>\n<li>타깃 오브젝트가 구현한 인터페이스의 모든 메소드가 조인 포인트가 된다</li>\n</ul>\n</li>\n<li><strong>Aspect</strong>\n<ul>\n<li>한 개 또는 그 이상의 포인트컷과 어드바이스의 조합으로 만들어지며 보통 싱글톤 형태의 오브젝트로 존재한다.</li>\n<li>스프링의 Advisor는 아주 단순한 Aspect라고 볼 수 있다</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"정리\" style=\"position:relative;\">정리<a href=\"#%EC%A0%95%EB%A6%AC\" aria-label=\"정리 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<ol>\n<li>프록시를 구현하기 위해 사용되는 <strong>Reflection</strong></li>\n<li>프록시의 개념</li>\n<li>프록시를 구현하는 두 가지의 방법 (<strong>JDK Dynamic Proxy</strong> 와 <strong>CGLIB</strong>)</li>\n<li>부가기능과 메소드 선별 기능을 스프링이 추상화한 <strong>ProxyFactory</strong> 와 <strong>ProxyFactoryBean</strong></li>\n<li>빈 후처리기를 통해 프록시를 편리하게 등록하는 방법</li>\n<li><code class=\"language-text\">@Aspect</code> (AspectJ)를 사용하여 프록시를 등록하는 방법</li>\n</ol>\n<p>위와 같은 내용들을 순서대로 알아보았다. 많은 내용이고 더 깊게 조사할 수 있는 부분들도 존재하지만 자주 사용하는 <code class=\"language-text\">@Transactional</code>과 같은 AOP 기능에 대해 더 가까워질 수 있었다.<br>\n이런 프록시에 대한 이해가 없다면 스프링이 제공하는 많은 편리한 기능들을 이해할 수 없고 그저 마법같은 일이라고만 생각하고 넘어갈 것이다.</p>\n<ul>\n<li>프록시가 무엇인지?</li>\n<li>프록시를 구현하는 방법에는 무엇이 있는지?</li>\n<li>스프링은 프록시를 어떻게 생성하는지?</li>\n<li>스프링은 부가기능의 타겟에 대한 의존성을 어떻게 끊었는지?</li>\n<li>스프링이 프록시를 만들기 위해 제공하는 두 가지의 방법은 무엇인지?</li>\n</ul>\n<p>이 글에서는 스프링의 AOP와 AspectJ는 더 자세하게 설명하지 않았다. 준비가 된다면 다른 글로 정리할 예정이다.</p>","frontmatter":{"title":"빈 후처리기를 이용한 프록시 생성에 대해","date":"March 17, 2024","description":null,"tags":["spring","reflection","proxy"]},"tableOfContents":"<ul>\n<li>\n<p><a href=\"#1%EB%8B%A8%EA%B3%84-java-reflection\">1단계: Java Reflection</a></p>\n</li>\n<li>\n<p><a href=\"#2%EB%8B%A8%EA%B3%84-proxy%EB%9E%80\">2단계: Proxy란?</a></p>\n</li>\n<li>\n<p><a href=\"#3%EB%8B%A8%EA%B3%84-proxy-%EC%83%9D%EC%84%B1-%EB%B0%A9%EB%B2%95\">3단계: Proxy 생성 방법</a></p>\n<ul>\n<li><a href=\"#java-dynamic-proxy\">Java Dynamic Proxy</a></li>\n<li><a href=\"#cglibcode-generation-library\">CGLIB(Code Generation Library)</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#4%EB%8B%A8%EA%B3%84-%ED%94%84%EB%A1%9D%EC%8B%9C%EC%9D%98-%EA%B5%AC%ED%98%84%EC%B2%B4-%EC%83%9D%EC%84%B1-%EB%B0%A9%EB%B2%95%EC%9D%84-%EC%84%A0%ED%83%9D%ED%95%98%EB%8A%94-proxyfactory\">4단계: 프록시의 구현체 생성 방법을 선택하는 ProxyFactory</a></p>\n</li>\n<li>\n<p><a href=\"#5%EB%8B%A8%EA%B3%84-factorybean\">5단계: FactoryBean</a></p>\n</li>\n<li>\n<p><a href=\"#6%EB%8B%A8%EA%B3%84-%EB%B6%80%EA%B0%80%EA%B8%B0%EB%8A%A5%EC%9D%84-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94-%EC%B0%A8%EC%9D%B4%EC%A0%90\">6단계: 부가기능을 구현하는 차이점</a></p>\n</li>\n<li>\n<p><a href=\"#7%EB%8B%A8%EA%B3%84-proxyfactorybean\">7단계: ProxyFactoryBean</a></p>\n</li>\n<li>\n<p><a href=\"#8%EB%8B%A8%EA%B3%84-%EB%B9%88-%ED%9B%84%EC%B2%98%EB%A6%AC%EA%B8%B0%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9E%90%EB%8F%99-%ED%94%84%EB%A1%9D%EC%8B%9C-%EC%83%9D%EC%84%B1%EA%B8%B0\">8단계: 빈 후처리기를 이용한 자동 프록시 생성기</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%8A%A4%ED%94%84%EB%A7%81-aop-%EB%A7%9B%EB%B3%B4%EA%B8%B0\">스프링 AOP 맛보기</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%A0%95%EB%A6%AC\">정리</a></p>\n</li>\n</ul>"},"previous":{"fields":{"slug":"/2024y/transaction/"},"frontmatter":{"title":"트랜잭션과 잠금"}},"next":{"fields":{"slug":"/2024y/testcontainers/"},"frontmatter":{"title":"테스트 불모지에 Testcontainers 심기"}}},"pageContext":{"id":"83e68652-9a78-5344-a893-30311c9782dd","previousPostId":"099bd161-b615-5200-ab96-c2a0d6a8dfa3","nextPostId":"ea381821-0e81-57aa-a137-69da08df90d1"}},"staticQueryHashes":["230163734","3589320610"],"slicesMap":{}}