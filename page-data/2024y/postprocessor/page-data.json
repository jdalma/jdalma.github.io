{"componentChunkName":"component---src-templates-blog-post-js","path":"/2024y/postprocessor/","result":{"data":{"site":{"siteMetadata":{"title":"코딩 주머니"}},"markdownRemark":{"id":"83e68652-9a78-5344-a893-30311c9782dd","excerpt":"스프링의 AOP 프록시를 생성하는 가장 기본적인 방법을 이해하기 위해서는 사전지식이 조금 필요하다. Reflection Java Dynamic Proxy CGLIB ProxyFactory FactoryBean ProxyFactoryBean…","html":"<p>스프링의 AOP 프록시를 생성하는 가장 기본적인 방법을 이해하기 위해서는 사전지식이 조금 필요하다.</p>\n<ol>\n<li>Reflection</li>\n<li>Java Dynamic Proxy</li>\n<li>CGLIB</li>\n<li>ProxyFactory</li>\n<li>FactoryBean</li>\n<li>ProxyFactoryBean</li>\n</ol>\n<p><strong>스프링을 더 깊게 이해하기 위해서는 필수적인 선수 지식이라고 생각한다.</strong><br>\n이 글에서는 스프링 AOP를 사용하는 법, 포인트 컷, 어드바이스를 자세하게 설명하진 않는다.<br>\n스프링의 빈 후처리기를 통해 프록시가 어떻게 자동으로 생성되는지를 중점으로 다룬다. 단계별로 알아보자.</p>\n<h1 id=\"1단계-java-reflection\" style=\"position:relative;\">1단계: Java Reflection<a href=\"#1%EB%8B%A8%EA%B3%84-java-reflection\" aria-label=\"1단계 java reflection permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>자바의 리플렉션(Reflection)은 런타임 시에 클래스의 속성, 메소드, 생성자 등의 메타데이터를 조회하거나 수정할 수 있는 강력한 기능이다.<br>\n또한, <strong>리플렉션을 사용하여 런타임 시에 동적으로 객체를 생성하고, 가시성에 관계없이 메소드를 호출하거나, 필드에 접근할 수 있다.</strong></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 900px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 50.22222222222222%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAECBAX/xAAUAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHWcbIIYv8A/8QAGhAAAgIDAAAAAAAAAAAAAAAAAQMQETEyM//aAAgBAQABBQJmizaxg9o//8QAFhEAAwAAAAAAAAAAAAAAAAAAEBFB/9oACAEDAQE/Aax//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAGhAAAQUBAAAAAAAAAAAAAAAAEAABAhEhQf/aAAgBAQAGPwKWquhj/8QAGxABAAICAwAAAAAAAAAAAAAAAQARECExQYH/2gAIAQEAAT8hd0p8lQGgdkCbNs1M4rP/2gAMAwEAAgADAAAAEI8v/8QAFhEBAQEAAAAAAAAAAAAAAAAAARAR/9oACAEDAQE/EE2H/8QAFhEBAQEAAAAAAAAAAAAAAAAAAQAR/9oACAECAQE/EAC2/8QAHBABAQACAgMAAAAAAAAAAAAAAREAITGBEEFR/9oACAEBAAE/EEGwahE3995T0cV9PcuAAQ5Ql6wACKkOFbcNaPH/2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"javalang\"\n        title=\"\"\n        src=\"/static/ba3e3f3cd9ce3e367559bba7dca13048/8e1fc/javalang.jpg\"\n        srcset=\"/static/ba3e3f3cd9ce3e367559bba7dca13048/863e1/javalang.jpg 225w,\n/static/ba3e3f3cd9ce3e367559bba7dca13048/20e5d/javalang.jpg 450w,\n/static/ba3e3f3cd9ce3e367559bba7dca13048/8e1fc/javalang.jpg 900w,\n/static/ba3e3f3cd9ce3e367559bba7dca13048/a2510/javalang.jpg 1000w\"\n        sizes=\"(max-width: 900px) 100vw, 900px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n<a href=\"https://www.geeksforgeeks.org/reflection-in-java/\">출처 geeksforgeeks</a></p>\n<ul>\n<li>필드(목록) 가져오기</li>\n<li>메소드(목록) 가져오기</li>\n<li>상위 클래스 가져오기</li>\n<li>인터페이스(목록) 가져오기</li>\n<li>어노테이션 가져오기</li>\n<li>생성자 가져오기</li>\n<li>...</li>\n</ul>\n<p>이 리플렉션을 사용하는 것은 <strong>메타 프로그래밍</strong> 이라고 하며 위와 같은 행위를 할 수 있다.<br>\n자바의 모든 클래스는 그 클래스 자체의 구성 정보를 담은 <code class=\"language-text\">Class 타입</code>의 오브젝트를 하나씩 갖고 있다.<br>\n<code class=\"language-text\">Class</code> 오브젝트를 이용하면 <strong>클래스 코드에 대한 메타 정보</strong> 를 가져오거나 <strong>객체를 조작</strong> 할 수 있다.<br>\n테스트 코드로 확인해보자.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">data class Address(\n    private val state: String,\n    private val city: String\n)\n\ndata class Person(\n    private val name: String,\n    var age: Int,\n    private val address: Address\n) {\n    constructor(name: String, age: Int): this(name, age, Address(&quot;empty&quot;, &quot;empty&quot;))\n\n    @Throws(IllegalArgumentException::class)\n    constructor(age: Int): this(&quot;Admin&quot;, age, Address(&quot;Admin&quot;, &quot;Admin&quot;))\n\n    fun greeting() = &quot;안녕하세요.&quot;\n}\n\ndescribe(&quot;Person 클래스&quot;) {\n    val personClass: Class&lt;Person&gt; = Person::class.java\n\n    it(&quot;Constructor를 통해 Person 만들기&quot;) {\n        val constructors: Array&lt;Constructor&lt;Person&gt;&gt;  = personClass.constructors as Array&lt;Constructor&lt;Person&gt;&gt;\n        constructors[0].toString() shouldBe \n            &quot;public _22_Reflection.ReflectionTest\\$1\\$Person(java.lang.String,int)&quot;\n        constructors[1].toString() shouldBe \n            &quot;public _22_Reflection.ReflectionTest\\$1\\$Person(int) throws java.lang.IllegalArgumentException&quot;\n        \n        val nameAndAgeConstructor = constructors[0]\n        val ageConstructor = constructors[1]\n\n        nameAndAgeConstructor.newInstance(&quot;Reflection&quot;, 10) shouldBe Person(&quot;Reflection&quot;, 10)\n        ageConstructor.newInstance(10) shouldBe Person(10)\n    }\n\n    it(&quot;Field로 객체 내부 멤버변수 조회하기&quot;) {\n        val fields: Array&lt;Field&gt; = personClass.declaredFields\n        fields[0].toString() shouldBe \n            &quot;private final java.lang.String _22_Reflection.ReflectionTest$1\\$Person.name&quot;\n        fields[1].toString() shouldBe \n            &quot;private int _22_Reflection.ReflectionTest$1\\$Person.age&quot;\n        fields[2].toString() shouldBe \n            &quot;private final _22_Reflection.ReflectionTest$1\\$Address _22_Reflection.ReflectionTest$1\\$Person.address&quot;\n\n        val person = Person(100)\n\n        fields.forEach { it.trySetAccessible() }\n\n        val nameField = fields[0]\n        val ageField = fields[1]\n        val addressField = fields[2]\n\n        nameField.get(person) shouldBe &quot;Admin&quot;\n        ageField.get(person) shouldBe 100\n        addressField.get(person) shouldBe Address(&quot;Admin&quot;, &quot;Admin&quot;)\n    }\n\n    it(&quot;Method 정보로 객체 실행하기&quot;) {\n        val methods: Array&lt;Method&gt; = personClass.methods\n\n        val getAgeMethod = methods.find { it.name == &quot;getAge&quot; }!!\n        val setAgeMethod = methods.find { it.name == &quot;setAge&quot; }!!\n        val greetingMethod = methods.find { it.name == &quot;greeting&quot; }!!\n\n        val person = Person(100)\n\n        person.age shouldBe 100\n        getAgeMethod.invoke(person) shouldBe 100\n\n        setAgeMethod.invoke(person, 50)\n\n        person.age shouldBe 50\n        getAgeMethod.invoke(person) shouldBe 50\n\n        greetingMethod.invoke(person) shouldBe &quot;안녕하세요.&quot;\n    }\n}</code>\n        </deckgo-highlight-code>\n<p>위와 같이 <code class=\"language-text\">Class</code> 정보를 이용하여 실제 인스턴스를 조작하거나 생성할 수 있다. (더 자세한 예제는 <a href=\"https://github.com/jdalma/kotlin-playground/blob/main/src/test/kotlin/_22_Reflection/ReflectionTest.kt\">여기</a>를 확인하자.)</p>\n<p>리플렉션을 간단하게 확인해보았는데 강력한 기능이라는 것을 느낄 수 있다.<br>\n이 강력한 기능을 통해 자바에서는 <strong><a href=\"https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/proxy.html\">Dynamic Proxy Class API</a></strong> 를 제공한다.<br>\n다이나믹 프록시에 대해 확인하기 전에 먼저 프록시에 대해 알아보자.</p>\n<h1 id=\"2단계-proxy란\" style=\"position:relative;\">2단계: Proxy란?<a href=\"#2%EB%8B%A8%EA%B3%84-proxy%EB%9E%80\" aria-label=\"2단계 proxy란 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>단순히 확장성을 고려해서 한 가지 기능을 분리한다면 아래와 같이 전형적인 전략 패턴(<code class=\"language-text\">condition: (Member) -> Boolean</code>)을 사용할 수 있을 것이다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">fun register(member: Member, condition: (Member) -&gt; Boolean) {\n    if(condition(member)) {\n        // business logic\n    }\n}</code>\n        </deckgo-highlight-code>\n<p>하지만 여러 곳에서 동일한 기능이 필요하다면 아주 번거로워질 것이다. 대표적으로 옛날 방식의 커넥션 관리가 있다.</p>\n<deckgo-highlight-code language=\"java\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">public void accountTransfer(String fromId, String toId, int money) throws SQLException {\n    Connection con = dataSource.getConnection();\n    try {\n        con.setAutoCommit(false);\n        bizLogic(con, fromId, toId, money); // 핵심 기능\n        con.commit();\n    } catch (Exception e) {\n        con.rollback();\n        throw new IllegalStateException(e);\n    } finally {\n        release(con);\n    }\n}</code>\n        </deckgo-highlight-code>\n<p>핵심 기능인 <code class=\"language-text\">bizLogic()</code>을 실행시키기 위한 부가 기능이 많이 존재한다.<br>\n이 문제를 <strong>위임</strong> 을 통해 해결하면 어떨까?</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 574px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/8218e1b1fc9598014689df3fa9c112af/86389/proxy.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 76.88888888888889%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsTAAALEwEAmpwYAAACTElEQVR42o2Ue2/aMBTF+f4fYf9smjRNk6ZO6ya1GqylokAoCRCgaEB5bQyVlkdGbMd2Es6u3U6l60O90pHj6OaXe31PksEjsd1u7drtdpHP55HNZjGdTu39OI4fVZIkds3giTAJURRBa20TDczcM/uHUpSjbf6TQAMxySYWiwW6vQHW68DuU4LfNnEvpJTPV/gPuF4t0W2d4HLiIhUTbOVP0i9oNoLeDK22MYdS+mXAhI+wZRWAe9DLEsY/9jEhJRsHEC4QOojXHmQkkEnT1J7PrkwYmFLKXqugSUB6MPKhFg78w7fwvr4B7+WhBgXIUQHJqoxIhMgEQYAwDO9N9/8KxdLH/OIQV+Msrr0DxNUzKBIvFcGKJYSnBfDBEaRiyCyXSzDGrMz1arWiw19jMBjQfoHL+TV6/gHalfdwjl+j/OEV0paPuFlHYtZWA5F7Btb7fgMUQthKjOf6/T6GwyFGoxHa7Tbq9TouLoaolfYw9D9h3PmC8ckelOdhkj3E7CiHq8IJpFu9A85mM2uLzWZjfWRGb2ReZCrWcYpgVkX4Ow9JA9k0c1SRC+f9O/h7H9HZ/wxdcxH2cjdA06Jp97kp67BDk6ShiBp4h8AETNs+kmaDWm9AVCtg/dsKX2IbHZwDfyoWys+PoWoeonoVsu5CNsguu2e4a5WHwDvbWCDzLJAXHfCyA1GuWLEiTbtPLcvwZRXGYko+K1KFVcTzU7B2jsBHtzoG63wjY7eoQvX8t2yGdPMXSSD5AlE4g+KXZPg5lNzVFeVpcCHwF+EObsU94YOyAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"proxy\"\n        title=\"\"\n        src=\"/static/8218e1b1fc9598014689df3fa9c112af/86389/proxy.png\"\n        srcset=\"/static/8218e1b1fc9598014689df3fa9c112af/3684f/proxy.png 225w,\n/static/8218e1b1fc9598014689df3fa9c112af/fc2a6/proxy.png 450w,\n/static/8218e1b1fc9598014689df3fa9c112af/86389/proxy.png 574w\"\n        sizes=\"(max-width: 574px) 100vw, 574px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">interface UserService {\n    fun accountTransfer(fromId: String, toId: String, money: Int)\n}\n\nclass UserServiceProxy (\n    private val userServiceTarget: UserService\n): UserService {\n    override fun accountTransfer(fromId: String, toId: String, money: Int) {\n        // 부가 기능\n        userServiceTarget.accountTransfer(...)\n        // 부가 기능\n    }\n}\n\nclass UserServiceTarget: UserService {\n    override fun accountTransfer(fromId: String, toId: String, money: Int) {\n        // 핵심 기능\n    }\n}</code>\n        </deckgo-highlight-code>\n<p>위임을 통해 부가 기능은 마치 <strong>자신이 핵심 기능 클래스인 것처럼 꾸며서, 클라이언트가 자신을 거쳐서 핵심 기능을 사용하도록 만드는 것이다.</strong><br>\n클라이언트는 인터페이스를 통해서만 핵심 기능을 사용하게 하여, 부가 기능은 자신도 같은 인터페이스를 구현한 뒤에 자신이 그 사이에 끼어들어 타깃을 직접 제어하는 것이다.</p>\n<p>이렇게 마치 <code class=\"language-text\">자신이 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 것</code>을 대리자,대리인 과 같은 역할을 한다고 해서 <strong>프록시</strong> 라고 부르며, 프록시를 통해 최종적으로 요청을 위임받아 처리하는 실제 오브젝트를 <strong>타깃</strong> 이라고 부른다.</p>\n<ol>\n<li>타깃과 동일한 인터페이스를 구현하고</li>\n<li>클라이언트와 타깃 사이에 존재하면서</li>\n<li>기능의 부가 또는 접근 제어를 담당하면 모두 <strong>프록시</strong> 라고 볼 수 있다.</li>\n</ol>\n<p>이 <strong>프록시의 사용 목적에 따라 디자인 패턴에서는 다른 패턴으로 구분된다.</strong></p>\n<h3>데코레이터 패턴</h3>\n<p><strong>타깃에 부가적인 기능을 런타임에 동적으로 부여하기 위해 프록시를 사용하는 패턴을 말한다.</strong><br>\n대표적으로 <a href=\"https://github.com/jdalma/footprints/blob/main/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/%EA%B5%AC%EC%A1%B0_%EA%B4%80%EB%A0%A8.md#%EB%8D%B0%EC%BD%94%EB%A0%88%EC%9D%B4%ED%84%B0-%ED%8C%A8%ED%84%B4\">자바 IO패키지의 InputStream 구현 클래스</a>이다.</p>\n<p>프록시로서 동작하는 각 데코레이터는 위임하는 대상에도 인터페이스로 접근하기 때문에 자신이 최종 타깃으로 위임하는지, 아니면 다음 단계의 데코레이터 프록시로 위임하는지 알지 못한다.<br>\n그래서 데코레이터의 다음 위임 대상은 인터페이스로 선언하고 생성자나 수정자 메소드를 통해 위임 대상을 외부에서 런타임 시에 주입받을 수 있도록 만들어야 한다.<br>\n프록시가 꼭 한 개로 제한되지 않으며, 여러 개의 프록시를 <strong>순서를 정해서 단계적으로 위임하는 구조로 만들어야 한다.</strong><br>\n데코레이터는 스스로 존재할 수 없고 항상 꾸며줄 대상이 있어야 하며 <strong>타겟에 대한 기능을 확장시키는 개념이다.</strong></p>\n<p>위의 <code class=\"language-text\">UserServiceTarget</code>에 부가 기능을 제공하는 <code class=\"language-text\">UserServiceProxy</code>를 추가한 것도 데코레이터 패턴을 적용했다고 볼 수 있다.</p>\n<h3>프록시 패턴</h3>\n<p><strong>클라이언트와 타깃 사이에서 대리 역할을 맡는 오브젝트를 두는 방법을 총칭하는 것이다.</strong><br>\n디자인 패턴에서 말하는 프록시 패턴은 <strong>프록시를 사용하는 방법 중에 타깃에 대한 접근 방법을 제어하려는 목적을 가진 경우</strong> 를 가리킨다.<br>\n즉, 프록시 패턴의 프록시는 타깃의 기능을 확장하거나 추가하지 않고 클라이언트가 타깃에 대한 접근 권한을 제어하거나 접근하는 방식을 변경해주는 것이다.</p>\n<p>위에서 봤던 <strong>실제 타깃 오브젝트를 만드는 대신 프록시를 넘겨주는 것, 그리고 프록시의 메소드를 통해 타깃을 사용하려고 시도하면, 그떄 프록시가 타깃 오브젝트를 (생성하고) 요청을 위임해주는 식이다.</strong><br>\n대표적으로 <code class=\"language-text\">Collections.unmodifiableCollection()</code>을 통해 만들어지는 객체가 전형적인 접근 권한 제어용 프록시라고 볼 수 있다.</p>\n<deckgo-highlight-code language=\"java\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">public static &lt;T&gt; Collection&lt;T&gt; unmodifiableCollection(Collection&lt;? extends T&gt; c) {\n    if (c.getClass() == UnmodifiableCollection.class) {\n        return (Collection&lt;T&gt;) c;\n    }\n    return new UnmodifiableCollection&lt;&gt;(c);\n}</code>\n        </deckgo-highlight-code>\n<p>이렇게 프록시 패턴은 타깃의 기능 자체에는 관여하지 않으면서 접근하는 방법을 제어해주는 프록시를 <code class=\"language-text\">이용</code>하는 것이다.</p>\n<blockquote>\n<p>위임을 통한 프록시를 생성하여 부가 기능과 핵심 기능을 분리했지만 프록시를 만드는 일은 번거롭고 타깃 인터페이스에 의존적이여서 타깃이 여러 개라면 인터페이스 API가 수정될 수 밖에 없을 것이다.</p>\n</blockquote>\n<h1 id=\"3단계-proxy-생성-방법\" style=\"position:relative;\">3단계: Proxy 생성 방법<a href=\"#3%EB%8B%A8%EA%B3%84-proxy-%EC%83%9D%EC%84%B1-%EB%B0%A9%EB%B2%95\" aria-label=\"3단계 proxy 생성 방법 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<h2 id=\"java-dynamic-proxy\" style=\"position:relative;\">Java Dynamic Proxy<a href=\"#java-dynamic-proxy\" aria-label=\"java dynamic proxy permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>일일이 프록시 클래스를 정의하는 것은 한계가 있다는 것을 알 수 있다.<br>\n이 한계를 <strong>프록시처럼 동작하는 오브젝트를 동적으로 생성하는 JDK의 다이내믹 프록시</strong> 와 <strong>리플렉션</strong> 으로 해결할 수 있다.</p>\n<p>이 프록시는 두 가지 기능으로 구성된다.</p>\n<ol>\n<li><strong>타깃과 같은 메소드를 구현하고 있다가 메소드가 호출되면 타깃 오브젝트로 위임한다.</strong></li>\n<li><strong>지정된 요청에 대해서는 부가 기능을 수행한다.</strong></li>\n</ol>\n<p>다이나믹 프록시를 이용해 프록시를 만들어보자.</p>\n<blockquote>\n<p><code class=\"language-text\">Hello</code> 인터페이스를 구현한 프록시를 만들어보자.<br>\n프록시에는 데코레이터 패턴을 적용해서 타깃인 <code class=\"language-text\">HelloTarget</code>에 부가 기능을 추가해보자.<br>\n리턴하는 문자를 모두 대문자로 바꾸는 부가 기능을 만들어보자.</p>\n</blockquote>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">interface Hello {\n    fun sayHello(name: String): String\n    fun sayHi(name: String): String\n    fun sayThankYou(name: String): String\n}\ninterface Goodbye {\n    fun sayGoodbye(name: String): String\n    fun sayThankYou(name: String): String\n}\nclass HelloTarget: Hello {\n    override fun sayHello(name: String): String = &quot;Hello $name&quot;\n    override fun sayHi(name: String): String = &quot;Hi $name&quot;\n    override fun sayThankYou(name: String): String = &quot;Hello Thank You $name&quot;\n}\n\nclass GoodbyeTarget: Goodbye {\n    override fun sayGoodbye(name: String): String = &quot;Goodbye $name&quot;\n    override fun sayThankYou(name: String): String = &quot;Goodbye Thank You $name&quot;\n}\n\nclass UppercaseHandler(\n    helloTarget: Hello,\n    goodbyeTarget: Goodbye\n): InvocationHandler {\n\n    private val lookupTarget = mapOf(\n        Hello::class.java to helloTarget,\n        Goodbye::class.java to goodbyeTarget,\n    )\n    override fun invoke(proxy: Any, method: Method, args: Array&lt;out Any&gt;): Any {\n        val result: String = method.invoke(lookupTarget[method.declaringClass], *args) as String\n        return result.uppercase()\n    }\n}\n\n&quot;Hello 동적 프록시 테스트하기&quot; {\n    val proxy = Proxy.newProxyInstance(\n        javaClass.classLoader,\n        arrayOf(Hello::class.java, Goodbye::class.java),\n        UppercaseHandler(HelloTarget(), GoodbyeTarget())\n    )\n\n    (proxy is HelloTarget) shouldBe false\n    (proxy is GoodbyeTarget) shouldBe false\n    (proxy is Hello) shouldBe true\n    (proxy is Goodbye) shouldBe true\n\n    val hello = proxy as Hello\n    hello.sayHello(&quot;admin&quot;) shouldBe &quot;HELLO ADMIN&quot;\n    hello.sayHi(&quot;admin&quot;) shouldBe &quot;HI ADMIN&quot;\n    hello.sayThankYou(&quot;admin&quot;) shouldBe &quot;HELLO THANK YOU ADMIN&quot;\n\n    val goodbye = proxy as Goodbye\n    goodbye.sayGoodbye(&quot;admin&quot;) shouldBe &quot;GOODBYE ADMIN&quot;\n    goodbye.sayThankYou(&quot;admin&quot;) shouldBe &quot;HELLO THANK YOU ADMIN&quot;\n}</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">Proxy.newProxyInstance()</code>로 중요한 두 가지의 값을 전달해야 한다.</p>\n<ol>\n<li><code class=\"language-text\">InvocationHandler</code>를 구현한 부가 기능을 가진 <strong>프록시</strong></li>\n<li><code class=\"language-text\">Hello</code>와 <code class=\"language-text\">Goodbye</code>와 같은 <strong>인터페이스</strong></li>\n</ol>\n<p>런타임 중에 주어진 인터페이스들을 구현하는 프록시 인스턴스를 생성하며, 프록시 인스턴스는 하나의 <code class=\"language-text\">InvocationHandler</code> 인스턴스와 연결된다.<br>\n프록시 인스턴스에 대한 모든 메소드 호출은 <code class=\"language-text\">InvocationHandler</code>의 <code class=\"language-text\">invoke()</code> 메소드로 호출되며, 여기서 타갯 메소드를 호출하기 전에 <strong>추가 기능을 가로채거나 추가할 수 있다.</strong></p>\n<blockquote>\n<p>리플렉션 메소드인 invoke()를 이용해 타깃 오브젝트의 메소드를 호출할 때는 타깃 오브젝트에서 발생하는 예외가 <code class=\"language-text\">InvocationTargetException</code>으로 한 번 포장돼서 전달된다.<br>\n따라서 InvocationTargetException으로 받은 후 <code class=\"language-text\">getTargetException()</code> 메소드로 <strong>중첩되어 있는 예외를 가져와야 한다.</strong></p>\n</blockquote>\n<p><code class=\"language-text\">Method</code>를 이용한 타깃의 오브젝트의 메소드 호출을 구분하거나 <code class=\"language-text\">args</code> 인자들의 정보를 확인하거나 조작할 수 있다.<br>\n리플렉션의 매우 유연하고 막강한 기능을 사용하여 동적 프록시를 조금 더 편하게 만들어보았다.<br>\n하지만 인터페이스 기반이라는 단점이 있다. 이 단점을 해결하는 CGLIB에 대해 알아보자.</p>\n<h2 id=\"cglibcode-generation-library\" style=\"position:relative;\">CGLIB(Code Generation Library)<a href=\"#cglibcode-generation-library\" aria-label=\"cglibcode generation library permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>자바 클래스의 바이트코드를 런타임에 조작하여 새로운 클래스나 객체를 동적으로 생성하고 수정할 수 있는 강력한 라이브러리다.<br>\n이 라이브러리는 스프링 AOP 프레임워크, ORM 툴, 그리고 다양한 테스팅 라이브러리 등에서 널리 사용되고 있다.<br>\n<strong>클래스 기반으로 타겟 객체의 클래스를 상속 받아 새로운 서브 클래스로 프록시를 생성하는 방식이다.</strong><br>\n인터페이스가 없는 클래스에도 적용할 수 있기에 자바의 동적 프록시의 단점을 해결한다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">open class Person: Hello, Goodbye {\n    open fun greeting() = &quot;안녕하세요!&quot;\n    override fun sayHello(name: String): String = &quot;Hello $name&quot;\n    override fun sayHi(name: String): String = &quot;Hi $name&quot;\n    override fun sayThankYou(name: String): String = &quot;Thank you $name&quot;\n    override fun sayGoodbye(name: String): String = &quot;Goodbye $name&quot;\n}\n\nclass MyMethodInterceptor: MethodInterceptor {\n    override fun intercept(proxy: Any, method: Method, args: Array&lt;out Any&gt;, methodProxy: MethodProxy): Any =\n        // 프록시의 슈퍼클래스의 타겟 메서드를 호출한다.\n        &quot;(Intercepted) &quot; + methodProxy.invokeSuper(proxy, args)\n}\n\n&quot;Person 클래스 Cglib 테스트&quot; {\n    val proxy = Enhancer.create(\n        Person::class.java,\n        MyMethodInterceptor()\n    )\n\n    (proxy is Hello) shouldBe true\n    (proxy is Goodbye) shouldBe true\n    (proxy is Person) shouldBe true\n\n    val person = proxy as Person\n    person.greeting() shouldBe &quot;(Intercepted) 안녕하세요!&quot;\n    person.sayHello(&quot;admin&quot;) shouldBe &quot;(Intercepted) Hello admin&quot;\n    person.sayHi(&quot;admin&quot;) shouldBe &quot;(Intercepted) Hi admin&quot;\n    person.sayThankYou(&quot;admin&quot;) shouldBe &quot;(Intercepted) Thank you admin&quot;\n    person.sayGoodbye(&quot;admin&quot;) shouldBe &quot;(Intercepted) Goodbye admin&quot;\n}</code>\n        </deckgo-highlight-code>\n<p>프록시 클래스는 구체적인 클래스와 인터페이스의 서브 클래스이므로, 모든 메서드를 가로챌 수 있다.<br>\n인터페이스를 구현하지 않는 클래스를 프록시하고 싶을 때 유용하다.<br>\n하지만 CGLIB을 통하여 프록시를 생성할 때 지켜야하는 규칙들이 있다.</p>\n<ol>\n<li><strong>클래스를 상속하고 메서드를 오버라이드 하기 때문에 클래스와 메서드가 final이 선언되어 있지 않아야 한다.</strong></li>\n<li><strong>기본 생성자가 꼭 있어야 한다.</strong></li>\n</ol>\n<p>CGLIB은 자바 동적 프록시에 비해 추가적인 기능도 제공한다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">class MyFixedValue: FixedValue {\n    override fun loadObject(): Any = &quot;Intercepted and always return \\&quot;Fixed\\&quot;&quot;\n}\n\nclass MyCallbackFilter : CallbackFilter {\n    override fun accept(method: Method): Int =\n        when(method.name) {\n            &quot;greeting&quot; -&gt; 1 // FixedValue 콜백 사용\n            else -&gt; 0       // MethodInterceptor 사용\n        }\n\n}\n\n&quot;Person 클래스 Cglib Callback, FixedValue 테스트&quot; {\n    val proxy = Enhancer.create(\n        Person::class.java,\n        arrayOf(Hello::class.java, Goodbye::class.java),\n        MyCallbackFilter(),\n        arrayOf&lt;Callback&gt;(MyMethodInterceptor(), MyFixedValue())\n    )\n\n    val person = proxy as Person\n    person.greeting() shouldBe &quot;Intercepted and always return \\&quot;Fixed\\&quot;&quot;\n    person.sayHello(&quot;admin&quot;) shouldBe &quot;(Intercepted) Hello admin&quot;\n    person.sayHi(&quot;admin&quot;) shouldBe &quot;(Intercepted) Hi admin&quot;\n    person.sayThankYou(&quot;admin&quot;) shouldBe &quot;(Intercepted) Thank you admin&quot;\n    person.sayGoodbye(&quot;admin&quot;) shouldBe &quot;(Intercepted) Goodbye admin&quot;\n}</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">Enhancer.create()</code>에서 전달하는 Callback 순서대로 (<code class=\"language-text\">arrayOf&lt;Callback>(MyMethodInterceptor(), MyFixedValue())</code>) <code class=\"language-text\">CallbackFilter</code>에서 어떤 콜백을 실행할지 지정할 수 있다.</p>\n<h1 id=\"4단계-프록시의-구현체-생성-방법을-선택하는-proxyfactory\" style=\"position:relative;\">4단계: 프록시의 구현체 생성 방법을 선택하는 ProxyFactory<a href=\"#4%EB%8B%A8%EA%B3%84-%ED%94%84%EB%A1%9D%EC%8B%9C%EC%9D%98-%EA%B5%AC%ED%98%84%EC%B2%B4-%EC%83%9D%EC%84%B1-%EB%B0%A9%EB%B2%95%EC%9D%84-%EC%84%A0%ED%83%9D%ED%95%98%EB%8A%94-proxyfactory\" aria-label=\"4단계 프록시의 구현체 생성 방법을 선택하는 proxyfactory permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>스프링에서 제공하는 AOP 프록시용 팩토리는 인터페이스가 있을 때는 JDK 동적 프록시를 사용하고, 그렇지 않은 경우에는 CGLIB을 사용한다.<br>\n이제는 부가 기능을 적용할 때 <code class=\"language-text\">Advice (부가 기능)</code>만 지정해주면된다. <code class=\"language-text\">InvocationHandler</code>나 <code class=\"language-text\">MethodInterceptor</code>를 알 필요가 없다.<br>\n프록시 팩토리가 내부에서 JDK 동적 프록시일 경우 InvocationHandler가 Advice를 호출하도록 하고, CGLIB인 경우 MethodInterceptor가 Advice를 호출하도록 기능을 개발해두었기 때문이다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">interface Hello {\n    fun sayHello(name: String): String\n    fun sayHi(name: String): String\n    fun sayThankYou(name: String): String\n}\n\nopen class Person: Hello {\n    open fun greeting() = &quot;안녕하세요!&quot;\n    override fun sayHello(name: String): String = &quot;Hello $name&quot;\n    override fun sayHi(name: String): String = &quot;Hi $name&quot;\n    override fun sayThankYou(name: String): String = &quot;Thank you $name&quot;\n}\n\nopen class ConcretePerson {\n    open fun greeting() = &quot;Concrete 안녕하세요!&quot;\n    open fun sayHello(name: String): String = &quot;Concrete Hello $name&quot;\n    open fun sayHi(name: String): String = &quot;Concrete Hi $name&quot;\n    fun sayThankYou(name: String): String = &quot;Concrete Thank you $name&quot;\n}\n\nclass MyMethodInterceptor1: MethodInterceptor {\n    override fun invoke(invocation: MethodInvocation): String = \n        &quot;(Intercepted1)&quot; + invocation.proceed()\n}\n\nclass MyMethodInterceptor2: MethodInterceptor {\n    override fun invoke(invocation: MethodInvocation): String = \n        &quot;(Intercepted2)&quot; + invocation.proceed()\n}\n\n&quot;인터페이스가 있으면 JDK 동적 프록시 사용&quot; {\n    val proxyFactory: ProxyFactory = ProxyFactory(Person())\n    proxyFactory.addAdvice(MyMethodInterceptor1())\n    proxyFactory.addAdvice(MyMethodInterceptor2())\n\n    shouldThrowExactly&lt;ClassCastException&gt; { proxyFactory.proxy as Person }\n\n    val proxy = proxyFactory.proxy as Hello\n\n    proxy.javaClass.toString() shouldBe &quot;class jdk.proxy2.\\$Proxy7&quot;\n\n    proxy.sayHello(&quot;admin&quot;) shouldBe &quot;(Intercepted1)(Intercepted2)Hello admin&quot;\n    proxy.sayHi(&quot;admin&quot;) shouldBe &quot;(Intercepted1)(Intercepted2)Hi admin&quot;\n    proxy.sayThankYou(&quot;admin&quot;) shouldBe &quot;(Intercepted1)(Intercepted2)Thank you admin&quot;\n}\n\n&quot;구체 클래스만 있으면 CGLIB 사용&quot; {w\n    val proxyFactory: ProxyFactory = ProxyFactory(ConcretePerson())\n    proxyFactory.addAdvice(MyMethodInterceptor1())\n    proxyFactory.addAdvice(MyMethodInterceptor2())\n\n    val proxy = proxyFactory.proxy as ConcretePerson\n\n    proxy.javaClass.toString() shouldBe &quot;class ConcretePerson$\\$SpringCGLIB$$0&quot;\n\n    proxy.greeting() shouldBe &quot;(Intercepted1)(Intercepted2)Concrete 안녕하세요!&quot;\n    proxy.sayHello(&quot;admin&quot;) shouldBe &quot;(Intercepted1)(Intercepted2)Concrete Hello admin&quot;\n    proxy.sayHi(&quot;admin&quot;) shouldBe &quot;(Intercepted1)(Intercepted2)Concrete Hi admin&quot;\n    // open 되지 않은 메서드는 프록시가 실행되지 않는다.\n    proxy.sayThankYou(&quot;admin&quot;) shouldBe &quot;Concrete Thank you admin&quot;\n}\n\n&quot;인터페이스가 있어도 클래스 기반 CGLIB 프록시 사용&quot; {\n    val proxyFactory: ProxyFactory = ProxyFactory(Person())\n    proxyFactory.isProxyTargetClass = true\n    proxyFactory.addAdvice(MyMethodInterceptor1())\n    proxyFactory.addAdvice(MyMethodInterceptor2())\n\n    val proxy = proxyFactory.proxy as Person\n\n    proxy.javaClass.toString() shouldBe &quot;class Person$\\$SpringCGLIB$$0&quot;\n\n    proxy.greeting() shouldBe &quot;(Intercepted1)(Intercepted2)안녕하세요!&quot;\n    proxy.sayHello(&quot;admin&quot;) shouldBe &quot;(Intercepted1)(Intercepted2)Hello admin&quot;\n    proxy.sayHi(&quot;admin&quot;) shouldBe &quot;(Intercepted1)(Intercepted2)Hi admin&quot;\n    proxy.sayThankYou(&quot;admin&quot;) shouldBe &quot;(Intercepted1)(Intercepted2)Thank you admin&quot;\n}</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code  terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">-- JDK 동적 프록시를 사용하는 경우\ninvoke:36, MyMethodInterceptor1\ninvoke:35, MyMethodInterceptor1\nproceed:184, ReflectiveMethodInvocation (org.springframework.aop.framework)\ninvoke:220, JdkDynamicAopProxy (org.springframework.aop.framework)\nsayHello:-1, $Proxy7 (jdk.proxy2)\n\n-- CGLIB을 사용하는 경우\ninvoke:36, MyMethodInterceptor1\ninvoke:35, MyMethodInterceptor1\nproceed:184, ReflectiveMethodInvocation (org.springframework.aop.framework)\nproceed:765, CglibAopProxy$CglibMethodInvocation (org.springframework.aop.framework)\nintercept:717, CglibAopProxy$DynamicAdvisedInterceptor (org.springframework.aop.framework)\ngreeting:-1, Person$$SpringCGLIB$$0</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"java\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">@FunctionalInterface\npublic interface MethodInterceptor extends Interceptor {\n\t@Nullable\n\tObject invoke(@Nonnull MethodInvocation invocation) throws Throwable;\n}</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">invoke()</code>의 파라미터인 <code class=\"language-text\">MethodInvocation</code> 내부에는 <strong>다음 메서드를 호출하는 방법</strong>, <strong>현재 프록시 객체 인스턴스</strong>, <strong>args</strong>, <strong>메서드 정보</strong>등이 포함되어 있다.<br>\nTarget이 MethodInvocation안에 포함되어 있기 때문에 이전 방법과 다르게 프록시 내부에서 Target을 신경쓰지 않아도 된다.</p>\n<p>스프링 부트는 AOP를 적용할 때 기본적으로 <code class=\"language-text\">proxyTargetClass=true</code>로 설정해서 사용하기 때문에 <strong>인터페이스가 있어도 CGLIB을 사용해서 구체 클래스를 기반으로 프록시를 생성한다.</strong></p>\n<h1 id=\"5단계-factorybean\" style=\"position:relative;\">5단계: FactoryBean<a href=\"#5%EB%8B%A8%EA%B3%84-factorybean\" aria-label=\"5단계 factorybean permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>스프링을 대신해서 오브젝트의 생성 로직을 담당하도록 만들어진 특별한 빈이.<br>\n생성할 프록시가 다른 빈을 주입 받을 필요가 있거나 스프링의 기능을 사용해야 한다면 스프링 빈으로 등록해야 할 필요가 있다.<br>\n이때 <strong>스프링은 <code class=\"language-text\">FactoryBean</code> 인터페이스를 구현한 클래스가 Bean의 클래스로 지정되면 <code class=\"language-text\">getObject()</code>를 통해 오브젝트를 가져오고, 이를 빈 오브젝트로 사용한다.</strong></p>\n<ul>\n<li>복잡한 초기화가 필요한 빈을 생성 시</li>\n<li>AOP 프록시와 같이 런타임에 생성되는 프록시 객체를 스프링 빈으로 등록할 때</li>\n</ul>\n<p>이런 경우 유용하게 사용할 수 있다.<br>\n<code class=\"language-text\">@Transactional</code>과 같은 역할을 하는 특정 패턴의 메서드는 정상 처리가 되었다면 commit을 하고 예러가 발생되면 rollback하는 프록시를 만들어보자.<br>\n아래의 예제를 확인해보자.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">/**\n * 프록시로 등록할 인터페이스와 구현체\n */\ninterface Hello {\n    fun sayGreeting(name: String): String\n    fun sayHello(name: String): String\n    fun sayHi(name: String): String\n    fun sayThankYou(name: String): String\n}\nopen class Person: Hello {\n    open fun greeting() = &quot;안녕하세요!&quot;\n    override fun sayGreeting(name: String) = &quot;안녕하세요! $name&quot;\n    override fun sayHello(name: String): String = &quot;Hello $name&quot;\n    override fun sayHi(name: String): String = &quot;Hi $name&quot;\n    override fun sayThankYou(name: String): String = &quot;Thank you $name&quot;\n}\n\n/**\n * 등록할 프록시를 스프링에서 관리할 수 있도록 빈으로 등록하는 FactoryBean 구현체\n * 범용적으로 대상은 Any로 했고, Class 타입도 * 이다.\n */\nclass PersonFactoryBean(\n    private val target: Any,\n    private val `interface`: Class&lt;*&gt;\n): FactoryBean&lt;Any&gt; {\n\n    override fun getObject() = ProxyFactory(target).apply {\n        this.addAdvice(TransactionMethodInterceptor(target, &quot;say&quot;))\n        this.isProxyTargetClass = true // 인터페이스 기반이 아닌 Person 구현체의 프록시를 생성하기 위해 직접 설정\n    }.proxy\n\n    override fun getObjectType(): Class&lt;*&gt; = `interface`\n}\n\n/**\n * 부가 기능을 정의한 MethodInterceptor 구현체이다.\n * 메소드 이름이 주입받은 pattern으로 시작하는 메소드만 부가 기능을 실행하도록 한다.\n */\nclass TransactionMethodInterceptor(\n    private val target: Any,\n    private val pattern: String\n): MethodInterceptor {\n\n    override fun invoke(invocation: MethodInvocation) =\n        if (invocation.method.name.startsWith(pattern))\n            invokeInTransaction(invocation.method, invocation.arguments)\n        else invocation.proceed()\n\n    private fun invokeInTransaction(method: Method, args: Array&lt;out Any&gt;): String {\n        try {\n            return &quot;(Commit)&quot; + method.invoke(target, *args)\n        } catch (e: InvocationTargetException) {\n            throw e.targetException\n        }\n    }\n}\n\n/**\n * Hello와 Person 빈을 등록할 때 프록시로 감싼 빈으로 등록한다.\n */\n@Configuration\nclass AppConfig {\n    @Bean\n    fun hello() = PersonFactoryBean(Person(), Hello::class.java)\n    @Bean\n    fun person() = PersonFactoryBean(Person(), Person::class.java)\n}\n\n@SpringBootTest(&quot;spring.profiles.active=local&quot;)\nclass FactoryBeanTest(\n    private val context: ApplicationContext,\n    private val hello: Hello,\n    private val person: Person\n): AnnotationSpec() {\n\n    private val NAME: String = &quot;admin&quot;\n\n    init {\n        extension(SpringExtension)\n    }\n\n    @Test\n    @DisplayName(&quot;인터페이스 기반 프록시&quot;)\n    fun interfaceProxy() {\n        hello.sayGreeting(NAME) shouldBe &quot;(Commit)안녕하세요! admin&quot;\n        hello.sayHello(NAME) shouldBe &quot;(Commit)Hello admin&quot;\n        hello.sayHi(NAME) shouldBe &quot;(Commit)Hi admin&quot;\n        hello.sayThankYou(NAME) shouldBe &quot;(Commit)Thank you admin&quot;\n    }\n\n    @Test\n    @DisplayName(&quot;클래스 기반 프록시&quot;)\n    fun concreteProxy() {\n        person.greeting() shouldBe &quot;안녕하세요!&quot;\n        person.sayGreeting(NAME) shouldBe &quot;(Commit)안녕하세요! admin&quot;\n        person.sayHello(NAME) shouldBe &quot;(Commit)Hello admin&quot;\n        person.sayHi(NAME) shouldBe &quot;(Commit)Hi admin&quot;\n        person.sayThankYou(NAME) shouldBe &quot;(Commit)Thank you admin&quot;\n    }\n\n    @Test\n    @DisplayName(&quot;팩토리 빈과 빈을 직접 조회하기&quot;)\n    fun searchFactoryBean() {\n        val factoryBean = context.getBean(&quot;&amp;person&quot;, PersonFactoryBean::class.java)\n        (factoryBean.`object` is Person) shouldBe true\n        (factoryBean.`object` is Hello) shouldBe true\n\n        val helloBean = context.getBean(&quot;hello&quot;, Hello::class.java)\n        helloBean.sayGreeting(NAME) shouldBe &quot;(Commit)안녕하세요! admin&quot;\n        helloBean.sayHello(NAME) shouldBe &quot;(Commit)Hello admin&quot;\n        helloBean.sayHi(NAME) shouldBe &quot;(Commit)Hi admin&quot;\n        helloBean.sayThankYou(NAME) shouldBe &quot;(Commit)Thank you admin&quot;\n\n        val personBean = context.getBean(&quot;person&quot;, Person::class.java)\n        personBean.greeting() shouldBe &quot;안녕하세요!&quot;\n        personBean.sayGreeting(NAME) shouldBe &quot;(Commit)안녕하세요! admin&quot;\n        personBean.sayHello(NAME) shouldBe &quot;(Commit)Hello admin&quot;\n        personBean.sayHi(NAME) shouldBe &quot;(Commit)Hi admin&quot;\n        personBean.sayThankYou(NAME) shouldBe &quot;(Commit)Thank you admin&quot;\n    }\n}</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">say</code>로 시작하는 메서드의 반환값에 <code class=\"language-text\">(Commit)</code> 문자열을 추가하여 반환하는 부가 기능을 <code class=\"language-text\">TransactionMethodInterceptor</code>로 정의하여 빈을 등록할 때 <code class=\"language-text\">PersonFactoryBean</code>을 통해 프록시로 감싼 빈을 등록하였다.</p>\n<h1 id=\"6단계-proxyfactorybean\" style=\"position:relative;\">6단계: ProxyFactoryBean<a href=\"#6%EB%8B%A8%EA%B3%84-proxyfactorybean\" aria-label=\"6단계 proxyfactorybean permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>ProxyFactory를 사용하여 프로그래밍 방식으로 프록시를 직접 생성해보았다. 스프링에서는 이 프록시를 빈으로 등록해주는 (<code class=\"language-text\">FactoryBean</code>을 구현하는) <code class=\"language-text\">ProxyFactoryBean</code> 구현체가 존재한다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 900px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/2b0581d4a2f9eefae78781e53b037914/b1001/proxyFactory.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 51.55555555555556%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAABy0lEQVR42k1S23aiQBDkNzYyDAx4ZSBG8ALqBhBcz5oE3BP3Zf//O2q7B415KLqprimmm7ZcV8EPxoiTDRbLFOtNjtVqTTHDar0hZJjONKTrwfX8b1DEPXKOkrwsfgzHGnnxG1Vd4e3tHd31Hz7aC9q2w/l8xssigUM6VwUPsMG3nKOkaHHCYuFICKkwsAX8KIdwA9jE2Y7bm7GBgbpF3/B37p5bLOSWGSoYQvkB/NEMnk95MDJfVpSbd3/0pfNIx5xHdS+4adlQkWB7aFGfGrQfHbruDy6XBz4/rxQviHSMdLdEdapuugvV/uJKONGYymODgEypZR+TWYRpGCGMnhGGGsnru/lJOp4jmieInhcIxiFG0xmmWmNG2pdVgsUmIX2MUEfkoU03FvctpAtbOBgIiSdbwhnGsN2hgVBjOIra8SeUT6ju4GnQa21P4sdAmDkL6Zk5WjzQ0UQjzStsd1tUVYOyOqAsS0IFHWnoeYb1do+iZL5HUVQ41A3q+og0XZqVud2Q1yZEmhXIt5kRmgNsStBRTIYbrHc/sdvviasN/1qUxrA5/kJChs7DsF9IR/bXHgjXtHAHCx1aajMWw8mvdeK2GXzuvkb/AbN5MFOXrCaCAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"proxyFactory\"\n        title=\"\"\n        src=\"/static/2b0581d4a2f9eefae78781e53b037914/1cfc2/proxyFactory.png\"\n        srcset=\"/static/2b0581d4a2f9eefae78781e53b037914/3684f/proxyFactory.png 225w,\n/static/2b0581d4a2f9eefae78781e53b037914/fc2a6/proxyFactory.png 450w,\n/static/2b0581d4a2f9eefae78781e53b037914/1cfc2/proxyFactory.png 900w,\n/static/2b0581d4a2f9eefae78781e53b037914/21482/proxyFactory.png 1350w,\n/static/2b0581d4a2f9eefae78781e53b037914/b1001/proxyFactory.png 1380w\"\n        sizes=\"(max-width: 900px) 100vw, 900px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>","frontmatter":{"title":"스프링의 빈 후처리기에 대해","date":"March 11, 2024","description":null,"tags":["spring","reflection","proxy"]},"tableOfContents":"<ul>\n<li>\n<p><a href=\"#1%EB%8B%A8%EA%B3%84-java-reflection\">1단계: Java Reflection</a></p>\n</li>\n<li>\n<p><a href=\"#2%EB%8B%A8%EA%B3%84-proxy%EB%9E%80\">2단계: Proxy란?</a></p>\n</li>\n<li>\n<p><a href=\"#3%EB%8B%A8%EA%B3%84-proxy-%EC%83%9D%EC%84%B1-%EB%B0%A9%EB%B2%95\">3단계: Proxy 생성 방법</a></p>\n<ul>\n<li><a href=\"#java-dynamic-proxy\">Java Dynamic Proxy</a></li>\n<li><a href=\"#cglibcode-generation-library\">CGLIB(Code Generation Library)</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#4%EB%8B%A8%EA%B3%84-%ED%94%84%EB%A1%9D%EC%8B%9C%EC%9D%98-%EA%B5%AC%ED%98%84%EC%B2%B4-%EC%83%9D%EC%84%B1-%EB%B0%A9%EB%B2%95%EC%9D%84-%EC%84%A0%ED%83%9D%ED%95%98%EB%8A%94-proxyfactory\">4단계: 프록시의 구현체 생성 방법을 선택하는 ProxyFactory</a></p>\n</li>\n<li>\n<p><a href=\"#5%EB%8B%A8%EA%B3%84-factorybean\">5단계: FactoryBean</a></p>\n</li>\n<li>\n<p><a href=\"#6%EB%8B%A8%EA%B3%84-proxyfactorybean\">6단계: ProxyFactoryBean</a></p>\n</li>\n</ul>"},"previous":{"fields":{"slug":"/2024y/generic/"},"frontmatter":{"title":"제네릭 가변성에 대해"}},"next":{"fields":{"slug":"/2024y/bookReview/bookReview/"},"frontmatter":{"title":"2024년 책,강의 서평"}}},"pageContext":{"id":"83e68652-9a78-5344-a893-30311c9782dd","previousPostId":"be694c1c-f095-5970-ae40-b324ed2b5259","nextPostId":"459e967c-8067-5121-a9e4-07e0de4508d6"}},"staticQueryHashes":["230163734","3589320610"],"slicesMap":{}}