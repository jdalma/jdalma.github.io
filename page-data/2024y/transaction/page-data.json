{"componentChunkName":"component---src-templates-blog-post-js","path":"/2024y/transaction/","result":{"data":{"site":{"siteMetadata":{"title":"코딩 주머니"}},"markdownRemark":{"id":"099bd161-b615-5200-ab96-c2a0d6a8dfa3","excerpt":"InnoDB Locking Dirty read, Non-repeatable read, and Phantom read 트랜잭션 트랜잭션은 작업의 완전성을 보장 (COMMIT, ROLLBACK…","html":"<ul>\n<li><strong><a href=\"https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html\">InnoDB Locking</a></strong></li>\n<li><strong><a href=\"https://jennyttt.medium.com/dirty-read-non-repeatable-read-and-phantom-read-bd75dd69d03a\">Dirty read, Non-repeatable read, and Phantom read</a></strong></li>\n</ul>\n<h1 id=\"트랜잭션\" style=\"position:relative;\">트랜잭션<a href=\"#%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98\" aria-label=\"트랜잭션 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>트랜잭션은 <strong>작업의 완전성을 보장 (COMMIT, ROLLBACK)</strong> 해주는 것이다.<br>\n즉 논리적인 작업 셋을 모두 완벽하게 처리하거나 처리하지 못할 경우에는 원 상태로 복구해서 작업의 일부만 적용되는 현상(Partial update)이 발생하지 않게 만들어주는 기능이다.</p>\n<ul>\n<li><strong>트랜잭션</strong> : 데이터의 정합성을 보장하기 위한 기능</li>\n<li><strong>잠금</strong> : 동시성을 제어하기 위한 기능</li>\n<li><strong>격리 수준</strong> : 하나의 트랜잭션 내에서 또는 여러 트랜잭션 간의 작업 내용을 어떻게 공유하고 차단할 것인지 결정하는 레벨</li>\n</ul>\n<p>이 트랜잭션은 개발자에게 엄청난 혜택을 주지만 주의해야 할 점이 있다.<br>\n<strong>트랜잭션 또한 DBMS의 커넥션과 동일하게 꼭 필요한 최소한의 코드에만 적용하도록 신경써야 한다.</strong><br>\n(<a href=\"https://www.youtube.com/watch?v=xc0tnJVGQEw&#x26;ab_channel=%EC%B5%9C%EB%B2%94%EA%B7%A0\">최범균님이 DB 커넥션 풀 부족 장애</a> 트러블 슈팅 내용을 업로드하셨는데 이 영상을 보는것도 좋다.)<br>\n트랜잭션 내에 외부 네트워크 통신과 같은 작업을 최대한 제거해야 한다.</p>\n<h1 id=\"mysql-엔진의-잠금\" style=\"position:relative;\">MySQL 엔진의 잠금<a href=\"#mysql-%EC%97%94%EC%A7%84%EC%9D%98-%EC%9E%A0%EA%B8%88\" aria-label=\"mysql 엔진의 잠금 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>MySQL에서 사용되는 잠금은 크게 <strong>MySQL 엔진</strong> 레벨과 <strong>스토리지 엔진</strong> 레벨로 나눌 수 있다.<br>\nMySQL 엔진 레벨의 잠금은 모든 스토리지 엔진에 영향을 미치지만, 스토리지 엔진 레벨의 잠금은 스토리지 엔진 간 상호 영향을 미치지 않는다.</p>\n<p>MySQL 엔진</p>\n<ul>\n<li>테이블 데이터 동기화를 위한 <strong>테이블 락</strong></li>\n<li>테이블의 구조를 잠그는 <strong>메타데이터 락</strong></li>\n<li>사용자의 필요에 맞게 사용할 수 있는 <strong>네임드 락</strong></li>\n</ul>\n<h2 id=\"글로벌-락\" style=\"position:relative;\">글로벌 락<a href=\"#%EA%B8%80%EB%A1%9C%EB%B2%8C-%EB%9D%BD\" aria-label=\"글로벌 락 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>글로벌 락은 <code class=\"language-text\">FLUSH TABLES WITH READ LOCK</code> 명령으로 획득할 수 있으며, 가장 범위가 큰 잠금이다.<br>\n한 세션에서 글로벌 락을 획득하면 다른 세션에서 <code class=\"language-text\">SELECT</code>를 제외한 대부분의 DDL, DML은 글로벌 락이 해제될 때까지 대기 상태로 기다린다.<br>\n대표적으로 여러 데이터베이스, 테이블 대상으로 일관된 백업을 받기 위해 사용할 수 있다.</p>\n<p>이 글로벌 락보다 조금 더 가벼운 백업 락이 도입됐다.<br>\n특정 세션에서 백업 락을 획득하면 모든 세션에서 테이블의 스키마나 사용자의 인증 관련 정보를 변경할 수 없게된다.<br>\n하지만 일반적인 테이블의 데이터 번경은 허용된다. 백업 락을 잡고 백업 진행 중에 DDL이 유입되면 백업은 실패한다.<br>\n<code class=\"language-text\">LOCK INSTANCE FOR BACKUP</code> 명령으로 백업 락을 획득하고 <code class=\"language-text\">UNLOCK INSTANCE</code> 명령으로 락을 반납한다.</p>\n<h2 id=\"테이블-락\" style=\"position:relative;\">테이블 락<a href=\"#%ED%85%8C%EC%9D%B4%EB%B8%94-%EB%9D%BD\" aria-label=\"테이블 락 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>개별 테이블 단위로 설정되는 잠금이며, 명시적 또는 묵시적으로 특정 테이블의 락을 획득할 수 있다.<br>\n<code class=\"language-text\">LOCK TABLES table_name [ READ | WRITE ]</code> 명령으로 락을 획득하고 <code class=\"language-text\">UNLOCK TABLES</code> 명령으로 락을 반납한다.<br>\nInnoDB 테이블의 경우 <strong>스토리지 엔진 차원에서 레코드 기반의 잠금</strong> 을 제공하기 때문에 단순 데이터 변경 쿼리로 인해 묵시적인 테이블 락이 설정되지는 않으며 스키마를 변경하는 쿼리(DDL)의 경우에만 영향을 미친다.</p>\n<h2 id=\"네임드-락\" style=\"position:relative;\">네임드 락<a href=\"#%EB%84%A4%EC%9E%84%EB%93%9C-%EB%9D%BD\" aria-label=\"네임드 락 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><code class=\"language-text\">GET_LOCK()</code> 함수를 이용해 임의의 문자열에 대해 잠금을 설정할 수 있다.<br>\n이 잠금의 특징은 잠금 대상이 테이블이나 레코드 또는 AUTO_INCREMENT와 같은 데이터베이스 객체가 아니라는 것이다.<br>\n<strong>단순히 사용자가 지정한 문자열에 대해 획득하고 반납하는 잠금</strong> 이다.</p>\n<deckgo-highlight-code language=\"sql\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">-- &lt;트랜잰셕 A&gt;\nselect GET_LOCK(&#39;test1&#39;, -1);\n+-----------------------+\n| GET_LOCK(&#39;test1&#39;, -1) |\n+-----------------------+\n|                     1 |\n+-----------------------+\n1 row in set (0.01 sec)\n\n-- &lt;트랜잰셕 B&gt;\nselect GET_LOCK(&#39;test1&#39;, -1);\n-- 무한 대기 중\n\n-- &lt;트랜잰셕 A&gt;\nselect RELEASE_LOCK(&#39;test1&#39;);\n-- &lt;/트랜잰셕 A&gt;\n\n-- &lt;트랜잰셕 B&gt;\n+-----------------------+\n| GET_LOCK(&#39;test1&#39;, -1) |\n+-----------------------+\n|                     1 |\n+-----------------------+\n&quot;1 row in set (2 min 47.74 sec)&quot;\n-- &lt;/트랜잰셕 B&gt;</code>\n        </deckgo-highlight-code>\n<h2 id=\"메타데이터-락\" style=\"position:relative;\">메타데이터 락<a href=\"#%EB%A9%94%ED%83%80%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%9D%BD\" aria-label=\"메타데이터 락 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>데이터베이스 객체 (대표적으로 테이블이나 뷰 등)의 이름이나 구조를 변경하는 경우에 획득하는 잠금이다.<br>\n<strong>메타데이터 락은 명시적으로 획득하거나 해제할 수 있는 락은 아니고 테이블을 수정할 때 자동으로 획득하는 잠금이다.</strong></p>\n<deckgo-highlight-code language=\"sql\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">-- &lt;트랜잰셕 A&gt;\nset autocommit = FALSE;\n\nselect * from MEMBER;\n+----+----------+\n| id | name     |\n+----+----------+\n|  1 | primary1 |\n|  2 | primary2 |\n|  3 | primary3 |\n|  4 | primary4 |\n+----+----------+\n\nrename table member TO updated_member;\n&quot;Query OK, 0 rows affected (0.05 sec)&quot;\n\n-- &lt;트랜잰셕 B&gt;\nselect * from member;\n&quot;ERROR 1146 (42S02): Table &#39;test.member&#39; doesn&#39;t exist&quot;\n\nselect * from updated_member;\n+----+----------+\n| id | name     |\n+----+----------+\n|  1 | primary1 |\n|  2 | primary2 |\n|  3 | primary3 |\n|  4 | primary4 |\n+----+----------+\n\n-- &lt;/트랜잰셕 A&gt;\n-- &lt;/트랜잰셕 B&gt;</code>\n        </deckgo-highlight-code>\n<p>위의 예시와 같이 트랜잭션 A에서 발생한 DDL은 트랜잭션과 무관하게 실행 즉시 커밋되며 롤백할 수 없다.<br>\n\"일부\" DDL 명령(ALTER TABLE)에 대해서만 트랜잭션을 지원하지만 이것도 사용자가 명시적으로 트랜잭션을 제어할 수 있는 것은 아니고 내부적으로 실패하면 롤백한다.<br>\nDDL은 단일 스레드로 작동한다.</p>\n<h1 id=\"innodb-스토리지-엔진-잠금\" style=\"position:relative;\">InnoDB 스토리지 엔진 잠금<a href=\"#innodb-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EC%97%94%EC%A7%84-%EC%9E%A0%EA%B8%88\" aria-label=\"innodb 스토리지 엔진 잠금 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>MySQL에서 제공하는 잠금과는 별개로 스토리지 엔진 내부에서 레코드 기반의 잠금 방식을 제공하며, 잠금 정보가 상당히 작은 공간으로 관리되기 때문에 락이 페이지 락으로, 또는 테이블 락으로 레벨업되는 경우(락 에스컬레이션)는 없다.<br>\nInnoDB는 <strong>레코드 기반의 잠금 방식 덕분에 MyISAM보다는 훨씬 뛰어난 동시성 처리를 제공할 수 있다.</strong><br>\n<strong>Inno DB내부에서는 여러 트랜잭션들이 경합하고 있는 상황에서 최대한의 성능을 위해서 <code class=\"language-text\">여러 방식의 다양한 락(Lock)을 조합</code>해서 사용하고 있다</strong> <a href=\"https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html\">InnoDB Locking</a></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 858px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/3134361084ee2563db7e0742903d1942/42d54/innodbLock.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 74.66666666666667%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsTAAALEwEAmpwYAAABYUlEQVR42p2U6Y6CQBCEef9Hg8g/MBKjqCjIoeCFB9Cbr7OT7LqHsztJ0TBH9VE9OPI+hmFQW9e1Ik1TRdM0am2H80xYFIVUVSWz2UziOFZC3/d1PssydWb2WhFyaLlcynw+VyRJooSHw0HKspTdbiePx8OecL/fS9/3cjweNRoGDpizTtmQYU1aWEDK0+lU1wxeEnZdpxFcr1eJokhWq5VMJhMF0bmu+2uanwghW6/XstlsFNQNYiIj0tvtJmEYqtLU8VXqDhs4RATn81mVxQmECMA6hIjDN86s2sbUkINEPB6PJQgCjXo0Gsn9fv9/HyIGKUK23W41QhtBviU0fYYFzC8Wi7+1zXOE9CKRAWqJ2hB+bJ2f8IWQ+tF31A/w7nme/V1G0bZtVWkU5HqRIr2IQPQhTljn9oDT6SSXy0UtnQGY57zDI89zTQ2LGKRqROFHwTeOTL+yZvYCRGSNcr0BVniISkararwAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"innodbLock\"\n        title=\"\"\n        src=\"/static/3134361084ee2563db7e0742903d1942/42d54/innodbLock.png\"\n        srcset=\"/static/3134361084ee2563db7e0742903d1942/3684f/innodbLock.png 225w,\n/static/3134361084ee2563db7e0742903d1942/fc2a6/innodbLock.png 450w,\n/static/3134361084ee2563db7e0742903d1942/42d54/innodbLock.png 858w\"\n        sizes=\"(max-width: 858px) 100vw, 858px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>레코드 수준 잠금은 레코드 각각에 잠금이 걸리므로 테이블 수준의 잠금보다는 조금 더 복잡하다.</p>\n<h2 id=\"record-locks\" style=\"position:relative;\">Record Locks<a href=\"#record-locks\" aria-label=\"record locks permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>레코드 자체만을 잠그는 것을 의미하며, InnoDB 스토리지 엔진은 <strong>레코드 자체가 아니라 인덱스의 레코드를 잠근다는 점이다.</strong><br>\n인덱스가 하나도 없는 테이블이더라도 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금을 설정한다.</p>\n<p>InnoDB에서는 대부분 보조 인덱스를 이용한 변경 작업은 넥스트 키 락 또는 갭 락을 사용하지만 <strong>프라이머리 키 또는 유니크 인덱스에 의한 변경 작업에서는 갭에 대해서는 잠그지 않고 레코드 자체에 대해서만 락을 건다.</strong></p>\n<p>레코드를 잠그는 것과 인덱스를 잠그는 것은 중요한 차이를 만들어낸다.<br>\n즉, <strong>변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 락을 걸어야 한다.</strong></p>\n<deckgo-highlight-code language=\"sql\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">CREATE TABLE employees (\n    id int NOT NULL AUTO_INCREMENT,\n    first_name varchar(255) DEFAULT NULL,\n    last_name varchar(255) DEFAULT NULL,\n    PRIMARY KEY (id),\n    KEY idx_first_name (first_name)\n) ENGINE=InnoDB\n\n+----+------------+----------------+\n| id | first_name | last_name      |\n+----+------------+----------------+\n|  1 | John       | Doe1           |\n|  2 | John       | Doe2           |\n|  3 | John       | Doe3           |\n|  4 | John       | Doe4           |\n|  5 | John       | Doe5           |\n|  6 | John       | Doe6           |\n|  7 | John       | Doe7           |\n|  8 | John       | Doe8           |\n|  9 | John       | Doe9           |\n| 10 | John       | Doe10          |\n| 11 | Jane       | Ann1           |\n| 12 | Jane       | Ann2           |\n+----+------------+----------------+</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"sql\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">update employees SET last_name = &#39;Updated Jane4&#39; where first_name = &#39;Jane&#39; and last_name = &#39;Ann1&#39;;</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code  terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">+-------------+----------------+-----------+---------------+-------------+------------+\n| OBJECT_NAME | INDEX_NAME     | LOCK_TYPE | LOCK_MODE     | LOCK_STATUS | LOCK_DATA  |\n+-------------+----------------+-----------+---------------+-------------+------------+\n| employees   | NULL           | TABLE     | IX            | GRANTED     | NULL       |\n| employees   | idx_first_name | RECORD    | X             | GRANTED     | &#39;Jane&#39;, 11 |\n| employees   | idx_first_name | RECORD    | X             | GRANTED     | &#39;Jane&#39;, 12 |\n| employees   | PRIMARY        | RECORD    | X,REC_NOT_GAP | GRANTED     | 11         |\n| employees   | PRIMARY        | RECORD    | X,REC_NOT_GAP | GRANTED     | 12         |\n| employees   | idx_first_name | RECORD    | X,GAP         | GRANTED     | &#39;John&#39;, 1  |\n+-------------+----------------+-----------+---------------+-------------+------------+\n\nIX : Intentional Exclusive, 특정 레코드에 대해 쓰기 잠금을 가지고 있음\nREC_NOT_GAP : 갭 락이 포함되지 않음 순수 레코드에 대한 잠금</code>\n        </deckgo-highlight-code>\n<p>Jane에 대해서 UPDATE를 실행하면 위와 같이 잠금이 활성화된다.<br>\n<strong>UPDATE시 where 절에 index 컬럼으로 특정 지으면 해당 index에 해당하는 레코드들이 락이 걸리고 update에 해당하는 레코드와 동일한 보조 인덱스의 값들을 가지는 로우들도 모두 락이 걸린다.</strong><br>\n테이블에 인덱스가 없으면 모든 행들이 락이 걸리며, where 절에 포함된 최소한의 범위로 락을 잡으려고 한다.<br>\n클러스터 인덱스와 보조 인덱스를 같이 where 절에 추가한다면 클러스터 인덱스 기준으로 락을 건다.<br>\n<a href=\"https://stackoverflow.com/questions/60007863/why-does-innodb-block-more-records-in-case-of-a-secondary-index\">보조 인덱스의 경우 InnoDB가 더 많은 레코드를 차단하는 이유는 무엇입니까?</a></p>\n<p>하지만 조금 의아한 점은 아래의 SQL은 모든 레코드를 잠근다.</p>\n<deckgo-highlight-code language=\"sql\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">-- &lt;트랜잭션 A&gt;\nupdate employees SET last_name = &#39;Updated Doe&#39; where first_name = &#39;John&#39; and last_name = &#39;Doe1&#39;;\n\n-- &lt;트랜잭션 B&gt;\nupdate employees SET last_name = &#39;Updated Jane&#39; where first_name = &#39;Jane&#39;;\n-- 트랜잭션 A의 UPDATE문을 기다린다.</code>\n        </deckgo-highlight-code>\n<p>위와 같이 UPDATE문을 작성하면 10건만 레코드 락이 걸려야하겠지만 아래와 같이 모든 레코드를 잠그게 된다.</p>\n<deckgo-highlight-code  terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">SELECT OBJECT_NAME, INDEX_NAME, LOCK_TYPE, LOCK_MODE, LOCK_STATUS, LOCK_DATA FROM performance_schema.data_locks;\n+-------------+------------+-----------+-----------+-------------+------------------------+\n| OBJECT_NAME | INDEX_NAME | LOCK_TYPE | LOCK_MODE | LOCK_STATUS | LOCK_DATA              |\n+-------------+------------+-----------+-----------+-------------+------------------------+\n| employees   | NULL       | TABLE     | IX        | GRANTED     | NULL                   |\n| employees   | PRIMARY    | RECORD    | X         | GRANTED     | supremum pseudo-record |\n| employees   | PRIMARY    | RECORD    | X         | GRANTED     | 11                     |\n| employees   | PRIMARY    | RECORD    | X         | GRANTED     | 12                     |\n| employees   | PRIMARY    | RECORD    | X         | GRANTED     | 1                      |\n| employees   | PRIMARY    | RECORD    | X         | GRANTED     | 2                      |\n| employees   | PRIMARY    | RECORD    | X         | GRANTED     | 3                      |\n| employees   | PRIMARY    | RECORD    | X         | GRANTED     | 4                      |\n| employees   | PRIMARY    | RECORD    | X         | GRANTED     | 5                      |\n| employees   | PRIMARY    | RECORD    | X         | GRANTED     | 6                      |\n| employees   | PRIMARY    | RECORD    | X         | GRANTED     | 7                      |\n| employees   | PRIMARY    | RECORD    | X         | GRANTED     | 8                      |\n| employees   | PRIMARY    | RECORD    | X         | GRANTED     | 9                      |\n| employees   | PRIMARY    | RECORD    | X         | GRANTED     | 10                     |\n+-------------+------------+-----------+-----------+-------------+------------------------+</code>\n        </deckgo-highlight-code>\n<h2 id=\"gap-locks\" style=\"position:relative;\">Gap Locks<a href=\"#gap-locks\" aria-label=\"gap locks permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>갭 락은 레코드 자체가 아니라 <strong>레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 것을 의미한다.</strong><br>\n갭 락의 역할은 <strong>레코드와 레코드 사이의 간격에 새로운 레코드가 생성되는 것을 제어하는 것</strong> 이며, 넥스트 키 락의 일부로 자주 사용된다.</p>\n<h2 id=\"next-key-locks\" style=\"position:relative;\">Next Key Locks<a href=\"#next-key-locks\" aria-label=\"next key locks permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>레코드 락과 갭 락을 합쳐 놓은 형태의 잠금이며, <strong>갭 락이나 넥스트 키 락은 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어 낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주 목적이다.</strong><br>\n하지만 의외로 넥스트 키 락과 갭 락으로 인해 데드락이 발생하거나 다른 트랜잭션을 기다리게 만드는 일이 자주 발생하기 때문에 해당 락은 줄이는 것이 좋다.<br>\n그래서 MySQL 8.0에서는 ROW 포맷의 바이너리 로그가 기본 설정으로 변경됐다. 바이너리 로그 포맷 관련 내용은 <a href=\"https://dev.mysql.com/doc/refman/8.0/en/binary-log-setting.html\">Setting The Binary Log Format</a> 참고하자.</p>\n<h2 id=\"auto-increment-locks\" style=\"position:relative;\">Auto Increment Locks<a href=\"#auto-increment-locks\" aria-label=\"auto increment locks permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>자동 증가하는 숫자 값을 추출(채번)하기 위해 AUTO_INCREMENT라는 컬럼 속성을 제공한다.<br>\n<strong>해당 컬럼이 존재하는 테이블에 여러 레코드가 동시에 INSERT 되는 경우, 저장되는 각 레코드는 중복되지 않고 저장된 순서대로 증가하는 일련번호 값을 가져야하기 때문에 내부적으로 Auto increment lock 이라고 하는 테이블 수준의 잠금을 사용한다.</strong></p>\n<p>새로운 레코드를 저장하는 쿼리에서만 필요하며, UPDATE나 DELETE의 쿼리에서는 잠금이 실행되지 않는다.<br>\n<strong>이 락은 트랜잭션과 관계없이 INSERT나 REPLACE 문장에서 AUTO_INCREMENT 값을 가져오는 순간만 락이 걸렸다가 즉시 해제된다.</strong></p>\n<p>위의 설명은 MySQL 5.0이하 버전에서 사용하던 방식이고 <code class=\"language-text\">innodb_autoinc_lock_mode</code>라는 시스템 변수를 이용해 자동 증가 락의 작동 방식을 변경할 수 있다.<br>\n자세한 내용은 <a href=\"https://dev.mysql.com/doc/refman/8.0/en/innodb-auto-increment-handling.html\">AUTO_INCREMENT Handling in InnoDB</a>을 참고하자.</p>\n<h2 id=\"shared-and-exclusive-locks\" style=\"position:relative;\">Shared and Exclusive Locks<a href=\"#shared-and-exclusive-locks\" aria-label=\"shared and exclusive locks permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>InnoDB는 공유(<code class=\"language-text\">S</code>) 잠금과 독점(<code class=\"language-text\">X</code>) 잠금의 두 가지 잠금 유형이 있는 행 수준 잠금을 구현한다.<br>\n사용자가 필요에 따라 명시적으로 <code class=\"language-text\">locking read</code>를 할 수 있도록 두가지 쿼리를 제공한다.</p>\n<h3>SELECT ... LOCK IN SHARE MODE</h3>\n<p>한 트랜잭션에서 읽어간 데이터를 <strong>다른 트랜잭션에서 배타적으로 수정하기 위해 락을 획득하려 할때 기다리게 한다. <code class=\"language-text\">S</code></strong><br>\n두 개의 세션에서 특정 레코드에 대한 <code class=\"language-text\">S</code> 락을 동시에 가질 수 있다. (Shared Lock이 걸려있는 동안 다른 트랜잭션이 해당 row에 대해 <code class=\"language-text\">X</code> lock 획득은 불가능하지만 <code class=\"language-text\">S</code> lock 획득은 가능)</p>\n<deckgo-highlight-code language=\"sql\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">-- &lt;트랜잭션 A&gt;\nselect * from employees where id = 10 for share;\n-- 1 row in set (0.00 sec)\n\n-- &lt;트랜잭션 B&gt;\nselect * from employees where id = 10 for share;\n-- 1 row in set (0.00 sec)\n\nSELECT OBJECT_NAME, INDEX_NAME, LOCK_TYPE, LOCK_MODE, LOCK_STATUS, LOCK_DATA FROM performance_schema.data_locks;\n+-------------+------------+-----------+---------------+-------------+-----------+\n| OBJECT_NAME | INDEX_NAME | LOCK_TYPE | LOCK_MODE     | LOCK_STATUS | LOCK_DATA |\n+-------------+------------+-----------+---------------+-------------+-----------+\n| employees   | NULL       | TABLE     | IS            | GRANTED     | NULL      |\n| employees   | PRIMARY    | RECORD    | S,REC_NOT_GAP | GRANTED     | 10        |\n| employees   | NULL       | TABLE     | IS            | GRANTED     | NULL      |\n| employees   | PRIMARY    | RECORD    | S,REC_NOT_GAP | GRANTED     | 10        |\n+-------------+------------+-----------+---------------+-------------+-----------+</code>\n        </deckgo-highlight-code>\n<p>MySQL 8.0 부터는 기존 <em>LOCK IN SHARE MODE</em> 대신 <code class=\"language-text\">FOR SHARE</code>라고 간략하게 적어줘도 된다.  <em>(하위 호환성을 위해 기존 구문도 문제 없이 실행됨)</em></p>\n<h3>SELECT ... FOR UPDATE</h3>\n<p>한 트랜잭션에서 읽어간 데이터를 <strong>다른 트랜잭션에서 배타적으로 읽거나, 수정하기 위해 락을 획득하려할 때 기다리게 한다. <code class=\"language-text\">X</code></strong><br>\n<code class=\"language-text\">exclusive lock</code>이 걸려있으면 다른 트랜잭션이 해당 row에 대해 <code class=\"language-text\">X</code> , <code class=\"language-text\">S</code> lock을 모두 획득하지 못하고 대기해야 한다.</p>\n<deckgo-highlight-code language=\"sql\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">-- &lt;트랜잭션 A&gt;\nselect * from employees where id = 10 for update;\n-- 1 row in set (0.00 sec)\n\n-- &lt;트랜잭션 B&gt;\nSELECT OBJECT_NAME, INDEX_NAME, LOCK_TYPE, LOCK_MODE, LOCK_STATUS, LOCK_DATA FROM performance_schema.data_locks;\n+-------------+------------+-----------+---------------+-------------+-----------+\n| OBJECT_NAME | INDEX_NAME | LOCK_TYPE | LOCK_MODE     | LOCK_STATUS | LOCK_DATA |\n+-------------+------------+-----------+---------------+-------------+-----------+\n| employees   | NULL       | TABLE     | IX            | GRANTED     | NULL      |\n| employees   | PRIMARY    | RECORD    | X,REC_NOT_GAP | GRANTED     | 10        |\n+-------------+------------+-----------+---------------+-------------+-----------+\n\nselect * from employees where id = 10 for update;\n-- 대기</code>\n        </deckgo-highlight-code>\n<h2 id=\"intention-locks\" style=\"position:relative;\">Intention Locks<a href=\"#intention-locks\" aria-label=\"intention locks permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>행 잠금과 테이블 잠금이 공존할 수 있는 다중 세분성 잠금을 지원한다.</p>\n<ul>\n<li>intention shared lock (<code class=\"language-text\">IS</code>) : 트랜잭션이 테이블의 개별 행에 공유 잠금을 설정하려고 함을 나타낸다.</li>\n<li>intention exclusive lock (<code class=\"language-text\">IX</code>) : 트랜잭션이 테이블의 개별 행에 독점 잠금을 설정하려고 함을 나타낸다.</li>\n</ul>\n<p>예를 들어 <code class=\"language-text\">SELECT ... FOR SHARE</code>는 IS 잠금을 설정하고 <code class=\"language-text\">SELECT ... FOR UPDATE</code>는 IX 잠금을 설정합니다.</p>\n<deckgo-highlight-code  terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">+-------------+------------+-----------+---------------+-------------+-----------+\n| OBJECT_NAME | INDEX_NAME | LOCK_TYPE | LOCK_MODE     | LOCK_STATUS | LOCK_DATA |\n+-------------+------------+-----------+---------------+-------------+-----------+\n| employees   | NULL       | TABLE     | IS            | GRANTED     | NULL      |\n| employees   | PRIMARY    | RECORD    | S,REC_NOT_GAP | GRANTED     | 9         |\n| employees   | NULL       | TABLE     | IX            | GRANTED     | NULL      |\n| employees   | PRIMARY    | RECORD    | X,REC_NOT_GAP | GRANTED     | 10        |\n+-------------+------------+-----------+---------------+-------------+-----------+</code>\n        </deckgo-highlight-code>\n<table>\n<thead>\n<tr>\n<th></th>\n<th><strong>X</strong></th>\n<th><strong>IX</strong></th>\n<th><strong>S</strong></th>\n<th><strong>IS</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>X</strong></td>\n<td>Conflict</td>\n<td>Conflict</td>\n<td>Conflict</td>\n<td>Conflict</td>\n</tr>\n<tr>\n<td><strong>IX</strong></td>\n<td>Conflict</td>\n<td>Compatible</td>\n<td>Conflict</td>\n<td>Compatible</td>\n</tr>\n<tr>\n<td><strong>S</strong></td>\n<td>Conflict</td>\n<td>Conflict</td>\n<td>Compatible</td>\n<td>Compatible</td>\n</tr>\n<tr>\n<td><strong>IS</strong></td>\n<td>Conflict</td>\n<td>Compatible</td>\n<td>Compatible</td>\n<td>Compatible</td>\n</tr>\n</tbody>\n</table>\n<p>Intention Lock은 전체 테이블 요청(예: <code class=\"language-text\">LOCK TABLES ... WRITE</code>)을 제외하고는 아무것도 차단하지 않으며, 주요 목적은 <strong>누군가 행을 잠그고 있거나 테이블의 행을 잠그려고 한다는 것을 표시하는 것이다.</strong><br>\n하지만 동일한 레코드에 Row-Level Lock의 실제 잠금(<code class=\"language-text\">S</code> 또는 <code class=\"language-text\">X</code>)을 획득하는 과정에서 동시 접근을 막거나 허용하는 제어를 하게 된다.<br>\n<code class=\"language-text\">LOCK TABLES</code> , <code class=\"language-text\">ALTER TABLE</code> , <code class=\"language-text\">DROP TABLE</code>이 실행될 때는 <code class=\"language-text\">IS</code> , <code class=\"language-text\">IX</code>를 모두 <strong>block</strong>하는 <strong>Table-Level Lock</strong>이 걸린다 (즉 , <code class=\"language-text\">IS</code> 또는 <code class=\"language-text\">IX</code> lock을 획득하려는 트랜잭션은 대기상태로 빠진다)</p>\n<h1 id=\"db-트랜잭션-격리-수준\" style=\"position:relative;\">DB 트랜잭션 격리 수준<a href=\"#db-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EA%B2%A9%EB%A6%AC-%EC%88%98%EC%A4%80\" aria-label=\"db 트랜잭션 격리 수준 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>여러 트랜잭션이 동시에 처리될 때 <strong>특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 말지를 결정하는 것이다.</strong><br>\nThread에서 공유 자원에 동시 접근을 제한하기 위해 <strong>Lock</strong>을 걸듯이 DB에서도 <strong><code class=\"language-text\">Transaction</code>간에 같은 동일한 데이터에 대한 동시 접근을 제한</strong>하기 위하여 <strong>Lock</strong>을 설정할 수 있다<br>\n<em><code class=\"language-text\">Lock</code>을 건다는 것은 동시처리량이 줄어든다는 의미이기 때문에 과도하게 사용하면 성능에 문제가 생길 수 있다</em></p>\n<p>가장 낮은 <strong>레벨 0</strong>의 경우 <code class=\"language-text\">Lock</code>이 걸리지 않기 때문에 속도는 매우 빠르나 동시 접근을 허용하기 때문에 데이터 정합성에 문제가 생길 수 있다<br>\n가장 높은 <strong>레벨 3</strong>의 경우 완전히 <code class=\"language-text\">Lock</code>을 걸어 동시 접근을 차단하고 순차적으로 처리하기 때문에 정합성은 완벽하지만 동시에 처리할 수 있는 양이 적어 속도가 매우 느리다</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\"><strong>Isolation Level</strong></th>\n<th align=\"left\"><strong>Dirty Read</strong></th>\n<th align=\"left\"><strong>Nonrepeatable Read</strong></th>\n<th align=\"left\"><strong>Phantom Read</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><code class=\"language-text\">레벨0</code> <strong>Read Uncommited</strong> 커밋되지 않은 읽기</td>\n<td align=\"left\">발생</td>\n<td align=\"left\">발생</td>\n<td align=\"left\">발생</td>\n</tr>\n<tr>\n<td align=\"left\"><code class=\"language-text\">레벨1</code> <strong>Read Committed</strong>\t커밋된 읽기</td>\n<td align=\"left\">X</td>\n<td align=\"left\">발생</td>\n<td align=\"left\">발생</td>\n</tr>\n<tr>\n<td align=\"left\"><code class=\"language-text\">레벨2</code> <strong>Repeatable Read</strong> 반복 가능한 읽기</td>\n<td align=\"left\">X</td>\n<td align=\"left\">X</td>\n<td align=\"left\">발생  <code class=\"language-text\">InnoDB는 발생 X</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code class=\"language-text\">레벨3</code> <strong>Serializable</strong>\t직렬화 가능</td>\n<td align=\"left\">X</td>\n<td align=\"left\">X</td>\n<td align=\"left\">X</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"read-uncommited\" style=\"position:relative;\">READ-UNCOMMITED<a href=\"#read-uncommited\" aria-label=\"read uncommited permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 631px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/eca1145dc503fac3b82564f1a99d645e/4597d/readUncommitted.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 100.8888888888889%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsTAAALEwEAmpwYAAACHUlEQVR42pVUx6oqURD0s3WjGxeCfoArQV0pGEBFxY0LEQMIKhgwgznnrPVuHd4Z1OvFsWEYZk53dXV1n9Zcr1csFgssl0us12vx3u12+GS32034MlbGbbdbaBhcrVbRbDbF4WazQa/X+wh4Op1Qq9VQqVQUEt1uF5rj8YhcLodsNovBYIDJZIJ2u60E3u/3Xw/tfD6LuHQ6LeLG4zFarRY0pE70fr8vmJbLZVECjXLw/NEkIN8scTabiRhWRxyNdOAh2bEUZr9cLiB7gksp6MMkj0Y/MpRJFEAGMtsjC4JYrVYYjUZYLBaYzWZEIpEnHyaXmj8BMvtoNMJ8PhdMyY7M3G43HA4HvF4vXC4XEonEEyAZUq63gMxEUJZAdhTabrfDZrMJQKfTqR6QAK8lsyGlUkl0slAoIJ/Piwq+BpTCD4dDmEwmaLVaGAwG6PV6hMPhp3GiNB8B5ahQQ4/HA5/Ph2g0ikAggGQyKaThGecuk8mg0+moK3m1WglAPmTm9/sRj8cxnU6F1nwTTDXgO5N3VjawXq+j0WioAzwcDojFYoIZGYZCIVGm1Jl+vAhv5/BdUyg2h1qn0ylNCQaD380htw5ZEJxPKpVCsVgUm4TbhWW+Xr0/u8xBlteJLGUSjg+7yibwnyrAd3dZjRHwWcOfmbv+3yxcP2RGJ7KUm+dxZb0a/+33e+VbbGxmmP4sBOpEjfjNJctvlvmN/QNAjOeYLcH0YgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"readUncommitted\"\n        title=\"\"\n        src=\"/static/eca1145dc503fac3b82564f1a99d645e/4597d/readUncommitted.png\"\n        srcset=\"/static/eca1145dc503fac3b82564f1a99d645e/3684f/readUncommitted.png 225w,\n/static/eca1145dc503fac3b82564f1a99d645e/fc2a6/readUncommitted.png 450w,\n/static/eca1145dc503fac3b82564f1a99d645e/4597d/readUncommitted.png 631w\"\n        sizes=\"(max-width: 631px) 100vw, 631px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p><strong>각 트랜잭션에서의 변경 내용이 <code class=\"language-text\">COMMIT</code>이나 <code class=\"language-text\">ROLLBACK</code>여부에 상관없이 다른 트랜잭션에서 보여지게 된다</strong><br>\nRDBMS 표준 에서는 트랜잭션의 격리 수준으로 인정하지 않을 정도로 문제가 많으며 <code class=\"language-text\">Dirty Read</code>가 허용되는 격리 수준이다</p>\n<h3 id=\"dirty-read-문제\" style=\"position:relative;\">Dirty Read 문제<a href=\"#dirty-read-%EB%AC%B8%EC%A0%9C\" aria-label=\"dirty read 문제 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p><strong>한 트랜잭션에서 처리한 작업이 완료되지 않았음에도 불구하고 다른 트랜잭션에서 볼 수 있게 되는 현상</strong></p>\n<deckgo-highlight-code language=\"sql\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">set autocommit = FALSE;\n\nset transaction_isolation = &#39;READ-UNCOMMITTED&#39;;\nSHOW VARIABLES LIKE &#39;%isolation&#39;;\n\n-- &lt;트랜잰셕 A&gt;\nstart transaction;\n\nupdate bookmark set name = &#39;탈출&#39; where id = &#39;1&#39;;\n-- &lt;/트랜잰셕 A&gt;\n\n-- &lt;트랜잭션 B&gt; Dirty Read 발생\nselect * from bookmark;\n-- &lt;/트랜잭션 B&gt;\n\n-- &lt;트랜잭션 A&gt;\nrollback;\n-- &lt;/트랜잭션 A&gt;</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">A 트랜잭션</code>의 작업단위를 최종적으로 끝내지않아도 다른 트랜잭션들도 해당 변경사항에 대해 노출된다.</p>\n<h2 id=\"read-committed\" style=\"position:relative;\">READ-COMMITTED<a href=\"#read-committed\" aria-label=\"read committed permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 685px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/2f449257e0b0d29202b5990ecb45571d/8ce22/readCommitted.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 101.33333333333334%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsTAAALEwEAmpwYAAACbUlEQVR42pVUuapiQRD1P40EEwNjNRZMTQQDEzXQ5BkIgo+noIiIqKgouO/7vu/Lq5lT0Jf79A4z01Dcpvv2qXNOVbfqfD7Tbrejw+HAsd/v6fl8khiYy+P7+1vaOx6P/L/8q1osFlQsFmm5XNJ2u6XNZkPj8ZgPyA+/jvv9ToPBgEqlEq3XayY1Go1INZ1OKRKJULvdptlsxmACEKNer1MqleKkuVxO2gPbarVK8XichsMhn221WqQCTWQol8u8AaZCMvYsFgvp9XoyGo1kMBjI7XZLyaBotVoxy8lkwupUQhYWrtfrD6mQlUgkmAXY5PN5ZiGG+A+sH48Hz1WCDdjVajVmhc3b7cYJut0uB1RAFlgIIPGFd0jOgGIRgGCBgwBCxU+nE6/DRzDrdDpcTQGmyFAsomLNZpNQJATYYM1qtZLJZCKz2czx8fEhSYYKMFMEVPIQreDz+RgkHA6T3++naDTKTJEQnZFOp6nRaEhnfgAK34SP8AsgXq+XAoEAz9FisAV7CFQaHotaSICQCc9QyUwmw1nhYzabpa+vLwoGgxSLxbgXX4vyR8mXy4VNRwAcHmq1WlKr1aTT6Uij0bCnYAMlCKjq9XrvDOUeyhsXtwSB5k0mk9yT8A4gCMhFMRU9fC2K0sBjAom4ISga3gK0lCIgJCsBiJ7EvjzZXz18ZQh/PB4P+2az2chut1MoFHprbNwURUA8DGAkgPEFoMPhIJfLRU6nkz4/P/+NIQyuVCqcDU0rHtxCocCthHVczfl8/gaIbngDBDP5Sy0OCGDsw8fXThDPnFSUxe+MyArJeAgwR1v0+3224H/HL46t2QW8QSnKAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"readCommitted\"\n        title=\"\"\n        src=\"/static/2f449257e0b0d29202b5990ecb45571d/8ce22/readCommitted.png\"\n        srcset=\"/static/2f449257e0b0d29202b5990ecb45571d/3684f/readCommitted.png 225w,\n/static/2f449257e0b0d29202b5990ecb45571d/fc2a6/readCommitted.png 450w,\n/static/2f449257e0b0d29202b5990ecb45571d/8ce22/readCommitted.png 685w\"\n        sizes=\"(max-width: 685px) 100vw, 685px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p><strong>온라인 서비스에서 가장 많이 선택되는 격리수준</strong> <em>오라클 DBMS에서 기본적으로 사용되고 있다</em><br>\n<strong>Undo 영역</strong>을 통해서 데이터를 가져오기 때문에 Dirty Read는 발생하지 않지만 , <code class=\"language-text\">NON_REPEATABLE READ</code> 문제가 발생한다</p>\n<h3 id=\"non-repeatable-read-문제\" style=\"position:relative;\">NON-REPEATABLE READ 문제<a href=\"#non-repeatable-read-%EB%AC%B8%EC%A0%9C\" aria-label=\"non repeatable read 문제 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 837px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/d3e28c67b919bed963714cc9d885eefe/ddc81/nonRepetableRead.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 93.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAYAAACQjC21AAAACXBIWXMAAAsTAAALEwEAmpwYAAACEElEQVR42o1UyaoqUQzsz3YjgiC4cSHoF4iCbnQjLgS3giK6UBHneZ7nue6tQBp99PN6IJzudLpSqeQc4/l84vF4iN3vd9xuN9D312IM41//47PBl0ajgXa7jfV6jfl8jsViYf6kydQ0GZ87nQ6q1SpWq5XYZDKBwQ/5fB65XA7j8RiDwUB2BfzEsFQqIZvNYjQaCVi/34fBD/v9XrJ1u11hSfpcl8sFhUIB6XRafiwWizgej2aZjCWRWq2GzWYj8YayoGO73ZrlcJGt0+mEzWaD3W6Hy+VCq9USsOv1ivP5LKxYrrI2AZmNoK+lkjmZsTTVuVKpSIk0VlUul980t2SoPrJYLpfybbfbSdLpdCpl09dqtpDJZDAcDr8DVB1Zmo4I9WUiGn1kZ8mQDOr1ugAzkIv6uN1uOBwO0c/r9b7ppbJYakhA6sFGqJ5MEAgEEAqFEA6HEY1G39h8BGS5zWbTFJygfCdIIpFAMplEKpWSxF8D9no9YcAAlk3tdCatBvsjoFVTGByLxRAMBhGJRBCPx99i2DCeKlZjCahzqIM9m83g8/ng8XikIX6/X+aSfo4KTxZnlKP1FcPT6SSNUm3ZMIIcDgdpGIedc0j/nwz1puEQU0uWR9P5053s/juH/3bwm0W2r0fWuP92kRkoLHfeh2rsHncy+3SNvRKQC3bzC8aOUkPdmYCMmZ3lfbt+ACnyo1llYM13AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"nonRepetableRead\"\n        title=\"\"\n        src=\"/static/d3e28c67b919bed963714cc9d885eefe/ddc81/nonRepetableRead.png\"\n        srcset=\"/static/d3e28c67b919bed963714cc9d885eefe/3684f/nonRepetableRead.png 225w,\n/static/d3e28c67b919bed963714cc9d885eefe/fc2a6/nonRepetableRead.png 450w,\n/static/d3e28c67b919bed963714cc9d885eefe/ddc81/nonRepetableRead.png 837w\"\n        sizes=\"(max-width: 837px) 100vw, 837px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p><strong>동일한 SELECT 쿼리를 실행했을 때 항상 같은 결과를 보장해야 한다는 <code class=\"language-text\">\"REPEATABLE READ\"</code> 정합성에 어긋난다</strong></p>\n<deckgo-highlight-code language=\"sql\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">set autocommit = FALSE;\n\nset transaction_isolation = &#39;READ-COMMITTED&#39;;\nSHOW VARIABLES LIKE &#39;%isolation&#39;;\n\n-- &lt;트랜잭션 A&gt;\nstart transaction;\n\nselect * from bookmark;\n-- &lt;/트랜잭션 A&gt;\n\n-- &lt;트랜잭션 B&gt;\nstart transaction;\n\nupdate bookmark set name = &#39;탈출&#39; where id = &#39;1&#39;;\n\nCOMMIT;\n-- &lt;/트랜잭션 B&gt;\n\n-- &lt;트랜잭션 A&gt; NON-REPEATABLE READ 문제 발생\nselect * from bookmark;\n-- &lt;/트랜잭션 A&gt;</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">트랜잭션 A</code>의 <code class=\"language-text\">첫 번째 SELECT</code>와 <code class=\"language-text\">두 번째 SELECT</code>의 결과가 서로 달라 <strong>하나의 트랜잭션 내에서 항상 똑같은 결과를 가져와야 하는 <code class=\"language-text\">REPEATABLE-READ</code>가 보장되지 않는 것이다.</strong></p>\n<blockquote>\n<p>일반적인 웹 프로그램에서는 크게 문제되지 않을 수 있지만, <strong>하나의 트랜잭션에서 동일 데이터를 여러 번 읽고 변경하는 작업이 금전적인 처리와 연결되면 문제가 될 수도 있다.</strong><br>\n예를 들어, 다른 트랜잭션에서 입금과 출금 처리가 계속 진행될 때 다른 트랜잭션에서 오늘 입금된 금액의 총합을 조회한다고 가정해보면<br>\n<code class=\"language-text\">REPEATABLE-READ</code>가 보장되지 않기 때문에 총합을 계산하는 <code class=\"language-text\">SELECT</code>쿼리는 실행될 때 마다 다른 결과를 가져올 것이다.</p>\n</blockquote>\n<p><strong>중요한 것은 사용 중인 트랜잭션의 격리 수준에 의해 실행하는 SQL문장이 어떤 결과를 가져오게 되는지를 정확히 예측할 수 있어야 한다는 것이다.</strong><br>\n<code class=\"language-text\">READ-COMMITTED</code>에서는 트랜잭션 외부에서 실행되는 <code class=\"language-text\">SELECT</code>문과 내부에서 실행되는 것과 차이가 없다.<br>\n하지만 <code class=\"language-text\">REPEATABLE-READ</code> 트랜잭션 내부에서는 온종일 동일한 결과가 반환된기 때문에 큰 차이가 있다.</p>\n<h2 id=\"repeatable-read\" style=\"position:relative;\">REPEATABLE-READ<a href=\"#repeatable-read\" aria-label=\"repeatable read permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 781px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/4f84513a095fd89c8cd9933700e4c0d0/7fee5/repeatableRead.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 111.55555555555556%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAWCAYAAADAQbwGAAAACXBIWXMAAAsTAAALEwEAmpwYAAACjElEQVR42o1VWWsyQRD07wpC3kV/gEFBouKzEUENGA+UBEEJ8YAIQl48olE8Erzv+0h/qYaW9YuJDjQ7uztbU9XVPavabDY0Go1oNpvRdDql+XxOyvH19XWI/8dqtTr6drFYkAo32WyWPj8/+SWuu92OP9jv9xwCKPcyxuMxZTIZarVaDNhsNkmFCQDz+Tx9fHxQvV4/YgNwqBBg2QjPer0eJZNJKhQKDMaAsqjT6fAikYkRiUTIaDSSwWDgq8lkooeHB36P9f1+n2U2Gg2Wj3EA7Ha7tN1uj5hBzuPjI93d3VEwGKRAIEAvLy80mUxoMBiwzEqlwiHfHgEKQwwsQI4gC5La7TavQb7ADPLe39+pXC7T29vbaUAlw9/GcrlkZsPhkHMO6QAWMgdA7Aw2YAXnAZ7L5cjv95PP56NQKMTyS6XSUTlJ/n/kEO7CaQFFeL1eslgsbAbi+vqagZUl9SsgnKpWqwyIwAZPT08UDofJ7XYz0P39PRt1EUMxRXZGOYAlclWr1bjgMVd20p+AYAUQ5A2uIvlOp5N0Oh1ptVrS6/U8RwmJ5LMMwQBSwQbsotEouVwucjgc5PF4eINEInGZZJQApIkpKF5pO4QSQNnbfzKUOpSFKBOz2UxWq5Vubm7IbrdTLBY7gF4MKJ2STqfZ3dvbW65FyH5+fubUSN0Wi0WuzbOdguKGSXAV5YQU4B5HHFoP7xEwD224Xq/PHw5wHIzi8TjLT6VS9Pr6epB61mUlIIxAl2g0GlKr1XR1dcVzm83Gm4ElehhVgQPiRy+fOhzwkbiPUsIc6yAT8iUtAD1IBghu5J+AOQISTv1HTg3pMAbELp3vsw6Otb6vyIece5IXSFT+rE6FjH9aoWvXquU5PAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"repeatableRead\"\n        title=\"\"\n        src=\"/static/4f84513a095fd89c8cd9933700e4c0d0/7fee5/repeatableRead.png\"\n        srcset=\"/static/4f84513a095fd89c8cd9933700e4c0d0/3684f/repeatableRead.png 225w,\n/static/4f84513a095fd89c8cd9933700e4c0d0/fc2a6/repeatableRead.png 450w,\n/static/4f84513a095fd89c8cd9933700e4c0d0/7fee5/repeatableRead.png 781w\"\n        sizes=\"(max-width: 781px) 100vw, 781px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p><strong>MySQL의 InnoDB 스토리지 엔진에서 기본적으로 사용되는 격리 수준</strong> <code class=\"language-text\">\"NON-REPEATABLE READ\"</code> 부정합이 발생하지 않는다<br>\n<strong>InnoDB 스토리지 엔진</strong>은 트랜잭션이 <code class=\"language-text\">ROLLBACK</code>될 가능성에 대비해 <strong>변경되기 전 레코드를 언두(Undo) 영역에 백업해두고 실제 레코드 값을 변경한다</strong><br>\n이러한 변경 방식을 <a href=\"https://dev.mysql.com/doc/refman/8.0/en/innodb-multi-versioning.html\"><code class=\"language-text\">MVCC(Multi Version Concurrency Control)</code></a>이라고 한다</p>\n<blockquote>\n<p>✋ <code class=\"language-text\">MVCC(Multi Version Concurrency Control)</code> - <strong>잠금을 사용하지 않는 일관된 읽기를 제공</strong><br>\nMVCC는 다중 버전 병행수행 제어의 약자로 DBMS에서는 쓰기(Write) 세션이 읽기(Read) 세션을 블로킹하지 않고,<br>\n읽기 세션이 쓰기 세션을 블로킹하지 않게 서로 다른 세션이 동일한 데이터에 접근했을 때 각 세션마다 스냅샷 이미지를 보장해주는 메커니즘이며 하나의 레코드에 대해 여러 개의 버전이 동시에 관리된다는 의미다.<br>\n변경되기 이전의 내용을 보관하고 있는 언두 영역의 데이터를 반환하는 과정을 DBMS에서는 <strong>MVCC</strong>라고 표현한다.<br>\n<code class=\"language-text\">COMMIT</code>명령을 실행한다면 현재 시점의 상태를 영구적인 데이터로 만들어버리지만, (COMMIT이 된다고 항상 바로 삭제되지 않고, 해당 언두 영역을 필요로 하지 않는 트랜잭션이 더는 없을 때 삭제한다.)<br>\n<code class=\"language-text\">ROLLBACK</code>을 실행한다면 <strong>언두 영역에 있는 백업된 데이터를 InnoDB 버퍼 풀로 다시 복구하고, 언두 영역의 내용을 삭제해 버린다.</strong></p>\n</blockquote>\n<p><strong>REPEATABLE READ</strong>는 이 <code class=\"language-text\">MVCC</code>를 위해 <strong>언두 영역에 백업된 이전 데이터를 통해 동일한 트랜잭션 내에서는 동일한 결과를 보여줄 수 있도록 보장한다</strong><br>\n<strong>모든 InnoDB의 트랜잭션은 고유한 트랜잭션 번호(순차적으로 증가하는 값)를 가지며</strong>, 언두 영역에 백업된 모든 레코드에는 변경을 발생시킨 트랜잭션의 번호가 포함되어 있다<br>\n<strong>REPEATABLE READ 격리 수준</strong>에서는 <code class=\"language-text\">MVCC</code>를 보장하기 위해 실행중인 트랜잭션 가운데 가장 오래된 트랜잭션 번호보다 트랜잭션 번호가 앞선 언두 영역의 데이터는 삭제할 수 없다</p>\n<h3 id=\"phantom-read-문제\" style=\"position:relative;\">PHANTOM READ 문제<a href=\"#phantom-read-%EB%AC%B8%EC%A0%9C\" aria-label=\"phantom read 문제 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 851px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/db48263d3b0bb69d05bbbcd0e708b275/0fcea/phantomRead.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 100.8888888888889%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsTAAALEwEAmpwYAAACP0lEQVR42o2UyW4qQQxF+XIiFkEsWMCCP4A1sGUDEpMAiSEBITET5nmeB793SqoWgUBiyerqrqpr+/q6TYfDQabTqaxWK8Ov16v8xTg7m81kvV7LcrmU3W4nJhaRSEQajYbabLfbcjwe1QWAnzn29fUlsVhMxuOxDIdD6XQ6YgK1Wq1KqVSSXq8no9Ho1wxPp5Nst1sV/PPzU2q1mnS7XVksFmLSlwHSmWkjGEGIPBgMFDWUh/OdisiMtTYDcDKZfANk7fF45O3tTbnZbBaLxaLogTuo6vf78vHxobLTFBmA8ECDtLGGikKhINFoVPL5vORyOSkWi0YzKLnZbKoKHjIE8DZDvsPVfD5XFwDZ7/fqHN8AImC5XJZWq/WYITzQNS5A7mazEa/XK3a7XZxOpzgcDnG5XCpL7HK5GNTA40OGREmn0yoyUev1uiQSCQkGg+L3+yUQCChnT2eDnc9n1dAHQAimNMimQZSVzWZVE3w+n9JbOBz+Vt5LQNKGaPQFV5SCxuLxuGpKMplU4LcdfQmo9YbW9DjRlN/sKeB9l1/Z7fgR9Cmg1qG+AA3wiCNgZIJ8/lTyfYas3W63WK1Wsdlsyt/f3yUUCimOAYYeuv7j6P0EyMFKpaLkw0WcvxIZoQT2MpmM0u+DsDl0O3oA8kMAIJVKqUus0Sk/DRqHVqGCbw+ApH/fVaYBjjjDk33K1SXrstGwUTLRFv9FTETK0E8tH568M4rPTI+hAqRMZhdBMyVE5R3nHdf7z/7it/YP0Nzpl5TRk9gAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"phantomRead\"\n        title=\"\"\n        src=\"/static/db48263d3b0bb69d05bbbcd0e708b275/0fcea/phantomRead.png\"\n        srcset=\"/static/db48263d3b0bb69d05bbbcd0e708b275/3684f/phantomRead.png 225w,\n/static/db48263d3b0bb69d05bbbcd0e708b275/fc2a6/phantomRead.png 450w,\n/static/db48263d3b0bb69d05bbbcd0e708b275/0fcea/phantomRead.png 851w\"\n        sizes=\"(max-width: 851px) 100vw, 851px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p><strong>다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다가 안보였다가 하는 현상을 <code class=\"language-text\">PHANTOM READ(PHANTOM ROW)</code></strong> 라고한다.</p>\n<deckgo-highlight-code language=\"sql\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">CREATE TABLE employees (\n    id int NOT NULL,\n    first_name varchar(255) DEFAULT NULL,\n    last_name varchar(255) DEFAULT NULL,\n    PRIMARY KEY (id),\n    KEY idx_first_name (first_name)\n) ENGINE=InnoDB;\n\n+----+------------+-----------+\n| id | first_name | last_name |\n+----+------------+-----------+\n|  1 | John       | Doe1      |\n|  2 | John       | Doe2      |\n|  3 | John       | Doe3      |\n|  4 | John       | Doe4      |\n|  5 | Jane       | Ann1      |\n|  6 | Jane       | Ann2      |\n|  7 | Jane       | Ann3      |\n|  8 | Jack       | Tim1      |\n|  9 | Jack       | Tim2      |\n| 10 | Jack       | Tim3      |\n+----+------------+-----------+</code>\n        </deckgo-highlight-code>\n<p>위의 테이블로 테스트를 해보자.</p>\n<deckgo-highlight-code language=\"sql\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">-- &lt;트랜잭션 A&gt;\nset transaction_isolation = &#39;READ-COMMITTED&#39;;\nset autocommit=false;\n\nselect * from employees where id &gt;= 8 for update;\n-- 3 rows in set (0.01 sec)\n\n-- &lt;트랜잭션 B&gt;\nset transaction_isolation = &#39;READ-COMMITTED&#39;;\nset autocommit=false;\n\nSELECT OBJECT_NAME, INDEX_NAME, LOCK_TYPE, LOCK_MODE, LOCK_STATUS, LOCK_DATA FROM performance_schema.data_locks;\n+-------------+------------+-----------+---------------+-------------+-----------+\n| OBJECT_NAME | INDEX_NAME | LOCK_TYPE | LOCK_MODE     | LOCK_STATUS | LOCK_DATA |\n+-------------+------------+-----------+---------------+-------------+-----------+\n| employees   | NULL       | TABLE     | IX            | GRANTED     | NULL      |\n| employees   | PRIMARY    | RECORD    | X,REC_NOT_GAP | GRANTED     | 8         |\n| employees   | PRIMARY    | RECORD    | X,REC_NOT_GAP | GRANTED     | 9         |\n| employees   | PRIMARY    | RECORD    | X,REC_NOT_GAP | GRANTED     | 10        |\n+-------------+------------+-----------+---------------+-------------+-----------+\n\ninsert into employees(id, first_name, last_name) values (11, &#39;Test&#39;, &#39;Test1&#39; );\ncommit;\n-- Query OK, 1 row affected (0.03 sec)\n-- &lt;/트랜잭션 B&gt;\n\n-- &lt;트랜잭션 A&gt;\nselect * from employees where id &gt;= 8 for update;\n-- 4 rows in set (0.00 sec)</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">트랜잭션 A</code>의 <code class=\"language-text\">첫 번째 SELECT FOR UPDATE</code>와 <code class=\"language-text\">두 번째 SELECT FOR UPDATE</code>의 결과가 서로 다르다.<br>\n<strong><code class=\"language-text\">SELECT ... FOR UPDATE</code>, <code class=\"language-text\">SELECT ... LOCK IN SHARE MODE</code>는 레코드에 쓰기 잠금을 걸어야 하는데, 언두 레코드에는 잠금을 걸 수 없기 때문에 조회되는 레코드는 언두 영역의 변경 전 데이터를 가져오는 것이 아니라 현재 레코드의 값을 가져오게 되는 것이다.</strong><br>\n격리 수준을 REPETABLE-READ로 올려보고 테스트하면 아래와 같이 해결된다.</p>\n<deckgo-highlight-code language=\"sql\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">-- &lt;트랜잭션 B&gt;\nset transaction_isolation = &#39;REPEATABLE-READ&#39;;\nset autocommit=false;\nselect * from employees where id &gt;= 8 for update;\n-- 3 rows in set (0.00 sec)\n\n-- &lt;트랜잭션 A&gt;\nset transaction_isolation = &#39;REPEATABLE-READ&#39;;\nset autocommit=false;\n\nSELECT OBJECT_NAME, INDEX_NAME, LOCK_TYPE, LOCK_MODE, LOCK_STATUS, LOCK_DATA FROM performance_schema.data_locks;\n+-------------+------------+-----------+---------------+-------------+------------------------+\n| OBJECT_NAME | INDEX_NAME | LOCK_TYPE | LOCK_MODE     | LOCK_STATUS | LOCK_DATA              |\n+-------------+------------+-----------+---------------+-------------+------------------------+\n| employees   | NULL       | TABLE     | IX            | GRANTED     | NULL                   |\n| employees   | PRIMARY    | RECORD    | X,REC_NOT_GAP | GRANTED     | 8                      |\n| employees   | PRIMARY    | RECORD    | X             | GRANTED     | supremum pseudo-record |\n| employees   | PRIMARY    | RECORD    | X             | GRANTED     | 9                      |\n| employees   | PRIMARY    | RECORD    | X             | GRANTED     | 10                     |\n+-------------+------------+-----------+---------------+-------------+------------------------+\n\ninsert into employees(id, first_name, last_name) values (11, &#39;Test&#39;, &#39;Test1&#39; );\n-- 트랜잭션 B의 상한 락으로 인해 무한 대기\n\ninsert into employees(id, first_name, last_name) values (0, &#39;Test&#39;, &#39;Test1&#39; );\n-- 8 이후의 레코드에만 락이 걸려있기 때문에 id가 0인 레코드는 삽입이 바로 가능하다.</code>\n        </deckgo-highlight-code>\n<blockquote>\n<p>InnoDB 스토리지 엔진에서는 레크도 락과 갭 락을 결합한 <strong>넥스트 키 락</strong> 덕분에 <code class=\"language-text\">PHANTOM READ</code>문제가 발생하지 않는다.<br>\n즉, 한 세션이 인덱스의 <code class=\"language-text\">R</code>레코드 에 공유 또는 독점 잠금을 설정한 경우, <strong>다른 세션은 인덱스 순서에서 <code class=\"language-text\">R</code>레코드 바로 앞에 새 인덱스 레코드를 삽입할 수 없다.</strong></p>\n</blockquote>\n<p><code class=\"language-text\">select .. where id >= 8 for update;</code> 쿼리로 인해 <code class=\"language-text\">supremum pseudo-record</code> 락이 발생하였으며 <code class=\"language-text\">id</code>가 8 이후의 레코드에 대해서는 삽입을 할 수 없다.<br>\n즉, <strong>테이블에 존재하지 않는 항목을 '잠금'할 수 있다.</strong></p>\n<h2 id=\"serializable\" style=\"position:relative;\">SERIALIZABLE<a href=\"#serializable\" aria-label=\"serializable permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>가장 단순한 격리 수준이면서 동시에 가장 엄격한 격리 수준이다.<br>\n그만큼 동시 처리 성능도 다른 격리 수준에 비해 떨어진다.<br>\n위에서 말했던 **Non-Locking consistent read (잠금이 필요 없는 일관된 읽기)**를 지키지 않으며, <strong>읽기 작업도 공유 잠금(읽기 잠금)을 획득해야만 하며, 동시에 다른 트랜잭션은 접근하지 못한다.</strong></p>","frontmatter":{"title":"트랜잭션과 잠금","date":"February 13, 2024","description":null,"tags":["transaction","lock"]},"tableOfContents":"<ul>\n<li>\n<p><a href=\"#%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98\">트랜잭션</a></p>\n</li>\n<li>\n<p><a href=\"#mysql-%EC%97%94%EC%A7%84%EC%9D%98-%EC%9E%A0%EA%B8%88\">MySQL 엔진의 잠금</a></p>\n<ul>\n<li><a href=\"#%EA%B8%80%EB%A1%9C%EB%B2%8C-%EB%9D%BD\">글로벌 락</a></li>\n<li><a href=\"#%ED%85%8C%EC%9D%B4%EB%B8%94-%EB%9D%BD\">테이블 락</a></li>\n<li><a href=\"#%EB%84%A4%EC%9E%84%EB%93%9C-%EB%9D%BD\">네임드 락</a></li>\n<li><a href=\"#%EB%A9%94%ED%83%80%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%9D%BD\">메타데이터 락</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#innodb-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EC%97%94%EC%A7%84-%EC%9E%A0%EA%B8%88\">InnoDB 스토리지 엔진 잠금</a></p>\n<ul>\n<li><a href=\"#record-locks\">Record Locks</a></li>\n<li><a href=\"#gap-locks\">Gap Locks</a></li>\n<li><a href=\"#next-key-locks\">Next Key Locks</a></li>\n<li><a href=\"#auto-increment-locks\">Auto Increment Locks</a></li>\n<li><a href=\"#shared-and-exclusive-locks\">Shared and Exclusive Locks</a></li>\n<li><a href=\"#intention-locks\">Intention Locks</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#db-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EA%B2%A9%EB%A6%AC-%EC%88%98%EC%A4%80\">DB 트랜잭션 격리 수준</a></p>\n<ul>\n<li>\n<p><a href=\"#read-uncommited\">READ-UNCOMMITED</a></p>\n<ul>\n<li><a href=\"#dirty-read-%EB%AC%B8%EC%A0%9C\">Dirty Read 문제</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#read-committed\">READ-COMMITTED</a></p>\n<ul>\n<li><a href=\"#non-repeatable-read-%EB%AC%B8%EC%A0%9C\">NON-REPEATABLE READ 문제</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#repeatable-read\">REPEATABLE-READ</a></p>\n<ul>\n<li><a href=\"#phantom-read-%EB%AC%B8%EC%A0%9C\">PHANTOM READ 문제</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#serializable\">SERIALIZABLE</a></p>\n</li>\n</ul>\n</li>\n</ul>"},"previous":{"fields":{"slug":"/2023y/retrospect/"},"frontmatter":{"title":"2023년 회고"}},"next":{"fields":{"slug":"/2024y/postprocessor/"},"frontmatter":{"title":"빈 후처리기를 이용한 프록시 생성에 대해"}}},"pageContext":{"id":"099bd161-b615-5200-ab96-c2a0d6a8dfa3","previousPostId":"a81d0024-a600-58f9-9a17-cfc08d50ca78","nextPostId":"83e68652-9a78-5344-a893-30311c9782dd"}},"staticQueryHashes":["230163734","3589320610"],"slicesMap":{}}