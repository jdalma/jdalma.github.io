{"componentChunkName":"component---src-templates-blog-post-js","path":"/2024y/boyscoutRule/","result":{"data":{"site":{"siteMetadata":{"title":"코딩 주머니"}},"markdownRemark":{"id":"7dce3593-8c41-5f90-8f8e-647de2f14e32","excerpt":"The Boy Scout Rule : Always leave the campground cleaner than you found it…","html":"<blockquote>\n<p>The Boy Scout Rule : Always leave the campground cleaner than you found it.<br>\n<strong>보이 스카웃 규칙 : 언제나 처음 왔을 때보다 깨끗하게 해놓고 캠프장을 떠날 것.</strong></p>\n</blockquote>\n<p>엉클 밥이 설명한 <a href=\"https://www.oreilly.com/library/view/97-things-every/9780596809515/ch08.html\">보이스카웃 규칙</a>을 실천한 경험을 정리해보려 한다.<br>\n종립님이 정리한 <a href=\"https://johngrib.github.io/wiki/jargon/boy-scout-rule/\">글</a>을 읽어보길 추천한다.</p>\n<h1 id=\"실천하면서-느낀-점\" style=\"position:relative;\">실천하면서 느낀 점<a href=\"#%EC%8B%A4%EC%B2%9C%ED%95%98%EB%A9%B4%EC%84%9C-%EB%8A%90%EB%82%80-%EC%A0%90\" aria-label=\"실천하면서 느낀 점 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>NEXTSTEP의 코틀린 클린코드 교육을 듣고 클린코드 관련 서적 \"엘레강트 오브젝트\", \"내 코드가 그렇게 이상한가요?\", \"켄트 백의 구현 패턴\" 등을 읽게 되면서 깔끔한 코드를 작성하고 기존 코드를 청소하는 것에 관심을 가지게 되었다.<br>\n업무로 할당된 것도 아니고 누가 시키지도 않았지만 코드를 정리하는 리팩토링을 진행하면서 배운 점도 많고 재미도 느꼈다.</p>\n<h3>작업 범위를 결정하고 작업 종류를 분류하기</h3>  \n<ol>\n<li>작업 범위를 분석한다. 이때는 얕게 분석한다.</li>\n<li>그 범위에 해당하는 테스트를 작성한다.</li>\n<li>현재 테스트 범위에서 필요로 하는 의존성을 파악하여 필요한 의존성만 주입한다. 가능하다면 단위테스트로 해결한다.</li>\n<li>테스트를 진행하면서 코드를 제대로 분석한다.</li>\n<li>리팩토링 작업을 분류한다. 코드 정리인지? 동작을 변경해야 하는지? 둘 다 인지?</li>\n</ol>\n<p>이 작업을 하면서 불필요한 연산이나 논리적으로 잘못된 로직을 발견하는 경우가 많았다.<br>\n만약 동작을 변경해야 한다면 변경하기 전에 먼저 팀내에 공유하고 허락을 받았으며, 설득하기 위해 프론트나 데이터팀에게 협조를 요청하여 근거를 마련해야 할 필요도 있었다.</p>\n<h3>리팩토링 실천과 결과 공유의 순영향</h3>\n<p>이 작업을 할 때 재직한 회사는 테스트 코드가 없었고 코드리뷰, 컨벤션도 존재하지 않았다.<br>\n그렇기에 리팩토링 작업이 끝나면 항상 공유하는 자리를 만들어 <code class=\"language-text\">\"작업을 하계된 계기\"</code>, <code class=\"language-text\">\"변경된 내용\"</code>, <code class=\"language-text\">\"변경 후 효과\"</code>, <code class=\"language-text\">\"검증 방법\"</code> 들을 공유했다.</p>\n<p>리팩토링을 진행하면서 분석하고 설계한 자료를 다른 팀원들이 더 잘 이해하고 공감할 수 있도록 자료를 다듬고 질문에 대비하기 위한 조사들이 스스로에게 도움이 많이 되었다.<br>\n그리고 리팩토링에 대한 피드백을 받고 서로의 생각을 공유하는 자리를 통해 클린 코드에 대한 지식들이 팀원간 <code class=\"language-text\">싱크</code>되고 있다는 것을 느꼈다.<br>\n이 느낌 덕분에 리팩토링을 더 능동적으로 진행한 것 같다.</p>\n<h3>개인의 기준</h3>\n<p>리팩토링을 진행하면서 내가 생각하는 클린 코드에 대한 기준이 생기고 그 기준에 대한 근거를 스스로 확립해나갈 수 있었다.<br>\n아래는 작업하면서 메모한 내용들이다.</p>\n<ul>\n<li>\n<p>getter/setter에 비즈니스 로직이 들어가서 어떤 용도로 호출되는지 알 수가 없다. 직렬화/역직렬화할 때도 호출되어서 메서드를 리팩토링 하기 힘들다.</p>\n</li>\n<li>\n<p>한 가지의 용도로만 사용하거나 직렬화/역직렬화 규칙에 포함되지 않도록 메서드를 작성하는게 좋을 것 같다.</p>\n</li>\n<li>\n<p>어떤 setter가 명시적으로 한 곳에서 사용중이지만 해당 객체로 역직렬화하는 곳도 해당 setter가 호출되기 때문에 의도된 행위인지 파악하기 힘들다.</p>\n</li>\n<li>\n<p>getter에 필드를 갱신하는 로직이 들어가면 어떤 의미로 사용되는지 알기 힘들다. 최악은 해당 getter의 반환값을 사용하지 않으면서 getter를 호출하는 코드들이다.</p>\n</li>\n<li>\n<p>요청부터 응답까지 동일한 생명주기를 가진 객체가 있는데, 전반적인 연산 자체가 해당 객체의 속성들을 수정하는 기조이다. 그래서 어떤 메서드 호출 순서를 바꾸기 위해서는 서로 의존하고 있는 필드가 있는지 확인해야 하는 너무 큰 문제가 발생한다.</p>\n</li>\n<li>\n<p>레거시인 절차지향 코드들을 보면 가능한 DB 조회와 연산을 분리하려 한 것 같은 느낌이 있다. 대부분 이해가 안가는 코드들은 읽는 사람의 도메인 지식이 작성자와 싱크가 되지 않기 때문인 것 같다.</p>\n</li>\n<li>\n<p>반환 타입이 <code class=\"language-text\">Map</code>으로 작성된 경우가 많다. 유연하기 때문에 기존 작업자들이 많이 선택한 것 같은데, 이 정도의 유연함은 제어가 불가능하다. 이런 경우는 그 반환 타입만을 위한 클래스를 정의하였다.</p>\n</li>\n<li>\n<p>불변 객체를 참조하는 가변 필드와 가변 객체를 참조하는 불변 필드를 구분하여 객체의 변경 범위를 어디까지 정해야할지 고민해야 한다.</p>\n</li>\n</ul>\n<p>아래는 실천한 사례들을 정리해보았다.</p>\n<h1 id=\"라이브러리에-대한-의존성-제한하기\" style=\"position:relative;\">라이브러리에 대한 의존성 제한하기<a href=\"#%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%EC%97%90-%EB%8C%80%ED%95%9C-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A0%9C%ED%95%9C%ED%95%98%EA%B8%B0\" aria-label=\"라이브러리에 대한 의존성 제한하기 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 900px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/1ca94fb4d7ee01e7ade74f46d99e3ede/f02b9/before1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 27.999999999999996%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAABLklEQVR42j1R7ZKCMBDj/Z/MP6DgjINCW4SRAsenCAgKue163s4sbFOaJsHCXxVFAdd14XkefN9HGIYYhoH31nVF3/e43++QUkIIwbPB3u83tm3jNmWZxzRNaJqGgWVZoHWGPM/5cNd1yLIMSZIwXpYV2rZlLI4/mKnn88m4ZZjHcYTjODidTqiqCkHg43h0EUWS11EUEVGBItf8llJgv7dxODg4n8/8jVKKZ8soSdMUu90Otm3TjTmiawd1rXG55GTNKKwhZIU46XCNG1IyQkUVQlHS5Qn1hSMyLv8VGmtseV6RFit+ekDFEzKtiahB3W2YXkBZv0jAgKIFdL0hEBXluODxGD6EhmSeZ1b57TC8kbqUrJp8Ngr/ASU1KbmRtZRzM3MQaNT1R8j3p/wCxuLBf5ySqGIAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"before1\"\n        title=\"\"\n        src=\"/static/1ca94fb4d7ee01e7ade74f46d99e3ede/1cfc2/before1.png\"\n        srcset=\"/static/1ca94fb4d7ee01e7ade74f46d99e3ede/3684f/before1.png 225w,\n/static/1ca94fb4d7ee01e7ade74f46d99e3ede/fc2a6/before1.png 450w,\n/static/1ca94fb4d7ee01e7ade74f46d99e3ede/1cfc2/before1.png 900w,\n/static/1ca94fb4d7ee01e7ade74f46d99e3ede/21482/before1.png 1350w,\n/static/1ca94fb4d7ee01e7ade74f46d99e3ede/f02b9/before1.png 1554w\"\n        sizes=\"(max-width: 900px) 100vw, 900px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>검색 서비스에 의존하는 서비스들의 클라이언트 코드들이 위의 그림과 같이 응답으로 받는 ElasticSearch의 <code class=\"language-text\">SearchResponse</code>에 직접 의존하는 것을 확인했다.</p>\n<deckgo-highlight-code language=\"java\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">val searchResponse = searchService.search(...)\nif (searchResponse == null || \n    searchResponse.failedShards &gt; 0 || \n    searchResponse.hits.totalHits == 0) {\n   // 검색 실패 로직\n}</code>\n        </deckgo-highlight-code>\n<p>위와 같이 클라이언트 코드에서 <code class=\"language-text\">failedShards</code>, <code class=\"language-text\">hits.totalHits</code> 필드들에 직접 의존하고 있어 엘라스틱서치의 클라이언트 의존성 버전 변경에 굉장히 민감해질 수 밖에 없다.<br>\n그리고 검색에 실패한 경우와 실패했을 때의 처리를 클라이언트 코드에서 직접 구분하고 있었기에 클라이언트는 <code class=\"language-text\">SearchResponse</code>에 너무 많은 정보를 알고 있었고 비슷한 코드가 여러 곳에서 반복되고 있었다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 900px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/c10543874b2b82b1afd258676a907a3c/f349c/usingSearchResponse.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 24.444444444444443%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA6klEQVR42pWO226DQAxE+REKyy7ZCxTKbUkEDQ0JEKjUVsr/f8vU0EjNQ1/6cOQZ2xrbMVJCaQOpo41QaigTIxA7uB7Dkx/8C0dSoJDqt8n4Dz7bcKnn3mfrgb+OPO44gj4K6UMVxzBJAqE1fAr0mYAXiLvm8MgzvgMLQtL8AYGAglZW7WilEZsIaV6grA8YpgUjcX3/wrR8YhwXzOSn+QOny4zm2KPat8QrMtviWFjcigK3qsRsazicCwrU0NEzjErQnc+4DCP604C2v+KtH3FoOmRFjZe8QppVVO1GSj7PSjRZjq6y2JcW3+fGlsbxStoXAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"usingSearchResponse\"\n        title=\"\"\n        src=\"/static/c10543874b2b82b1afd258676a907a3c/1cfc2/usingSearchResponse.png\"\n        srcset=\"/static/c10543874b2b82b1afd258676a907a3c/3684f/usingSearchResponse.png 225w,\n/static/c10543874b2b82b1afd258676a907a3c/fc2a6/usingSearchResponse.png 450w,\n/static/c10543874b2b82b1afd258676a907a3c/1cfc2/usingSearchResponse.png 900w,\n/static/c10543874b2b82b1afd258676a907a3c/21482/usingSearchResponse.png 1350w,\n/static/c10543874b2b82b1afd258676a907a3c/d61c2/usingSearchResponse.png 1800w,\n/static/c10543874b2b82b1afd258676a907a3c/f349c/usingSearchResponse.png 2002w\"\n        sizes=\"(max-width: 900px) 100vw, 900px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>이 검색 클라이언트 의존성을 격리시키면서 클라이언트 코드가 검색 결과에 따라 원하는 행위를 지정하도록 할 수 있는 방법은 없을까?<br>\n클라이언트가 원하는 검색에 실패하였을 떄의 처리</p>\n<ol>\n<li>빈 검색 결과 객체를 반환하거나</li>\n<li>null을 반환하거나</li>\n<li>예외를 던지거나</li>\n</ol>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">sealed class ResponseResult&lt;out T&gt; {\n\n    data class Success&lt;out T&gt;(val body: T): ResponseResult&lt;T&gt;()\n    data class Failure(val errorResponse: ErrorResponse): ResponseResult&lt;Nothing&gt;()\n\n    val isSuccess: Boolean\n        get() = this is Success\n    val isFailure: Boolean\n        get() = this is Failure\n\n    inline fun onSuccess(action: (T) -&gt; Unit): ResponseResult&lt;T&gt; {\n        if (this is Success) {\n            action(body)\n        }\n        return this\n    }\n\n    inline fun onFailure(action: (ErrorResponse) -&gt; Unit): ResponseResult&lt;T&gt; {\n        if (this is Failure) {\n            action(errorResponse)\n        }\n        return this\n    }\n\n    fun getOrNull(): T? = if (this is Success) body else null\n\n    inline fun getOrThrow(exception: () -&gt; Nothing): T {\n        return when (this) {\n            is Success -&gt; body\n            is Failure -&gt; exception()\n        }\n    }\n\n    inline fun &lt;R&gt; getOrDefault(default: R): R {\n        return when (this) {\n            is Success -&gt; body\n            is Failure -&gt; default\n        }\n    }\n}\n\ndata class ErrorResponse(\n    val message: String,\n    val code: CustomError,\n    val status: HttpStatus\n)</code>\n        </deckgo-highlight-code>\n<p><a href=\"https://tech.kakaopay.com/post/make-http-client-design-flexible/#%EA%B0%81%EA%B8%B0-%EB%8B%A4%EB%A5%B8-%EB%B9%84%EC%A6%88%EB%8B%88%EC%8A%A4-%EC%9A%94%EA%B5%AC%EC%82%AC%ED%95%AD%EC%97%90-%EB%A7%9E%EA%B2%8C-%EC%9C%A0%EC%97%B0%ED%95%9C-%ED%95%B8%EB%93%A4%EB%A7%81-%EC%A7%80%EC%9B%90\">MSA 환경에서의 유연한 HTTP 클라이언트 설계 전략</a>을 참고하여 이 문제를 해결할 수 있었다.<br>\n간략하게 설명하자면 <code class=\"language-text\">ResponseResult</code> 추상 클래스를 상속하는 <code class=\"language-text\">Success</code>와 <code class=\"language-text\">Failure</code> 클래스를 통해 HTTP 통신 결과에 따라 클라이언트 코드가 원하는 행위를 지정할 수 있도록 도와주는 클래스이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 900px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/287d55030171a22736ff2ee7fb54c446/f02b9/refactor1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 27.999999999999996%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAABM0lEQVR42j2R63KCMBCFef8n8w8odGpFSKAgCTDcEVBUTjdr251JsjmQk283Fn6jLEu4rgvP83A6nRCGIaZp4m+v1wvjOGIYBkgpIYTg3GjP5xPbtvEwYZlpWRa0bcvCuq7I8xxFUfDhvu95n6YptM5RVTW6rmMtSd6aidvtxrplnOd5huM4OB6PqOsa/vkMj2ijOOJ9HMdkVKIsNK9SCuz3Ng4HB77v8z9RFHFuGRKlFHa7HWzbRqHp0OcXtOMi8z4wDj103kDIGkna4ztpiWSmy2qEokIQpDTO3CJT5T+hKY37RehTVlF/gFZcUKoLGXVo+g3LA6iaBwFMKDtANxsCUVMfV1yv09vQmNzvd6ZURKeyDBmVrOhh8kjyJeN4RSQ1kWRUmuK+mTwINJrmDfL3KD91/cET6pxlEgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"refactor1\"\n        title=\"\"\n        src=\"/static/287d55030171a22736ff2ee7fb54c446/1cfc2/refactor1.png\"\n        srcset=\"/static/287d55030171a22736ff2ee7fb54c446/3684f/refactor1.png 225w,\n/static/287d55030171a22736ff2ee7fb54c446/fc2a6/refactor1.png 450w,\n/static/287d55030171a22736ff2ee7fb54c446/1cfc2/refactor1.png 900w,\n/static/287d55030171a22736ff2ee7fb54c446/21482/refactor1.png 1350w,\n/static/287d55030171a22736ff2ee7fb54c446/f02b9/refactor1.png 1554w\"\n        sizes=\"(max-width: 900px) 100vw, 900px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<blockquote>\n<p>사실 검색 서비스에서 검색 결과를 <code class=\"language-text\">ByteArrayInputStream</code>으로만 응답해줄 것이 아니라 <strong>\"검색 서비스를 필요로 하는 서비스\"들에게 <code class=\"language-text\">SearchResponse</code> 타입을 전혀 몰라도 검색 결과를 알 수 있도록 <code class=\"language-text\">규격화된 응답 객체</code>를 전송해야 마땅하다.</strong><br>\n하지만 검색 서비스 API 응답을 수정하는 작업은 해당 API를 사용하는 클라이언트에 대한 확인이 필요하여 작업 범위가 크다고 판단하였으며, 이번에 <code class=\"language-text\">ResponseResult</code>를 사용하여 의존성을 격리시킨다면 추후에 <code class=\"language-text\">SearchResponse</code> 의존성을 제거하는 것은 쉬울 것이므로 수정 범위를 이 정도로만 정했다.</p>\n</blockquote>\n<p>어떻게 적용하였는지 예제 코드를 확인해보자.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">// Unirest 응답 타입 전용 확장함수\nfun HttpResponse&lt;SearchResponse&gt;.responseResult(): ResponseResult&lt;Document&gt; {\n    return when (\n        this.isSuccess &amp;&amp; \n        this.body != null &amp;&amp; \n        this.body.failedShards == 0 &amp;&amp; \n        this.body.hits.hits.isNotEmpty()\n    ) {\n        true -&gt; {\n            val body = defaultMapper.readValue(hit.sourceAsString, Document::class.java)\n            ResponseResult.Success(body)\n        }\n        false -&gt; ResponseResult.Failure(\n            ErrorResponse(\n                &quot;외부 통신 실패&quot;, \n                CommonError.ERROR, \n                HttpStatus.INTERNAL_SERVER_ERROR\n            )\n        )\n    }\n}\n\n// UnirestInstance 요청 결과인 응답을 (확장함수를 사용하여) ResponseResult로 래핑\nfun searchResponseResult(...): ResponseResult&lt;Document&gt; {\n   return unirestInstance.post(url)\n      .cookie(cookie)\n      .routeParam(&quot;cluster&quot;, cluster)\n      .body(body)\n      .asObject&lt;SearchResponse&gt; { raw: RawResponse -&gt;\n         // 검색 서비스에서 응답받은 Stream을 SearchResponse로 변환\n      }\n      .responseResult()\n}\n\n// ResponseResult를 반환받아 클라이언트 코드에서 행위를 지정할 수 있다.\n// 1. 검색에 실패하였다면 null을 반환한다.\nval document = searchService.searchResponseResult(...).getOrNull()\n\n// 2. 검색에 실패하였다면 지정한 예외를 던진다.\nval document = searchService.searchResponseResult(...).getOrThrow {\n   throw DocumentNotFoundException(...)\n}\n\n// 3. 검색에 실패하였다면 지정한 기본값을 반환한다.\nval document = searchService.searchResponseResult(...).getOrDefault(::EmtyDocument)</code>\n        </deckgo-highlight-code>\n<p>이제부터는 격리시키고 싶은 의존성이 있다면 <code class=\"language-text\">ResponseResult</code>로 래핑하는 확장함수를 추가하면 된다.<br>\n그리고 클라이언트가 통신 결과에 따라 유연하게 람다를 지정하여 호출할 수 있어 클라이언트 코드가 불필요한 의존성을 알아야 할 필요가 없어졌다.</p>\n<h1 id=\"공통-기능을-모아놓은-빈-제거하기\" style=\"position:relative;\">공통 기능을 모아놓은 빈 제거하기<a href=\"#%EA%B3%B5%ED%86%B5-%EA%B8%B0%EB%8A%A5%EC%9D%84-%EB%AA%A8%EC%95%84%EB%86%93%EC%9D%80-%EB%B9%88-%EC%A0%9C%EA%B1%B0%ED%95%98%EA%B8%B0\" aria-label=\"공통 기능을 모아놓은 빈 제거하기 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>폴더 구조를 가지는 기능을 가진 서비스가 있다.<br>\n어떤 정보들을 프로젝트안에 존재하는 폴더에 저장하는 기능이다. 즉, <strong>한 개의 프로젝트에 N개의 폴더를 생성할 수 있으며 각 폴더에 N개의 정보를 저장하는 것이다.</strong></p>\n<ol>\n<li>한 프로젝트의 모든 폴더를 조회하는 API</li>\n<li>한 프로젝트 안에 폴더를 생성하고 해당 폴더를 조회하는 API</li>\n</ol>\n<p>이 두 개의 웹 API가 아래와 같은 의존도를 가지고 있었다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 900px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/799bda9f2dea5e27d16211b78f3071e5/b962a/commonBeanDeleteBefore.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 51.11111111111111%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABfklEQVR42m2S63LaMBCF8xIdQkBYtuQLtsCA7zaU5nem0/d/mtOzik0zKT/O7I5W+2n32C87HeG7VKCR5iXqtqU6tP2AhjHLHXRkEdkEh+qCqml53qPrR+TuiOl2x8tzYAibFnBlifJcETiiqluYOEWgjYemzsEdS5wvNU5UnO4J/PkcuEA3KoBiHhKgQwO10wRGXlvmUl/u/litMV4JlPU2iuIFf2mOCzg0MUySIbAxdgRvebZmXc11WV8mfn3bYhKgzQrsC0cd5uiQ7nMPEkmDYawYR1dgOhwwZhmyiBNzajMDVwvweGnRDSP6YfKS/EK/LKcSyXQxm9/54Eff4fcw4E9d4WQslFhBBQQ/Jly8+C7xRSQN8jFCQiPmltPq2QrRf0DxQQ4eEm8YF7OlQXIdcX0Bc0U113df6qv15h/wuTiRTeln4SXefn1Yc+UoSZDtnf9l1hv1+ZWfw0I2WZybnq/ecOX/VTedn2ZZM8kLNNPoa/f7L54ZDNMNfwGFQiGWksqujAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"commonBeanDeleteBefore\"\n        title=\"\"\n        src=\"/static/799bda9f2dea5e27d16211b78f3071e5/1cfc2/commonBeanDeleteBefore.png\"\n        srcset=\"/static/799bda9f2dea5e27d16211b78f3071e5/3684f/commonBeanDeleteBefore.png 225w,\n/static/799bda9f2dea5e27d16211b78f3071e5/fc2a6/commonBeanDeleteBefore.png 450w,\n/static/799bda9f2dea5e27d16211b78f3071e5/1cfc2/commonBeanDeleteBefore.png 900w,\n/static/799bda9f2dea5e27d16211b78f3071e5/21482/commonBeanDeleteBefore.png 1350w,\n/static/799bda9f2dea5e27d16211b78f3071e5/d61c2/commonBeanDeleteBefore.png 1800w,\n/static/799bda9f2dea5e27d16211b78f3071e5/b962a/commonBeanDeleteBefore.png 2465w\"\n        sizes=\"(max-width: 900px) 100vw, 900px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>위의 다이어그램을 보면 의아한 점이 생긴다.</p>\n<ol>\n<li><strong>ProjectFolderService와 FolderService, ProjectFolderMapper와 FolderMapper의 차이는 뭘까?</strong>\n<ul>\n<li>ProjectFolder와 Folder를 분리할 필요가 없고 동일한 관심사를 가지고 있다고 판단되었다.</li>\n</ul>\n</li>\n<li><strong>CommonUtils는 어떤 공통 기능을 가졌을까?</strong>\n<ul>\n<li>폴더의 재귀 구조를 생성해주는 기능이 구현되어 있었다.</li>\n<li>서로 같은 관심사를 가진 두 개의 Service가 존재하게 되면서 중복되는 코드를 CommonUtils라는 스프링 빈으로 몰아넣어져 있었다.</li>\n<li>이 공통 기능을 가진 빈은 다시 Mapper를 필요로 한다.</li>\n</ul>\n</li>\n</ol>\n<p>공통 기능을 가진 스프링 빈은 의존성을 분리하는 이점이 있긴 하지만 OOP에 전혀 도움이 되지 않으며, 깨진 창문처럼 더 더러워지기 쉬운 이름을 가져서 어정쩡한 책임을 쉽게 추가하기 좋은 클래스이다.<br>\n<code class=\"language-text\">CommonUtils</code> 라는 이름은 죄책감을 가지지 않고 기능을 추가하기 딱 좋은 이름이지 않나?</p>\n<p>결론은 <strong>한 개의 관심사이지만 분리된 책임을 한 곳으로 모으고, 공통 기능을 수행하는 객체를 생성하기로 했다.</strong></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 900px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/6496fa019901870a4a6811825992d459/36563/commonBeanDeleteAfter.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 36%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAABDElEQVR42p2Py26DMBRE+YiqQg3mjWMIBltJSDDYhEZNH1I33fT/v2TquO0irZRFFiNL947PzPXCOMVVJTkKVoGyEstyhYKyf54oyeA/BBj0BO8ajEQJkoxhPx4wzzNOp2coNTjATcBf+STEIkqdfBKB3NzQKrUt+4JiEgKzlNhmGfIovoBeAIMwxsKm/tV5TqwxDwjeucDHqPCpNY5FAWYbB3ZHfv6evXf3PtSo4dGyBrfpvBVohERzfluJquYuOc2X2G879OsNpJ0J3tgZdTvGufO3cg1WVng8PsFbic6SDUb9rcGmaDOh2/XI8gK0arFRxqUP5mDPMiir2kGF2kHpEWaa0asRL69v+ALJCc16FjnAIgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"commonBeanDeleteAfter\"\n        title=\"\"\n        src=\"/static/6496fa019901870a4a6811825992d459/1cfc2/commonBeanDeleteAfter.png\"\n        srcset=\"/static/6496fa019901870a4a6811825992d459/3684f/commonBeanDeleteAfter.png 225w,\n/static/6496fa019901870a4a6811825992d459/fc2a6/commonBeanDeleteAfter.png 450w,\n/static/6496fa019901870a4a6811825992d459/1cfc2/commonBeanDeleteAfter.png 900w,\n/static/6496fa019901870a4a6811825992d459/21482/commonBeanDeleteAfter.png 1350w,\n/static/6496fa019901870a4a6811825992d459/d61c2/commonBeanDeleteAfter.png 1800w,\n/static/6496fa019901870a4a6811825992d459/36563/commonBeanDeleteAfter.png 2023w\"\n        sizes=\"(max-width: 900px) 100vw, 900px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>CommonUtils가 수행하던 기능을 (여러 FolderEntity를 대표하는) <code class=\"language-text\">Folders</code>라는 객체가 책임을 가지도록 수정하였다.<br>\n즉, 영속성 계층에서 조회한 결과로 <strong><code class=\"language-text\">폴더들</code>을 조작하는 책임</strong>을 가진 객체를 추가하여 CommonUtils를 대신하였다.</p>\n<h1 id=\"절차지향-메소드를-객체함수로-분리하여-책임-분리하기\" style=\"position:relative;\">절차지향 메소드를 객체,함수로 분리하여 책임 분리하기<a href=\"#%EC%A0%88%EC%B0%A8%EC%A7%80%ED%96%A5-%EB%A9%94%EC%86%8C%EB%93%9C%EB%A5%BC-%EA%B0%9D%EC%B2%B4%ED%95%A8%EC%88%98%EB%A1%9C-%EB%B6%84%EB%A6%AC%ED%95%98%EC%97%AC-%EC%B1%85%EC%9E%84-%EB%B6%84%EB%A6%AC%ED%95%98%EA%B8%B0\" aria-label=\"절차지향 메소드를 객체함수로 분리하여 책임 분리하기 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>사용자 회원가입의 검증 로직에 탈퇴한 ID와 동일하다면 회원가입이 되지 않도록 조건을 추가해야 하는 간단한 작업을 해야했다.<br>\n기존에 작성되어 있던 회원가입 검증 로직을 보고 그냥 조건문 추가하면 해결되었겠지만.. 냄새나는 코드 작성에 일조하기가 싫어서 코드 정리를 결심했다.<br>\n먼저 문제점을 확인해보자.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">@Service\nclass UserRegisterService(\n    private val userRegisterMapper: UserRegisterMapper,\n    ...\n) {\n\n   fun validationCheck(userDataList: List&lt;UserDataVO&gt;): Map&lt;String, Any&gt; {\n      val userIdList = userDataList.map { it.userId }\n      var errorReason = &quot;&quot;;\n      val validationError = mutableMapOf&lt;String, MutableSet&lt;String&gt;&gt;()\n\n      val userExistList = userRegisterMapper.selectExistId(userIdList).toMutableSet()\n      if (userExistList.isNotEmpty()) {\n         // 동일한 아이디가 이미 존재하면 errorReason에 에러 메세지를 누적하고, 동일한 아이디들을 validationError에 누적한다.\n      }\n\n      val companyIdExist = userRegisterMapper.selectExistCompanyId(userDataList[0].companyId)\n      if (companyIdExist.isNullOrEmpty()) {\n         // 회사 코드가 존재하지 않으면 errorReason에 에러 메세지를 누적하고, 회사 ID를 validationError에 누적한다.\n      }\n\n      val validationErrorValue = mutableSetOf&lt;String&gt;()\n      userDataList.forEach {\n         for (validation in RegisterValidation.values()) {\n               // enum으로 정의된 회원가입시 기입해야할 필드들을 리플렉션을 통해 객체의 필드를 순회하여 해당하는 정보를 조회한다.\n               val property =\n                  it::class.members.first { value -&gt; value.name == validation.key } as KProperty1&lt;UserDataVO, Any&gt;\n\n               val value = property.get(it) as String?\n               if (!expCheck(value, validation)) {\n                  // 조회된 정보를 정규표현식을 통하여 검증한다.\n                  // 정규표현식을 통과하지 못하면 validationErrorValue와 validationError에 정보를 누적한다.\n               }\n         }\n      }\n      errorReason += &quot;생성 규칙에 안맞는 데이터 입니다 : $validationErrorValue&quot;\n      return mapOf(&quot;error&quot; to validationError, &quot;reason&quot; to errorReason)\n   }\n   ...\n}\n\nenum class RegisterValidation(val key: String, val required: Boolean, val regex: String) {\n    USERID(&quot;userId&quot;, true, &quot;...&quot;),\n    PASSWORD(&quot;password&quot;, true, &quot;...&quot;),\n    EMAIL(&quot;email&quot;, true, &quot;...&quot;),\n    MOBILE(&quot;mobile&quot;, true, &quot;...&quot;),\n    LEVEL(&quot;level&quot;, true, &quot;...&quot;),\n    TYPE(&quot;type&quot;, true, &quot;...&quot;),\n    STATUS(&quot;status&quot;, true, &quot;...&quot;),\n    COMPANYMOBILE(&quot;companyMobile&quot;, false, &quot;...&quot;)\n}</code>\n        </deckgo-highlight-code>\n<ol>\n<li>각 검증마다 검증 결과를 누적하고 공유되고 있는 <code class=\"language-text\">errorReason</code>, <code class=\"language-text\">validationError</code>, <code class=\"language-text\">validationErrorValue</code> 필드</li>\n<li>사용자 회원가입 정보가 담겨있는 <code class=\"language-text\">UserDataVO</code> 객체의 정의된 필드를 검증 마다 매번 순회</li>\n<li>사용자 필드별 정규표현식을 가지는 <code class=\"language-text\">RegisterValidation</code> enum의 필드를 검증하는 관심사가 Service에 존재</li>\n</ol>\n<p>위 3개의 문제점을 발견하여 코드 정리를 진행했다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">@Service\nclass UserRegisterValidationService(\n    private val userRegisterMapper: UserRegisterMapper\n) {\n\n    private val validationTasks: List&lt;KFunction1&lt;List&lt;UserDataVO&gt;, RegisterUserValidationResult?&gt;&gt; = listOf(\n        ::userIdDuplicateValidation,\n        ::dropUserIdValidation,\n        ::companyIdValidation\n    )\n\n    fun validationCheck(registerUsers: List&lt;UserDataVO&gt;): RegisterUserValidationResultVO {\n        val registerUserValidationResults = validationTasks.mapNotNull { it(registerUsers) }\n        val registerUserFieldValidationResult = RegisterUserFieldValidation.validate(registerUsers)\n\n        return RegisterUserValidationResultVO(\n            errorDataCombine(...),\n            errorReasonCombine(...)\n        )\n    }\n   \n    ...\n}\n\nenum class RegisterUserFieldValidation (\n    private val property: KProperty1&lt;UserDataVO, String?&gt;,\n    private val required: Boolean,\n    private val regex: String\n) {\n\n    USERID(UserDataVO::userId, true, &quot;...&quot;),\n    PASSWORD(UserDataVO::password, true, &quot;...&quot;),\n    EMAIL(UserDataVO::email, true, &quot;...&quot;),\n    MOBILE(UserDataVO::mobile, true, &quot;...&quot;),\n    LEVEL(UserDataVO::level, true, &quot;...&quot;),\n    TYPE(UserDataVO::type, true, &quot;...&quot;),\n    STATUS(UserDataVO::status, true, &quot;...&quot;),\n    COMPANYMOBILE(UserDataVO::companyMobile, false, &quot;...&quot;);\n\n    companion object {\n        fun validate(registerUsers: List&lt;UserDataVO&gt;): RegisterUserValidationResultVO {\n            val errorData = // UserDataVO를 순회하며 registerUsersValidate를 통한 검증 결과 누적\n\n            if (errorData.isEmpty()) {\n                return RegisterUserValidationResultVO(emptyMap(), emptyList())\n            }\n\n            val errorReason = ValidationErrorReason(ValidationMessage.REG_EXP_VALIDATION_FAIL, errorData.values)\n            return RegisterUserValidationResultVO(\n                errorData,\n                listOf(errorReason.convertMessage())\n            )\n        }\n\n        private fun registerUsersValidate(registerUsers: List&lt;UserDataVO&gt;, fieldValidation: RegisterUserFieldValidation): ValidationErrorData? {\n            val values = // 필드 검증\n\n            return if (values.isEmpty()) null else ValidationErrorData(fieldValidation.property.name, values)\n        }\n    }\n}\n\nenum class ValidationMessage(private val description: String) {\n    DUPLICATE_ID(&quot;아이디가 이미 존재합니다. : %s&quot;),\n    DROP_ID(&quot;탈퇴한 아이디가 존재합니다. : %s&quot;),\n    NOT_EXIST_COMPANY_ID(&quot;존재하지 않는 회사입니다. : %s&quot;),\n    REG_EXP_VALIDATION_FAIL(&quot;생성 규칙에 맞지 않은 데이터입니다. : %s&quot;);\n\n    fun convert(data: Collection&lt;Any&gt;) = this.description.format(data.toString())\n}</code>\n        </deckgo-highlight-code>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 900px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/3c33170bc9b7bbc6598ee42c18c460a9/0907e/refactor2.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 28.444444444444443%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAABCUlEQVR42l2Ra07DMBCEfQV+FFTUxO84SWPH6bsgcQ8OwvmHXVNHFT9Gir27n2c2opEarFaZVfKhlu5DCJjzAaEfsWvVqv8zVcL5AOs6Gjao8Hdl8UZn6QJyzrhc70h5gQsDYpqR5gW+61fws8Tt/oHlcII2FvYBX6TEZ9NgYqfWgx/tyOEwRkwE3MdUHGuuEbhKGQdxvt5Kg/eeoi2Iccb3bouf7QZfBH2lV6W2MOR2mlKJH+dcAP2wpwR0ThkTzbEhwcWRGhtyU/ezUQ4v2mFLd945ipsLiPuM7wswL8cCMpTID2P55rqokOefoUi6nrWBoWg8qCmSJeDxfAGvinfJ7rV1f3Xr8QvGaK04I+ZVbQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"refactor2\"\n        title=\"\"\n        src=\"/static/3c33170bc9b7bbc6598ee42c18c460a9/1cfc2/refactor2.png\"\n        srcset=\"/static/3c33170bc9b7bbc6598ee42c18c460a9/3684f/refactor2.png 225w,\n/static/3c33170bc9b7bbc6598ee42c18c460a9/fc2a6/refactor2.png 450w,\n/static/3c33170bc9b7bbc6598ee42c18c460a9/1cfc2/refactor2.png 900w,\n/static/3c33170bc9b7bbc6598ee42c18c460a9/21482/refactor2.png 1350w,\n/static/3c33170bc9b7bbc6598ee42c18c460a9/d61c2/refactor2.png 1800w,\n/static/3c33170bc9b7bbc6598ee42c18c460a9/0907e/refactor2.png 3788w\"\n        sizes=\"(max-width: 900px) 100vw, 900px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>대략적인 코드 정리 결과물이다. 이 작업을 통해 어떤 점이 개선되었을까?</p>\n<ol>\n<li>사용자 유효성 검증을 진행하는 함수들을 List로 묶어서 각 검증 결과 DTO를 반환하도록 수정하여 추가가 수월해졌다.</li>\n<li>사용자 유효성 검증과 회원가입 필드 유효성 검증을 구분하여 관심사를 분리하였다. 예를 들어, 정규표현식을 보유하고만 있던 Enum에게 직접 유효성 검증을 하도록 책임을 부여하였다.</li>\n<li>UserDataVO 객체의 필드를 리플렉션으로 순회하는 부분을 제거하고 각 정규표현식이 관심가지는 UserDataVO의 필드를 직접 매핑하였다.</li>\n<li>각 단계별 검증 반환 DTO를 추가하여 검증 결과를 누적하기 위해 사용하던 변수들을 제거하였다.</li>\n<li>검증 실패 메시지를 Enum으로 분리하였다.</li>\n</ol>\n<h1 id=\"결론\" style=\"position:relative;\">결론<a href=\"#%EA%B2%B0%EB%A1%A0\" aria-label=\"결론 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>스스로가 만든 작업 범위에서 <code class=\"language-text\">분석 → 설계 → 개발 → 공유</code>를 통해 많은 것을 배웠다.<br>\n그리고 리팩토링이 쉬운 작업이 아니라는 것을 확실히 느꼈다.</p>\n<ol>\n<li>기존 코드를 완벽하게 분석하여 이해하고</li>\n<li>이 작업이 어디까지 영향을 끼치는지 확인하여 작업 범위를 스스로 결정하고</li>\n<li>코드 정리인지, 동작 변경인지 분류하여</li>\n<li>설계,개발하여 검증하고</li>\n<li>작업 결과를 공유하기 위한 준비를 해야한다.</li>\n</ol>\n<p>그래도 힘든만큼 보람도 있었으며, 교육을 듣거나 책을 여러 권 읽는 것보다 직접 실천하며 부딪히며 배우는 것이 훨씬 더 머리에 쉽게 각인되었다.<br>\n거기에다가 배운 것을 바로 써먹을 수 있는 기회까지 만들어 갈 수 있으니 쉬운 업무를 할당받거나 조금 더 도전적인 업무를 통해 성취감을 느끼고 싶다면 꼭 도전해보길 바란다.</p>\n<p><strong>클린 코드는 기계적인 원칙이 아닌 탐색의 결과이고 완성은 없다.</strong></p>\n<blockquote>\n<p>\"좋은 코드가 상업적 성공에 필수적인 부분은 아니다. 조잡한 코드로 돈을 많이 버는 사례가 있다고 할지라도, 나는 여전히 코드 품질이 매우 중요하다고 믿는다.\"<br>\n\"기능을 개발하고 출시하며, 기회와 경쟁 상황에 따라 개발 방향을 바꿀 수 있으며 위기 속에서도 직원들의 사기를 높일 수 있는 회사는 조잡하고 버그가 있는 코드를 작성하는 회사에 비해 성공할 확률이 높다.\"<br>\n<strong>\"설사 좋은 코딩이 장기적으로 경제적 이득을 가져오지 못한다고 하더라도 나는 여전히 내가 작성할 수 있는 최고의 코드를 작성할 것이다.\"</strong></p>\n<ul>\n<li>켄트 백의 구현 패턴 중</li>\n</ul>\n</blockquote>","frontmatter":{"title":"보이스카웃 규칙 실천하기","date":"May 25, 2024","description":null,"tags":["Refactoring","Cleancode"]},"tableOfContents":"<ul>\n<li><a href=\"#%EC%8B%A4%EC%B2%9C%ED%95%98%EB%A9%B4%EC%84%9C-%EB%8A%90%EB%82%80-%EC%A0%90\">실천하면서 느낀 점</a></li>\n<li><a href=\"#%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%EC%97%90-%EB%8C%80%ED%95%9C-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A0%9C%ED%95%9C%ED%95%98%EA%B8%B0\">라이브러리에 대한 의존성 제한하기</a></li>\n<li><a href=\"#%EA%B3%B5%ED%86%B5-%EA%B8%B0%EB%8A%A5%EC%9D%84-%EB%AA%A8%EC%95%84%EB%86%93%EC%9D%80-%EB%B9%88-%EC%A0%9C%EA%B1%B0%ED%95%98%EA%B8%B0\">공통 기능을 모아놓은 빈 제거하기</a></li>\n<li><a href=\"#%EC%A0%88%EC%B0%A8%EC%A7%80%ED%96%A5-%EB%A9%94%EC%86%8C%EB%93%9C%EB%A5%BC-%EA%B0%9D%EC%B2%B4%ED%95%A8%EC%88%98%EB%A1%9C-%EB%B6%84%EB%A6%AC%ED%95%98%EC%97%AC-%EC%B1%85%EC%9E%84-%EB%B6%84%EB%A6%AC%ED%95%98%EA%B8%B0\">절차지향 메소드를 객체,함수로 분리하여 책임 분리하기</a></li>\n<li><a href=\"#%EA%B2%B0%EB%A1%A0\">결론</a></li>\n</ul>"},"previous":{"fields":{"slug":"/2024y/mysqlMigration/"},"frontmatter":{"title":"AWS DMS를 이용한 MySQL 마이그레이션"}},"next":{"fields":{"slug":"/2024y/bookReview/bookReview/"},"frontmatter":{"title":"2024년 기록"}}},"pageContext":{"id":"7dce3593-8c41-5f90-8f8e-647de2f14e32","previousPostId":"b760302f-ed1a-54f1-87d2-1103440eae32","nextPostId":"459e967c-8067-5121-a9e4-07e0de4508d6"}},"staticQueryHashes":["230163734","3589320610"],"slicesMap":{}}