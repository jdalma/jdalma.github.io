{"componentChunkName":"component---src-templates-blog-post-js","path":"/2024y/polymorphism/","result":{"data":{"site":{"siteMetadata":{"title":"코딩 주머니"}},"markdownRemark":{"id":"57ed670b-72c1-5c05-aaa0-b691a4c0e34c","excerpt":"…","html":"<blockquote>\n<p>대부분의 내용은 <a href=\"https://www.yes24.com/Product/Goods/122890814\">타입으로 견고하게 다형성으로 유연하게</a> 책을 정리한 내용입니다.</p>\n</blockquote>\n<p>이 글을 통해</p>\n<ol>\n<li><strong>타입</strong></li>\n<li>여러 종류의 <strong>다형성</strong>과 <strong>가변성</strong></li>\n<li><strong>제네릭 가변성</strong></li>\n</ol>\n<p>대해 알아보자. 자연스럽게 타입 검사기와 더 친해질 수 있을 것이다.</p>\n<h1 id=\"다형성\" style=\"position:relative;\">다형성<a href=\"#%EB%8B%A4%ED%98%95%EC%84%B1\" aria-label=\"다형성 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>다형성은 프로그램의 <strong>한 개체</strong>가 여러 타입에 속하도록 만드는 것이다.<br>\n개체는 값, 함수, 클래스, 메서드 등 여러 가지가 될 수 있다.</p>\n<p>하나의 값이 여러 타입에 속할 수도 있고, 한 함수를 여러 타입의 함수로 사용할 수도 있는 것이다.<br>\n<strong>다형성은 거의 모든 정적 타입 언어에서만 발견할 수 있는 매우 널리 사용되는 개념이다.</strong><br>\n<code class=\"language-text\">\"어떤 개체에 다형성을 부여하는지\"</code> , <code class=\"language-text\">\"어떻게 다형성을 부여하는지\"</code> 를 이해하는 것이 중요하다.</p>\n<h2 id=\"서브타입에-의한-다형성\" style=\"position:relative;\">서브타입에 의한 다형성<a href=\"#%EC%84%9C%EB%B8%8C%ED%83%80%EC%9E%85%EC%97%90-%EC%9D%98%ED%95%9C-%EB%8B%A4%ED%98%95%EC%84%B1\" aria-label=\"서브타입에 의한 다형성 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>이 주제는 객체를 다룰 때 유용하며 <strong>서브타입</strong> 이라는 개념을 통해 다형성을 실현한다.<br>\n서브타입은 타입 사이의 관계이며, <code class=\"language-text\">\"A는 B이다.\"</code> 라는 설명이 올바르다면 <code class=\"language-text\">A는 B의 서브타입</code> , <code class=\"language-text\">B는 A의 슈퍼타입</code>이다.<br>\n반대로 <code class=\"language-text\">\"B는 A이다.\"</code>는 성립하지 않는다.</p>\n<p>A는 B의 서브타입일 때 B 타입의 부품을 A 타입의 부품으로도 간주할 수 있게 하는 기능이 서브타입에 의한 다형성이다.<br>\n즉, <strong>슈퍼타입이 요구되는 자리에 서브타입이 위치하더라도 타입 검사기가 문제삼지 않는다는 것이다.</strong><br>\n타입 검사기가 객체 타입의 서브타입 관계를 판단할 때 <strong>이름에 의한 서브타입</strong>과 <strong>구조에 의한 서브타입</strong>이 존재한다.</p>\n<h3 id=\"이름에-의한-서브타입\" style=\"position:relative;\">이름에 의한 서브타입<a href=\"#%EC%9D%B4%EB%A6%84%EC%97%90-%EC%9D%98%ED%95%9C-%EC%84%9C%EB%B8%8C%ED%83%80%EC%9E%85\" aria-label=\"이름에 의한 서브타입 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 451px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/ab487c944bf8a83a56f771c3d2cfa5c7/38070/subtype.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 60%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAACKElEQVR42lWTSY/TQBCF/f+Pc+AGB8SVXEAgoaBwgMlCRrNAEme1J453OxnHieO1H9Vle5ix9NRlu/vrV13VCugRAs0jUFZAdBGwI4GNW0A1M0x2KaYk1cqwcjIYQY7gWCDNK17zkqG0QZqXsA4Frv+Y+PVgYTBxMNkmWLrA3BEkQG00swSmVomFncPc58gYXEMVGRyTAnPafeEKfP5xjw+dLt53ehhMfWh+Ac0OsXNsmK7J46MTYmUnUO2SwGCwZLDD86WkVHLM6efCKaGFlOoeMMMTonCJ/DCmMxjRrlLDZhzx96dghkc3IDBlQAzJUjQv550kTGpGqdiOjurQbwBjiOj3C9Xv8jviIcUD+N6G12l+DmW6y7BkGBWAzmrr+DyJQcebemFyC1zuSXe1krvmP/3jOX1YnkXFK18DZzYQ+Et2JqKbZ3dfO1fofnqDLx+v8PPbW1x33yEPadP4hh0jHuEpVPHXIIe6X6e8ZIeA5Rq8o3RXOxjjYPQQ6F2E+nfstz1+b9OupMO4D8fdYO2Rw3P6uihcsWDCkxA3KZ1v6zSlZCzVHsdpgFP4gLl5xjmt2rapQapVELTi2PN0qqRcRKlFjY6thjwWVGnXXWFhJcQQ3ORKe0myouImlbAZgSfUvHKi4bgIAw3H/QJRMMXeVwmyxta2sbRiGGGFtGhuC5rGfr55fGMqhHFBE3Nqg5Idj9cpxpuUYkHnJKAHFbyjIND/dS3jH61mgkoOmwTNAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"subtype\"\n        title=\"\"\n        src=\"/static/ab487c944bf8a83a56f771c3d2cfa5c7/38070/subtype.png\"\n        srcset=\"/static/ab487c944bf8a83a56f771c3d2cfa5c7/3684f/subtype.png 225w,\n/static/ab487c944bf8a83a56f771c3d2cfa5c7/fc2a6/subtype.png 450w,\n/static/ab487c944bf8a83a56f771c3d2cfa5c7/38070/subtype.png 451w\"\n        sizes=\"(max-width: 451px) 100vw, 451px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>클래스의 이름과 클래스 사이의 상속 관계만 고려한다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">open class Person(val name: String)\nclass Marathoner(name: String): Person(name)</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">fun run(person: Person) {\n    ..\n}\n\nrun(Person(..))\nrun(Marathoner(..))</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">fun run(marathoner: Marathoner) {\n    ..\n}\n\nrun(Person(name))       // 컴파일 에러\nrun(Marathoner(name))</code>\n        </deckgo-highlight-code>\n<h3 id=\"구조에-의한-서브타입\" style=\"position:relative;\">구조에 의한 서브타입<a href=\"#%EA%B5%AC%EC%A1%B0%EC%97%90-%EC%9D%98%ED%95%9C-%EC%84%9C%EB%B8%8C%ED%83%80%EC%9E%85\" aria-label=\"구조에 의한 서브타입 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 571px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/73c335250124c6fa96c65e567cdefe5a/17d73/subtype2.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 24.888888888888886%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAABRElEQVR42hWQTU/CUBBF+fWuMXGlCe7cKOrGEKOiAgqtgohIDbS0lUD5aqWlhAJ97/hYzN3NmXMnI4TEjwVOIPm0I5rOiq/fNdY0xQtTkp0E9qNSJIi1S/L3wcavsguqbAOdNGojkzFSCjKDYEfHXmI7Swq3NXLHZxTudCw75MeOMS2fJIwhmpGOKuBXaBdzPF0fUbo45LVwQuw9w1IjjbtkOp5QywGubtDrzrl/qFN/62EPVvTNgB9zwWwUKpCBHBZhD51UGDXyvCro8P0c1p/qYB2xqCrD+Zae1sXseOjlL6ovbcp3Gs2Gg2nMsAyPZOrD1EUMlEm/wM69R7vIcnN6gJbPIiclBawh9oZCSqKuxdAN0GsGj08tHot1jJbDfByxmSvYSlVeLJDhTNl9sxm8MG5eMmmeM2xcsfXeYTtRP075B18/aNmhU6BxAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"subtype2\"\n        title=\"\"\n        src=\"/static/73c335250124c6fa96c65e567cdefe5a/17d73/subtype2.png\"\n        srcset=\"/static/73c335250124c6fa96c65e567cdefe5a/3684f/subtype2.png 225w,\n/static/73c335250124c6fa96c65e567cdefe5a/fc2a6/subtype2.png 450w,\n/static/73c335250124c6fa96c65e567cdefe5a/17d73/subtype2.png 571w\"\n        sizes=\"(max-width: 571px) 100vw, 571px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>만약 Person과 Marathoner라는 콘크리트 클래스가 서로 관계가 맺어져 있지 않고 다른 라이브러리에 존재한다고 가정하면 함수를 같이 사용할 수 없게된다.<br>\n이 문제를 <strong>구조를 드러내는 타입</strong>을 사용하여 <code class=\"language-text\">\"A가 B에 정의된 필드와 메서드를 모두 정의한다면 A는 B의 서브타입이다.\"</code> 라는 규칙을 적용하게 하여 해결할 수 있다.<br>\n언어가 구조에 의한 서브타입을 제공하면 추상 메서드를 대체할 수 있기 때문에 추상 메서드의 필요성이 줄어든다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">// scala\nclass Person(val name: String) {\n  def greeting(word: String): Unit = {\n    println(word)\n  }\n}\nclass Marathoner(val name: String, val awards: List[String]) {\n  def greeting(word: String): Unit = {\n    println(word)\n  }\n}\n\n// 필드 구조를 드러내어 다형성을 해결\ndef run(person: { val name: String }): Unit = {\n   // person.name\n}\n\nrun(new Person(name))\nrun(new Marathoner(name, null))\n\n// 메서드 구조를 드러내어 다형성을 해결\ndef _greeting(person: { def greeting(word: String): Unit }, word: String): Unit = {\n   person.greeting(word)\n}\n\n_greeting(new Person(name), &quot;hello&quot;)\n_greeting(new Marathoner(name, null), &quot;hi&quot;)</code>\n        </deckgo-highlight-code>\n<h3 id=\"집합론적-서브타입\" style=\"position:relative;\">집합론적 서브타입<a href=\"#%EC%A7%91%ED%95%A9%EB%A1%A0%EC%A0%81-%EC%84%9C%EB%B8%8C%ED%83%80%EC%9E%85\" aria-label=\"집합론적 서브타입 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<blockquote>\n<p>타입은 프로그램에 존재하는 값들을 그 능력에 따라 분류한 것이다. 여기서 값은 변수에 저장되거나 함수에서 반환될 수 있는 모든 것들을 말한다.</p>\n</blockquote>\n<h3>최대 타입 (전체 집합, top type)</h3>\n<p><strong><code class=\"language-text\">\"아무 값이나 가능하다\"</code>는 사실을 타입으로 표현하기 위함이다.</strong><br>\n가장 큰 타입이며 모든 값을 포함하는 타입이다.<br>\n이 정의에 따라 <strong>모든 타입은 최대 타입의 서브타입이며, 최대 타입은 모든 타입의 슈퍼타입이다.</strong></p>\n<p>자바에서는 <code class=\"language-text\">Object</code>, 코틀린에서는 <code class=\"language-text\">Any?</code>를 의미한다.</p>\n<h3>최소 타입 (공집합, bottom type)</h3>\n<p>예외가 발생하여 실행이 즉시 끝나는 경우, 타입 검사를 통과한 프로그램이더라도 예외가 발생해 실행이 갑작스럽게 중단되는 경우를 다루기 위함이다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">fun error() {\n    throw RuntimeException()\n}\n\nfun assertEquals(num1: Int, num2: Int) : Boolean = \n   if (num1 == num2) true else error() // 컴파일 에러</code>\n        </deckgo-highlight-code>\n<p>위의 <code class=\"language-text\">assertEquals</code>는 정상적인 경우 <code class=\"language-text\">true</code>를 반환하므로 <code class=\"language-text\">Boolean</code>을 반환하는 것이 합당해 보일 수 있지만 컴파일 에러가 발생한다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">fun error(): Boolean {\n    throw RuntimeException()\n}\n\nfun assertEquals(num1: Int, num2: Int) : Boolean = \n    if (num1 == num2) true else error()\n\nfun assertEqualsYesOrThrowException(num1: Int, num2: Int) : String = \n    if (num1 == num2) &quot;Y&quot; else error()    // 컴파일 에러</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">error()</code> 함수를 <code class=\"language-text\">Boolean</code>을 반환하도록 수정하면 컴파일을 완료할 수 있다.<br>\n하지만 <code class=\"language-text\">error()</code> 함수가 다른 타입에서도 사용되어야 한다면 그 타입에 맞는 타입을 반환하는 함수가 계속 추가되어야 한다.</p>\n<p>error() 함수는 <strong>값을 반환하지 못한 채 예외가 발생하는 함수</strong>이므로 어디서든 사용할 수 있도록 하는 것이 맞다.<br>\n이때 <strong><code class=\"language-text\">\"계산을 끝마치지 못한다\"</code>를 표현하기 위한 타입, 어떤 값도 속하지 않는 타입이 최소 타입을 사용할 수 있다.</strong></p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">fun error(): Nothing {\n    throw RuntimeException()\n}\n\nfun assertEquals(num1: Int, num2: Int) : Boolean =\n    if (num1 == num2) true else error()\nfun assertEqualsYesOrThrowException(num1: Int, num2: Int) : String =\n    if (num1 == num2) &quot;Y&quot; else error()</code>\n        </deckgo-highlight-code>\n<p><a href=\"https://github.com/jdalma/footprints/tree/main/%EC%BD%94%ED%8B%80%EB%A6%B0#%EB%84%90-%EA%B0%80%EB%8A%A5%EC%84%B1%EC%97%90-%EB%8C%80%ED%95%9C-%EC%8A%A4%EB%A7%88%ED%8A%B8-%EC%BA%90%EC%8A%A4%ED%8A%B8%EC%99%80-nothing-%ED%83%80%EC%9E%85\">Kotlin의 Nothing</a>을 사용하여 예외를 던지는 함수를 어디서든 호출할 수 있도록 하여 문제를 해결할 수 있다.<br>\n<strong>최대 타입이 \"아무 값이나 될 수 있다.\"를 의미한다면 최소 타입은 \"아무 곳에나 사용될 수 있다.\"를 의미한다.</strong></p>\n<h3>이거나 타입 (합집합, union type)</h3>\n<p>한 함수가 받는 인자 타입이 여러 가지가 되어야 하는 경우 유용하게 사용할 수 있는 타입이다.</p>\n<deckgo-highlight-code language=\"typescript\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">// typescript\nfunction write(data: string | number): void {\n    if (typeof data === &quot;string&quot;) {\n        let str: string = data;\n        ..\n    } else {\n        let num: number = data;\n        ..\n    }\n}\n\nwrite(1)\nwrite(&quot;abcd&quot;)</code>\n        </deckgo-highlight-code>\n<h3>이면서 타입 (교집합, intersection type)</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 476px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/a31fce48b48f12a00340d2c7fc9b87e6/f2205/intersection.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 55.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB+0lEQVR42n2Sa3OaUBCG/f9/pf3QtEkn07SNycR+iE2qUVEEhrugCN6IoFyeHjAxTSftzrzs4TDz7LvLNnpawL2k8yDbSJqH4a0way3/0uoo218j6XPmyy1VlEUpHgc1HpQp3ftbWjfXDKU+eZ7zvyifcpzs0QS8vitfvjdkK6oPhahS3RdJSmqqPGodoS6x2iExJBLHIewrhAOFSFLwOjJWT6Gc+WS+R+5NyH2fxvgILOqcTT1W6hW7lUEaaaQLk8dpG7s/wFNnhE5A5ITYQwdj5Ap7OUWaCpclmW1VwMUr4N63iO02VeNZntWudxsTs98jTctj0+l2h28GLzMUUblsjO3XwJ1nkfodhmOFiy/nXF232EQq8l2b88/faDYvOTs75fvXS1zNfwIWL8CRGb3psKqZpgm7TGTh0Br0SbYZ+yxlv0+J1zG+/obDnjY/gPY5WQXxXRZ6i+02JIkDdtslm3kPXcxwNtmwFquyWSU4AjYxDsBCbEaFzCqgG2xQnSX6ZInmx1gjE01WGcgPSKMug+EvZHWMIjpp3xm0fxrctnW6XZs8K/hzb2qHh/eynkNdZTaliON/7t9zJOLPaoaOK1bFcV1mqxVrTaVRPm/lc5UwJHMd8kUozsFRRTgnn8/JgoAyilgaBhfv39E8+cDN6SeaH0+wfrT4DfWnPeKOHHiFAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"intersection\"\n        title=\"\"\n        src=\"/static/a31fce48b48f12a00340d2c7fc9b87e6/f2205/intersection.png\"\n        srcset=\"/static/a31fce48b48f12a00340d2c7fc9b87e6/3684f/intersection.png 225w,\n/static/a31fce48b48f12a00340d2c7fc9b87e6/fc2a6/intersection.png 450w,\n/static/a31fce48b48f12a00340d2c7fc9b87e6/f2205/intersection.png 476w\"\n        sizes=\"(max-width: 476px) 100vw, 476px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>다중 상속 또는 구현을 다룰 때 유용하다. 위의 그림과 같이 어떤 함수를 <code class=\"language-text\">Trainer</code>와 <code class=\"language-text\">Developer</code>를 동시에 인자로 받도록 지정하고 싶을 때 편리하게 사용할 수 있다.<br>\n(코틀린에서도 <code class=\"language-text\">where</code> 키워드를 이용하여 상한을 동시에 지정할 수 있다. <a href=\"https://jdalma.github.io/2024y/polymorphism/#%ED%83%80%EC%9E%85-%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98-%EC%A0%9C%ED%95%9C\">\"타입 매개변수 제한\"</a> 내용에서 설명한다.)</p>\n<deckgo-highlight-code language=\"typescript\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">// typescript\ninterface Person {\n  name: string;\n}\ninterface Marathoner {\n  awards: string[];\n}\nclass Trainer implements Person, Marathoner {\n    awards: string[]=[];\n    name!: string;\n}\nclass Developer implements Person, Marathoner {\n    awards: string[]=[];\n    name!: string;\n}\n\nfunction getName(person: Trainer &amp; Developer): String {\n    return person.name;\n}</code>\n        </deckgo-highlight-code>\n<h3 id=\"함수와-서브타입\" style=\"position:relative;\">함수와 서브타입<a href=\"#%ED%95%A8%EC%88%98%EC%99%80-%EC%84%9C%EB%B8%8C%ED%83%80%EC%9E%85\" aria-label=\"함수와 서브타입 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>언어가 함수를 값으로 사용할 수 있는 일급 함수를 지원하고 객체와 서브타입에 의한 다형성이 존재하면 <strong>함수 타입 사이의 서브타입 관계를 따질 필요가 생긴다.</strong></p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">open class Person\nclass Marathoner : Person()\n\nval selectBySupertype: (Person) -&gt; Marathoner = ..\nval selectBySubtype: (Marathoner) -&gt; Marathoner = ..\n\nfun select(selector: (Marathoner) -&gt; Person) {\n   val person = selector(Marathoner())\n   ..\n}\n\n@Test\nfun call() {\n   select(selectBySupertype)\n   select(selectBySubtype)\n}</code>\n        </deckgo-highlight-code>\n<p>이전에 배운 <code class=\"language-text\">\"A는 B이다.\"</code>에 입각하여 위의 예제를 보면 <code class=\"language-text\">(Person) -> Boolean</code>은 <code class=\"language-text\">(Marathoner) -> Boolean</code>의 서브타입이다.<br>\n<strong>\"사람을 인자로 받을 수 있는 함수는 마라토너를 인자로 받을 수 있는 함수다.\"</strong> 가 성립되기 때문이다.</p>\n<p>하지만 그 반대인 <code class=\"language-text\">(Marathoner) -> Boolean</code>은 <code class=\"language-text\">(Person) -> Boolean</code>의 서브타입이 아니다.<br>\n<strong>\"마라토너를 인자로 받을 수 있는 함수는 사람을 인자로 받을 수 있는 함수다.\"</strong> 가 성립되지 않기 때문이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 796px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/b8fd32776c679261a601b162ffd247e4/d48f1/functionSubtype.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 100%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsTAAALEwEAmpwYAAAC6UlEQVR42p1U25KbOhD0jywgCQlxR1wMGHvt7Fad85L//51OS/iyyUMqyUPXGIFHPT09c+jrGpW1aFuHVFu8RQJRLP8Zh0xnSI2FzgporUPCkNTHf0lYMFlrHXJTIi8KWJszNihsBpOqv2Z8mJsW7+6KS3dF13ZYlhnODTgeF/RdhabMEP9NQp2SibQwykJJzbItJGPK8zQ1RLrLwI/fYvGUZJdFBuzv928OxuSITB0QmwYJNY1TgUSl1DZH7C8xBZRgFCZcaDKLLCsheJnIFKUxgZSSKQ5dVSErHbrxhKZf4KYZ8+mE47JhY/zvcsVtu6J1DpnRSJIUUmkiQyIVL1SsiGfCv1M49HUFm9cYJ2o2TBiPK97fP7BdvuF82vBtvOA6XDGOM4q2eDbp2azoLsWjZMGSYj4kQvEGGRgIf5tIA+KI5/H+O0rkFw0f+r0ShqZYWyCxHUTRQ+YO0moIrejLHIra2LzC3jg2ifDfZ7aE0gbCUj9GK3NoEgsJh6aGrRzG+Qw3rpjmleXSRjeWPbF8d8PRrXCDg1I7U19VYE/9BCsTrMrrFxK2RRludP2Epu0Zj1jWM9bThYkmLPUJYzWzYT1Z0ehve4kPywQ97wgJE0/1PmpR/OtUiJf4ifx5aqKvDfli7KqsocoRupmhqxGm5kxzOsq6Q1U1qKuWY1ij0DxPLceypA8LyExD5Sksz2zKZ5Yeujxw2xTUsKdeAzGvGy7XD5zfb/i83fD9839sywUdNZRSIqZWHp6xRxyrgCfD0rve+sVQo24chnFBR+2O/Ygzm7G2R2rbIc30yy6/m2UhDW9SO+KXp+K7TnH0YHWPjz8Hdi88E7Z1A0P9Mreh7GdUPZl2LdqmR1l2aMi6NN5n1Cr3662CNIZ+VfC7NFcF/Zm+utxxBxZlGyzjy93ON4Ljdjrjc/vAxLOqq+k7eS/3NXLRF7u8Fmzmt0cZJqKsuqBfy324dhN35IyhGZBzgXgD/8k+/AFhGEPuNY5zJQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"functionSubtype\"\n        title=\"\"\n        src=\"/static/b8fd32776c679261a601b162ffd247e4/d48f1/functionSubtype.png\"\n        srcset=\"/static/b8fd32776c679261a601b162ffd247e4/3684f/functionSubtype.png 225w,\n/static/b8fd32776c679261a601b162ffd247e4/fc2a6/functionSubtype.png 450w,\n/static/b8fd32776c679261a601b162ffd247e4/d48f1/functionSubtype.png 796w\"\n        sizes=\"(max-width: 796px) 100vw, 796px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">람다 \\ 함수 인자</th>\n<th align=\"center\">selectSuperToSuper</th>\n<th align=\"center\">selectSubToSuper</th>\n<th align=\"center\">selectSuperToSub</th>\n<th align=\"center\">selectSubToSub</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><code class=\"language-text\">(Sub) -> Sub</code></td>\n<td align=\"center\">❌</td>\n<td align=\"center\">O</td>\n<td align=\"center\">❌</td>\n<td align=\"center\">O</td>\n</tr>\n<tr>\n<td align=\"left\"><code class=\"language-text\">(Sub) -> Super</code></td>\n<td align=\"center\">❌</td>\n<td align=\"center\">O</td>\n<td align=\"center\">❌</td>\n<td align=\"center\">❌</td>\n</tr>\n<tr>\n<td align=\"left\"><code class=\"language-text\">(Super) -> Super</code></td>\n<td align=\"center\">O</td>\n<td align=\"center\">O</td>\n<td align=\"center\">❌</td>\n<td align=\"center\">❌</td>\n</tr>\n<tr>\n<td align=\"left\"><code class=\"language-text\">(Super) -> Sub</code></td>\n<td align=\"center\">O</td>\n<td align=\"center\">O</td>\n<td align=\"center\">O</td>\n<td align=\"center\">O</td>\n</tr>\n</tbody>\n</table>\n<p>즉, A가 B의 서브타입일 떄 <code class=\"language-text\">B -> C</code>가 <code class=\"language-text\">A -> C</code>의 서브타입이며 그 반대는 성립하지 않는다.<br>\n따라서 <strong>함수 타입은 매개변수 타입의 서브타입 관계를 뒤집는다.</strong><br>\n결과 타입의 서브타입 관계가 유지된다는 사실은 나름 직관적인것에 비해, 매개변수 타입의 서브타입 관계가 뒤집히는게 이상할 수 있지만 논리적으로 타당하다.</p>\n<p><code class=\"language-text\">selectSubToSuper</code>의 함수는 4가지의 람다를 모두 허용하는 이유가 <strong>\"함수 타입은 매개변수 타입의 서브타입 관계를 뒤집고 결과 타입의 서브타입 관계는 유지하기 때문이다.\"</strong> ⭐️</p>\n<h2 id=\"매개변수에-의한-다형성\" style=\"position:relative;\">매개변수에 의한 다형성<a href=\"#%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98%EC%97%90-%EC%9D%98%ED%95%9C-%EB%8B%A4%ED%98%95%EC%84%B1\" aria-label=\"매개변수에 의한 다형성 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>매개변수에 의한 다형성은 <strong>타입 매개변수를 통해 다형성을 만드는 기능으로, 제네릭스라고도 부른다.</strong></p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">fun &lt;T&gt; choose(v1: T, v2: T): T {\n   println(v1)\n   println(v2)\n   return if(readln() == &quot;Y&quot;) v1 else v2\n}</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">T</code>를 매개변수 타입 표시와 결과 타입 표시에 사용했다. 이와 같이 한 개 이상의 타입 매개변수를 가지는 함수를 <strong>제네릭 함수</strong> 라고 부른다.<br>\n타입 매개변수를 추가할 수 있는 곳은 함수뿐이 아니라 타입에 타입 매개변수를 추가하여 <strong>제네릭 타입</strong> 을 지정할 수 있고,<br>\n타입 매개변수를 가진 클래스를 정의하여 <strong>제네릭 클래스</strong> 도 만들 수 있다.</p>\n<p>하지만 제네릭 <code class=\"language-text\">T</code>가 아무 타입이나 될 수 있기 때문에 특정 타입에서 제공하는 기능을 사용할 수 없다.<br>\n<strong>타입 매개변수로 지정된 타입은 함수 또는 클래스 안에서 특정 능력이 필요한 자리에 사용된다면 제네릭으로 선언할 필요가 없다.</strong></p>\n<h3 id=\"무엇이든-타입\" style=\"position:relative;\">무엇이든 타입<a href=\"#%EB%AC%B4%EC%97%87%EC%9D%B4%EB%93%A0-%ED%83%80%EC%9E%85\" aria-label=\"무엇이든 타입 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">fun &lt;T&gt; first(list: List&lt;T&gt;): T = list.first()\nfun &lt;T&gt; last(list: List&lt;T&gt;): T = list.last()\n\nfun &lt;T&gt; compute(selector: (List&lt;T&gt;) -&gt; T) {\n   selector(listOf(1,2,3))          // 컴파일 에러\n   selector(listOf(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;))    // 컴파일 에러\n}\n\n@Test\nfun task() {\n   compute&lt;Int&gt;(::first)\n   compute&lt;String&gt;(::last)\n}</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">simulate</code> 함수 안에서 selector의 타입이 2가지가 동시에 존재하기 때문에 컴파일 에러가 발생한다.<br>\n타입 검사기가 <code class=\"language-text\">simulate</code>의 <code class=\"language-text\">T</code>가 무엇인지 알 수 없는 이와 같은 상황을 해결할 수 있는 방법은 무엇일까?<br>\n(simulate에 list를 파라미터로 추가하면 되지만.. 2가지 타입이 동시에 존재하는 상황에 집중해보자)</p>\n<deckgo-highlight-code language=\"haskell\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\"># haskell\ncompute :: (forall a.[a] -&gt; a) -&gt; ()\ncompute selector = \n    let number = selector [1, 2, 3] in\n    let char = selector [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;] in</code>\n        </deckgo-highlight-code>\n<p>이때 하스켈의 <code class=\"language-text\">forall</code> 키워드인 <strong>무엇이든 타입</strong> 을 사용할 수 있다.<br>\n<strong>제네릭 함수를 바로 인자로 넘길 수 있다.</strong></p>\n<h3 id=\"무엇인가-타입\" style=\"position:relative;\">무엇인가 타입<a href=\"#%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-%ED%83%80%EC%9E%85\" aria-label=\"무엇인가 타입 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">class TimeStamper{\n    fun Init(): Int = 0\n    fun next(t: Int) = t + 1;\n    fun compare(o1: Int, o2: Int) = o1 - o2\n}</code>\n        </deckgo-highlight-code>\n<p>내가 라이브러리 개발자라고 가정해보자\n(위의 클래스는 문제가 많지만 상황을 설명하기 위해 어쩔 수 없이 사용해야 한다고 생각해보자.)</p>\n<p>만약 TimeStamper의 반환 타입을 String으로 바꿔야 한다면 라이브러리 사용자는 내부 필드의 타입까지 모두 알고있기 때문에 라이브러리 수정으로 인한 파급력이 클 수 있다.<br>\n이때 <strong>무엇인가 타입</strong> 을 활용하면 라이브러리 사용자에게 TimeStamper의 타입이 되는 <code class=\"language-text\">무엇인가</code>가 있다는 사실은 알지만, 그 타입을 특정하여 사용할 수 없도록 할 수 있다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">exists T.{ T init(); T next(T t); T compare(T o1, T o2); } create() {\n    return TimeStamper()\n}</code>\n        </deckgo-highlight-code>\n<p>이렇게 <code class=\"language-text\">exists T.A</code> 형태로 생긴 타입이 무엇인가 타입이며, <strong>T는 타입 매개변수, A는 타입을 의미한다.</strong> 여기서 <code class=\"language-text\">T</code>가 무엇인지는 알 수 없다.<br>\n그저 <code class=\"language-text\">create</code> 함수 반환 값의 타입이 <code class=\"language-text\">{ T init(); T next(T t); T compare(T o1, T o2); } 구조이다.</code> 라는 사실이 되도록 만드는 T가 존재한다는 사실만 알려줄 뿐이다.<br>\n<strong>라이브러리 사용자는 타입에 의존하는 것이 아니라 구조에 의존하도록 의도하여 행동이 제약된다.</strong></p>\n<p>실제로 <code class=\"language-text\">exists T.A</code> 키워드가 존재하는 것은 아니고 언어마다 이 타입을 지원하는 방법이 다르기 때문에 따로 확인이 필요할 것이다.<br>\n이런 문제를 해결하기 위해 이런 방법을 지원하는 언어들이 있다고 기억하면 좋을것이다. (하스켈, 오캐멀 참고)</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/d19f33a8a6125d3ff62d9a6554c20c01/fcda8/forallExist.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 64%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAABv0lEQVR42pWTXW/aMBSG+f//Zfe7m7hYaaWIScAgEUWUQQqjofkOSZz42XG8qAy6qbPsyD4fr98353jA9YgieH6G11e7zDmKIU7kfIJQbGFofVV1kz7IsoxYkiqlSPZ7ksOBpnPp7vv46OIuxkwmjuRbgOxcEAtg7vucy5I4jkmShDzPGXiex3A45Gm7ZXp/z4PsXwJhQouuQ9KfM9JgSXycU0dPYi6ZLxZ8vbtjIrE7yXMch9FohOu6DDouWls+wlYXZ9komQm6OlHHi45VWxxRwRTOIr2MrAYj/VpyB6atPJ2mAlhAIwm6kVlSxR4I0yZaU6dbG5f4aFXKfwwNG/TFGtgIC4gA0jGsLUORV7/M4LCiDVfUuS+FkAuLk41/j+EtYGH3ukZnP1DeUGS2tPsl6uCI3OQt21T6w4DGXJ5QKwGUsrebKer47bej/SBDKcofgCK/8r6gHj5Rf/8ssvfyN5r/YCi9JM305pW+ZDaH1RK2O9j59tI+568M+2Ea1wS1IqlpbFK/jO3Sbi6Xhv43YM/SgJplnqA0LvIiur1hHATWF0W8N24Be/lmzEXueAzymthsYL22hbuOuwD8BSTK8KWw9ipsAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"forallExist\"\n        title=\"\"\n        src=\"/static/d19f33a8a6125d3ff62d9a6554c20c01/fcda8/forallExist.png\"\n        srcset=\"/static/d19f33a8a6125d3ff62d9a6554c20c01/3684f/forallExist.png 225w,\n/static/d19f33a8a6125d3ff62d9a6554c20c01/fc2a6/forallExist.png 450w,\n/static/d19f33a8a6125d3ff62d9a6554c20c01/fcda8/forallExist.png 590w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<blockquote>\n<p>무엇인가 타입의 값은 만들기 쉽지만 사용하기 어렵고, 무엇이든 타입의 값은 만들기는 어려워도 사용하기는 쉽다.</p>\n</blockquote>\n<h1 id=\"두-다형성의-만남\" style=\"position:relative;\">두 다형성의 만남<a href=\"#%EB%91%90-%EB%8B%A4%ED%98%95%EC%84%B1%EC%9D%98-%EB%A7%8C%EB%82%A8\" aria-label=\"두 다형성의 만남 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>전통적으로 서브타입에 의한 다형성은 객체 지향 언어가 지원하고, 매개변수에 의한 다형성은 함수형 언어가 지원했다.<br>\n요즘은 한 언어가 <strong>두 종류의 다형성을 지원한다.</strong><br>\n서로 다른 특징을 가진 두 개의 다형성이 유용한 기능들이 탄생한다.</p>\n<h2 id=\"제네릭-클래스와-상속\" style=\"position:relative;\">제네릭 클래스와 상속<a href=\"#%EC%A0%9C%EB%84%A4%EB%A6%AD-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%EC%83%81%EC%86%8D\" aria-label=\"제네릭 클래스와 상속 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>알다시피 어떤 클래스를 상속해 새로운 클래스를 정의하면 기존 클래스에 정의된 필드와 메서드가 새 클래스에도 자동으로 정의된다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">abstract class List&lt;T&gt; {\n    abstract fun get(index: Int): T\n}\nclass ArrayList&lt;T&gt;: List&lt;T&gt;() {\n    override fun get(index: Int): T = ..\n}\nclass AnotherList: List&lt;Boolean&gt;() {\n    override fun get(index: Int): Boolean = ..\n}\n\nval stringList = ArrayList&lt;String&gt;()\nval intList = ArrayList&lt;Int&gt;()\nval anotherList = AnotherList()\n\nfun &lt;T&gt; findFirst(list: List&lt;T&gt;): T = ..\nfun isExist(list: List&lt;Boolean&gt;): Boolean = ..\n\n@Test\nfun name2() {\n    findFirst(stringList)\n    findFirst(intList)\n    findFirst(anotherList)\n\n    isExist(stringList)     // 컴파일 에러\n    isExist(intList)        // 컴파일 에러\n    isExist(anotherList)\n}</code>\n        </deckgo-highlight-code>\n<p>기존의 <code class=\"language-text\">List&lt;T></code>를 구현하는 <code class=\"language-text\">ArrayList&lt;T></code> 와 다르게 <strong>특정 타입의 List에 대한 서브타입</strong> 을 추가해야하는 경우이다.<br>\n제네릭 클래스가 있을 때 타입들 사이의 서브타입 관계가 <code class=\"language-text\">C&lt;T> extends D&lt;T></code>라면 <code class=\"language-text\">C&lt;A></code>는 <strong>타입 <code class=\"language-text\">D</code>에 등장하는 모든 <code class=\"language-text\">T</code>를 <code class=\"language-text\">A</code>로 바꿔서 만든 타입의 서브타입</strong> 이라고 정리할 수 있다.</p>\n<h2 id=\"타입-매개변수-제한\" style=\"position:relative;\">타입 매개변수 제한<a href=\"#%ED%83%80%EC%9E%85-%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98-%EC%A0%9C%ED%95%9C\" aria-label=\"타입 매개변수 제한 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>제네릭 함수를 정의한다는 것은 여러 타입으로 사용될 수 있는 함수를 만드는 일이니, <strong>인자로 주어질 값이 특별한 능력을 가진다고 가정할 수 없다.</strong><br>\n반대로 인자가 특별한 능력을 가져야만 한다면 그 함수는 제네릭 함수일 필요가 없다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">open class Person(private val age: Int): Comparable&lt;Person&gt;{\n    override fun compareTo(other: Person): Int = compareValuesBy(this, other, Person::age)\n}\nclass Marathoner(age: Int): Person(age)\n\nfun elder(person: Person, other: Person): Person =\n    if(person &gt; other) person else other\n\nval person: Person = elder(person1, person2)\nval marathoner: Marathoner = elder(marathoner1, marathoner1)    // 컴파일 에러</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">elder</code>의 파라미터는 서브타입에 의한 다형성으로 컴파일을 통과하지만 반환 타입이 <code class=\"language-text\">Marathoner</code>이기 때문에 컴파일 에러가 발생한다.<br>\n실제로 반환 타입인 <code class=\"language-text\">Person</code>은 <code class=\"language-text\">Marathoner</code>의 서브타입이 아니기 때문이다.</p>\n<p>이때 제네릭 함수를 적용하려 할 수 있다. 하지만 제네릭 타입은 모든 타입을 수용하기 때문에 <code class=\"language-text\">></code> 연산 같은 특별한 능력을 사용할 수 없다.<br>\n이때 <strong>타입 매개변수 제한의 상한(upper bound)</strong> 을 지정하여 <strong>\"T가 최대 Person 타입까지 커질 수 있다.\"</strong> 라는 의미를 부여할 수 있다.<br>\n즉, <strong>T가 Person의 <code class=\"language-text\">서브타입</code>이다.</strong> (제네릭 함수뿐 아니라 제네릭 클래스도 마찬가지다.)</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">fun &lt;T: Person&gt; elder(person: T, other: T): T =\n    if(person &gt; other) person else other\n\nval person: Person = elder&lt;Person&gt;(person1, person2)\nval marathoner: Marathoner = elder&lt;Marathoner&gt;(marathoner1, marathoner1)</code>\n        </deckgo-highlight-code>\n<p>위와 같이 상한을 <code class=\"language-text\">&lt;T: Person></code>으로 지정하여 반환 타입으로 <code class=\"language-text\">Marathoner</code>를 받을 수 있고, 특별한 <code class=\"language-text\">></code> 연산을 사용할 수 있게 되었다.</p>\n<p>기본적으로 <code class=\"language-text\">&lt;></code>에 하나의 상한만 지정이 가능하지만 둘 이상의 상한이 필요한 경우 <code class=\"language-text\">where</code>을 사용할 수 있다. <a href=\"https://kotlinlang.org/docs/generics.html#upper-bounds\"><code class=\"language-text\">kotlinlang</code> Upper Bounds</a><br>\n<strong>전달된 유형은 절의 모든 조건을 동시에 만족해야한다.</strong> 아래의 예제를 확인해보자.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">interface Person\ninterface Marathoner\n\nclass Trainer: Person, Marathoner\nclass Developer: Person, Marathoner\n\ninterface Intersection&lt;T&gt; where T : Person, T : Marathoner\n\nfun main() {\n    val person = object : Intersection&lt;Person&gt; {}           // Type argument is not within its bounds. Compile Error !!!\n    val marathoner = object : Intersection&lt;Marathoner&gt; {}   // Type argument is not within its bounds. Compile Error !!!\n    val trainer = object : Intersection&lt;Trainer&gt; {}\n    val developer = object : Intersection&lt;Developer&gt; {}\n}</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">Intersection</code> 인터페이스를 구현하는 타입은 <code class=\"language-text\">Person</code>와 <code class=\"language-text\">Marathoner</code> 둘 다 만족해야 한다.</p>\n<p>아래는 함수의 인자를 동시에 제한하여 <strong><code class=\"language-text\">CharSequence</code>와 <code class=\"language-text\">Comparable</code>을 구현하는 타입만 받을 수 있는 함수</strong>이다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">fun &lt;T&gt; copyWhenGenerator(list: List&lt;T&gt;, threshold: T): List&lt;String&gt;\n    where T: CharSequence, T: Comparable&lt;T&gt; {\n        return list.filter {\n            it &gt; threshold\n        }.map { it.toString() }\n    }\n\ndescribe(&quot;copyWhenGenerator 함수는&quot;) {\n    val param1: Pair&lt;List&lt;String&gt;, String&gt; = listOf(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;) to &quot;b&quot;\n    val param2: Pair&lt;List&lt;StringBuilder&gt;, StringBuilder&gt; = listOf(\n        StringBuilder(&quot;A&quot;),\n        StringBuilder(&quot;B&quot;),\n        StringBuilder(&quot;C&quot;)\n    ) to StringBuilder(&quot;B&quot;)\n\n    context(&quot;threshold 보다 큰 값만 반환한다.&quot;) {\n\n        copyWhenGenerator(param1.first, param1.second) shouldBe listOf(&quot;c&quot; , &quot;d&quot;)\n        copyWhenGenerator(param2.first, param2.second) shouldBe listOf(&quot;C&quot;)\n    }\n}</code>\n        </deckgo-highlight-code>\n<h2 id=\"재귀적-타입-매개변수-제한\" style=\"position:relative;\">재귀적 타입 매개변수 제한<a href=\"#%EC%9E%AC%EA%B7%80%EC%A0%81-%ED%83%80%EC%9E%85-%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98-%EC%A0%9C%ED%95%9C\" aria-label=\"재귀적 타입 매개변수 제한 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>타입 매개변수가 자기 자신을 상한으로 하는 타입 매개변수를 <strong>재귀적 타입 매개변수 제한</strong> 이라고 부른다.<br>\n정렬하는 코드를 예제로 보자.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">abstract class Comparable&lt;T&gt; {\n    abstract fun gt(that: T): Boolean\n}\nclass Person(private val age: Int): Comparable&lt;Person&gt;(){\n    override fun gt(that: Person): Boolean = this.age &gt; that.age\n}\n\nfun &lt;T: Comparable&lt;T&gt;&gt; sort(list: List&lt;T&gt;) {\n    list.forEachIndexed { index, element -&gt;\n        var min = index\n        for (innerIndex in index + 1 until list.size) {\n            if (element.gt(list[innerIndex])) {\n                min = innerIndex\n            }\n        }\n        // index와 min의 원소를 교체\n    }\n}\n\nsort(listOf(Person(10), Person(5)))</code>\n        </deckgo-highlight-code>\n<p>객체를 정렬 가능한 객체로 구현할 때 접하는 익숙한 코드이다.<br>\n어떤 리스트를 정렬하려면 그 리스트를 구성하는 값들이 서로 비교 가능해야 하기 때문에</p>\n<ul>\n<li><strong>Comparable 추상 클래스는 자신과 동일한 타입의 다른 객체와 비교할 수 있는 클래스이다.</strong></li>\n<li><strong>Comparable 추상 클래스는 자신의 타입 매개변수 T를 자신의 상한으로 지정하고 있다.</strong></li>\n<li><strong>T가 Comparable&#x3C;T>의 서브타입일 때 T 타입의 값을 T 타입의 값과 비교할 수 있다</strong></li>\n</ul>\n<p>이 규칙을 모두 만족하므로 <code class=\"language-text\">sort</code> 함수는 컴파일된다.<br>\nComparable의 gt 메서드가 (<code class=\"language-text\">that: T</code>) 자기 자신과 같은 타입의 매개변수를 참조하는 것과 <code class=\"language-text\">sort</code> 함수가 요구하는 <code class=\"language-text\">&lt;T: Comparable&lt;T>></code> 제네릭이 <strong>재귀적 타입 매개변수 제한</strong> 이다.</p>\n<h2 id=\"가변성\" style=\"position:relative;\">가변성<a href=\"#%EA%B0%80%EB%B3%80%EC%84%B1\" aria-label=\"가변성 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><strong>지금까지 제네릭 함수를 정의할 때는 대개 매개변수 타입과 결과 타입의 관계를 유지해야 한다는 명확한 목표가 있었다.</strong><br>\n아래의 <code class=\"language-text\">choose</code>와 <code class=\"language-text\">elder</code> 같이 받은 타입을 그대로 반환해야 하는 함수 <strong>매개변수에 의한 다형성이 반드시 필요했다.</strong></p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">fun &lt;T&gt; choose(v1: T, v2: T): T = if ( .. ) v1 else v2\nfun &lt;T: Person&gt; elder(person: T, other: T): T = if( .. ) person else other</code>\n        </deckgo-highlight-code>\n<p>반면 그냥 Person 객체를 인자로 받아 소비만하는 <code class=\"language-text\">run</code>과 같은 함수는 <strong>서브타입에 의한 다형성이면 충분하다.</strong></p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">fun run(person: Person) {\n    person.age ..\n}</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">Marathoner</code>는 <code class=\"language-text\">Person</code>의 서브타입이 맞지만, <strong><code class=\"language-text\">List&lt;Marathoner></code>는 <code class=\"language-text\">List&lt;Person></code>의 서브타입이 아니기 때문에 <code class=\"language-text\">List&lt;Marathoner></code>와 <code class=\"language-text\">List&lt;Person></code> 타입의 리스트를 모두 사용하기 위한 함수는 <code class=\"language-text\">averageAge</code>함수처럼 제네릭 함수로 정의하고 타입 매개변수 제한을 사용하였다.</strong></p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">fun &lt;T: Person&gt; averageAge(people: List&lt;T&gt;): Int = ..</code>\n        </deckgo-highlight-code>\n<p>하지만 이 방법대로라면 아래와 같은 귀찮은 점이 있다.</p>\n<ol>\n<li><strong><code class=\"language-text\">List&lt;A></code> 타입의 인자를 받는 함수를 정의할 때 마다 매개변수 타입을 <code class=\"language-text\">List&lt;A></code>로 하는 대신, 상한이 <code class=\"language-text\">A</code>인 타입 매개변수 <code class=\"language-text\">T</code>를 정의하고 매개변수 타입을 <code class=\"language-text\">List&lt;T></code>로 해야 한다.</strong></li>\n<li><strong>제네릭 타입의 값을 인자로 받는 모든 함수를 동일하게 제네릭 함수로 만들어야 한다.</strong></li>\n</ol>\n<blockquote>\n<p>그럼 그냥 <code class=\"language-text\">Marathoner</code>가 <code class=\"language-text\">Person</code>의 서브타입인 것처럼 <code class=\"language-text\">List&lt;Marathoner></code>도 <code class=\"language-text\">List&lt;Person></code>의 서브타입이면 안 될까?</p>\n</blockquote>\n<p>즉, <strong>\"B가 A의 서브타입일 때 <code class=\"language-text\">List&lt;B></code>가 <code class=\"language-text\">List&lt;A></code>의 서브타입이도 될까?\"</strong><br>\n<code class=\"language-text\">List&lt;Marathoner></code>가 <code class=\"language-text\">List&lt;Person></code>의 서브타입이 된다고 가정하고 ReadOnlyList와 ReadWriteList의 예제를 보자.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">open class Person(val age: Int)\nclass Marathoner(age: Int) : Person(age)\n\n// 가지고 있는 원소들을 알려줄 뿐, 원소를 추가하거나 제거할 수 없는 리스트다.  \nabstract class ReadOnlyList&lt;T&gt; {\n    abstract fun get(index: Int): T\n}\n\n// [1]\nval marathoners: ReadOnlyList&lt;Marathoner&gt; = ..\nval people: ReadOnlyList&lt;Person&gt; = marathoners\nval person = people.get(0)\nperson.age ..</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">[1]</code>의 상황을 보면 <code class=\"language-text\">Marathoner</code>의 객체들로 구성된 List이지만 <code class=\"language-text\">people</code>에 대입이 가능하고, <code class=\"language-text\">people</code>에서 꺼낸 원소는 <code class=\"language-text\">Person</code> 타입으로 사용할 수 있다.<br>\n런타임에는 <code class=\"language-text\">Marathoner</code> 객체이지만 타입 검사기가 알 수 있는 타입은 <code class=\"language-text\">Person</code>이다.<br>\n하지만 이 상황은 문제가 되지 않는다. Marathoner는 이미 Person의 서브타입이므로 <strong>Marathoner 객체를 Person 객체처럼 사용해도 문제 없다.</strong><br>\n즉, <strong>ReadOnlyList&#x3C;Marathoner> 를 ReadOnlyList&#x3C;Person> 로 취급함으로써 일어날 수 있는 일은 Person 객체를 기대한 곳에서 Marathoner 객체가 나오는 것 뿐이다.</strong></p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">// 가지고 있는 원소들을 알려주고 새 원소를 추가할 수 있다.\nabstract class ReadWriteList&lt;T&gt; {\n    abstract fun get(index: Int): T\n    abstract fun add(element: T)\n}\n\n// [2]\nval marathoners: ReadWriteList&lt;Marathoner&gt; = ..\nval people: ReadWriteList&lt;Person&gt; = marathoners\npeople.add(Person(..))\n\nval marathoner: Marathoner = marathoners.get(0)</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">[2]</code>의 상황을 보면 <code class=\"language-text\">Marathoner</code>의 객체들로 구성된 List를 <code class=\"language-text\">people</code>에 대입하고, <code class=\"language-text\">people</code>에 <code class=\"language-text\">Person</code>을 추가할 때 <strong>Marathoner와 Person이 같은 리스트를 나태나는 문제가 발생한다.</strong><br>\n<code class=\"language-text\">people</code>에 Marathoner 객체와 Person 객체가 동시에 존재할 수 있게 되면서 <strong><code class=\"language-text\">marathoners</code>에 Person 객체가 추가되게 되었다.</strong><br>\n타입 검사기는 <code class=\"language-text\">marathoners</code>에서 꺼낸 원소의 타입은 <code class=\"language-text\">Marathoner</code>라고 믿고있지만 실제로는 <code class=\"language-text\">Person</code> 객체가 반환될 수 있기 때문에 <strong>타입 안전성을 깨트리는 큰 문제다.</strong></p>\n<p>즉, B가 A의 서브타입일 때<br>\n<code class=\"language-text\">ReadOnlyList&lt;B></code>는 <code class=\"language-text\">ReadOnlyList&lt;A></code>의 서브타입이 가능하지만,<br>\n<code class=\"language-text\">ReadWriteList&lt;B></code>는 <code class=\"language-text\">ReadWriteList&lt;A></code>의 서브타입이 불가능하다는 것이다.</p>\n<blockquote>\n<p>원소 읽기만 허용하면 <code class=\"language-text\">List&lt;B></code>는 <code class=\"language-text\">List&lt;A></code>의 서브타입이 될 수 있지만, 원소 쓰기를 허용하면 서브타입이 될 수 없다.</p>\n</blockquote>\n<p>이 내용들로 알 수 있는 사실은 <strong>\"어떤 제네릭 타입은 타입 인자의 서브타입 관계를 보존하지만, 어떤 제네릭 타입은 그렇지 않다.\"</strong> 라는 것이다.<br>\n그러므로 제네릭 타입과 타입 인자 사이의 관계를 분류할 수 있다. 이 분류를 <strong>가변성</strong> 이라고 부른다.</p>\n<p><strong>가변성은 제네릭 타입과 타입 인자 사이의 관계를 뜻하며, 제네릭 타입 사이의 서브타입 관계를 추가로 정의하는 기능이다.</strong><br>\n(하나의 제네릭 타입에서 타입 인자만 다르게 하여 얻은 타입들 사이의 서브타입 관계를 만든다.)</p>\n<h3>공변</h3>\n<p>제네릭 타입이 타인 인자의 서브타입 관계를 보존하는 것이며, <strong>타입 인자가 <code class=\"language-text\">A</code>에서 서브타입인 <code class=\"language-text\">B</code>로 변할 때 <code class=\"language-text\">List&lt;A></code> 역시 <code class=\"language-text\">List&lt;B></code>로 변한다고 말할 수 있다.</strong><br>\n그래서 \"제네릭 타입이 타입 인자와 함께 변한다\"는 뜻을 담아, 이런 가변성을 <strong>공변 (convariance)</strong> 라고 부른다.</p>\n<h3>불변</h3>\n<p>제네릭 타입이 타입 인자의 서브타입 관계를 무시하는 것이며, <strong><code class=\"language-text\">B</code>가 <code class=\"language-text\">A</code>의 서브타입이더라도 <code class=\"language-text\">List&lt;B></code>와 <code class=\"language-text\">List&lt;A></code>는 아무런 관계가 없는 것이다.</strong><br>\n서로 다른 타입인 것이다. 따라서 \"타입 인자가 서브타입으로 변해도 제네릭 타입은 서브타입으로 안 변한다\"는 뜻을 담아, 이런 가변성을 <strong>불변 (invariance)</strong> 이라 부른다.</p>\n<h3>반변</h3>\n<p>여러 번 사용했지만 제네릭 타입이라고 표현하지 않았던 <strong>함수 타입</strong> 이다.<br>\n<strong>\"함수 타입은 매개변수 타입의 서브타입 관계를 뒤집고 결과 타입의 서브타입 관계를 유지한다.\"</strong><br>\n즉, 함수 타입과 결과 타입 사이의 관계는 공변이다. 한편 함수 타입과 매개변수 타입 사이의 관계는 공변도 불변도 아니다.<br>\n여기서 세 번째 가변성이 등장한다.</p>\n<p>세 번째 가변성은 <strong>제네릭 타입이 타입 인자의 서브타입 관계를 뒤집는 것이다.</strong><br>\n결과 타입을 <code class=\"language-text\">C</code>로 고정할 때 <code class=\"language-text\">B</code>가 <code class=\"language-text\">A</code>의 서브타입이면 <code class=\"language-text\">B -> C</code>는 <code class=\"language-text\">A -> C</code>의 <strong>슈퍼 타입이다.</strong><br>\n타입 인자가 <code class=\"language-text\">A</code>에서 서브타입인 <code class=\"language-text\">B</code>로 변할 때 <code class=\"language-text\">A -> C</code>는 타입 인자와는 반대 반향으로 움직여 슈퍼 타입인 <code class=\"language-text\">B -> C</code>로 변한다고도 할 수 있다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 900px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/be7b1988a84f607240aa2c956fdab9a4/951a4/variance.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 17.77777777777778%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAlUlEQVR42k2PCw6AIAxDuf9BNX5Q8Q8qNW8JxiXNxsrazS3LonEc1fe9rusy5Jy/fJ6n5nk23Pctgj71cRwKIXw8Mw5imiZVVWWiwzDoeR6r13VVSkn7vpswNYDnH3Olt22buq6TK44EjmUL3GKMJto0jWXvvdq2Na78R/z/djQ4u65rG2QzerixAcEb/ANxUHguwOwFoNA2xvhlrbwAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"variance\"\n        title=\"\"\n        src=\"/static/be7b1988a84f607240aa2c956fdab9a4/1cfc2/variance.png\"\n        srcset=\"/static/be7b1988a84f607240aa2c956fdab9a4/3684f/variance.png 225w,\n/static/be7b1988a84f607240aa2c956fdab9a4/fc2a6/variance.png 450w,\n/static/be7b1988a84f607240aa2c956fdab9a4/1cfc2/variance.png 900w,\n/static/be7b1988a84f607240aa2c956fdab9a4/21482/variance.png 1350w,\n/static/be7b1988a84f607240aa2c956fdab9a4/951a4/variance.png 1355w\"\n        sizes=\"(max-width: 900px) 100vw, 900px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>즉, <code class=\"language-text\">ReadOnlyList</code>는 원소 타입에 대해 <strong>공변</strong> 이며, <code class=\"language-text\">ReadWriteList</code>는 <strong>불변</strong> 이다.<br>\n마지막으로 함수 타입은 매개변수 타입에 대해서는 <strong>반변</strong> 이고, 결과 타입에 대해서는 <strong>공변</strong> 이다.</p>\n<h3>각 제네릭 타입의 가변성을 결정하는 일반적인 방법</h3>\n<p>논의를 간단하게 만들기 위해 타입 매개변수가 하나뿐인 제네릭 타입만 고려한다.<br>\n제네릭 타임의 이름은 <code class=\"language-text\">G</code>, 타입 매개변수의 이름은 <code class=\"language-text\">T</code>라고 하자.</p>\n<blockquote>\n<p><code class=\"language-text\">G</code>가 <code class=\"language-text\">T</code>를 출력에만 사용하면 <strong>공변</strong> , 입력에만 사용하면 <strong>반변</strong> , 출력과 입력 모두에 사용하면 <strong>불변</strong> 이다.</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th align=\"center\"><code class=\"language-text\">G</code>에 해당하는 타입</th>\n<th align=\"center\"><code class=\"language-text\">T</code>를 출력에 사용</th>\n<th align=\"center\"><code class=\"language-text\">T</code>를 입력에 사용</th>\n<th align=\"center\"><strong>가변성</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">ReadOnlyList&#x3C;T></td>\n<td align=\"center\">O</td>\n<td align=\"center\">X</td>\n<td align=\"center\"><strong>공변</strong></td>\n</tr>\n<tr>\n<td align=\"center\">ReadWriteList&#x3C;T></td>\n<td align=\"center\">O</td>\n<td align=\"center\">O</td>\n<td align=\"center\"><strong>불변</strong></td>\n</tr>\n<tr>\n<td align=\"center\">Int -> T</td>\n<td align=\"center\">O</td>\n<td align=\"center\">X</td>\n<td align=\"center\"><strong>공변</strong></td>\n</tr>\n<tr>\n<td align=\"center\">T -> Int</td>\n<td align=\"center\">X</td>\n<td align=\"center\">O</td>\n<td align=\"center\"><strong>반변</strong></td>\n</tr>\n</tbody>\n</table>\n<p>즉, <strong>타입 매개변수를 출력에만 사용하는지, 입력에만 사용하는지, 둘 모두에 사용하는지 보면 가변성을 판단할 수 있다.</strong><br>\n타입 매개변수를 사용한 곳에 따라 달라진다는 것이다.</p>\n<h3 id=\"정의할-때-가변성-지정하기\" style=\"position:relative;\">정의할 때 가변성 지정하기<a href=\"#%EC%A0%95%EC%9D%98%ED%95%A0-%EB%95%8C-%EA%B0%80%EB%B3%80%EC%84%B1-%EC%A7%80%EC%A0%95%ED%95%98%EA%B8%B0\" aria-label=\"정의할 때 가변성 지정하기 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>가변성은 각 제네릭 타입의 고유한 속성이다. 따라서 <strong>제네릭 타입을 정의할 때 가변성을 지정하는게 가장 직관적이다.</strong><br>\n개발자는 제네릭 타입의 각 매개변수에 가변성을 표시함으로써 공변, 반변, 불변 중 하나를 고를 수 있다.</p>\n<h3>불변</h3>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">abstract class List&lt;T&gt; {\n    abstract fun length(): Int\n    abstract fun get(index: Int): T\n    abstract fun add(element: T)\n}</code>\n        </deckgo-highlight-code>\n<h3>공변</h3>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">abstract class ReadOnlyList&lt;out T&gt; {\n    abstract fun get(index: Int): T\n}\n\nval marathoners: ReadOnlyList&lt;Marathoner&gt; = ..\nval people: ReadOnlyList&lt;Person&gt; = marathoners\nval person = people.get(0)\n\nfun averageAge(people: ReadOnlyList&lt;Person&gt;): Int = ..\n\naverageAge(marathoners)\naverageAge(people)</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">ReadOnlyList&lt;out T></code>는 해당 타입 매개변수가 출력에만 사용됨을 뜻하며 원소를 추가할 수 없는 대신 공변인 리스트를 정의할 수 있다.<br>\n<code class=\"language-text\">T</code>를 출력에만 사용한다고 했으니, <code class=\"language-text\">T</code>를 메서드 결과 타입으로 사용할 수 있는 있어도 매개변수 타입으로 사용할 수는 없다.<br>\n<code class=\"language-text\">ReadOnlyList</code>는 <strong>공변이므로 타입 인자의 서브타입 관계를 보존한다.</strong></p>\n<p>이제 <code class=\"language-text\">averageAge</code> 함수를 제네릭 함수로 만들지 않고 타입 매개변수 제한없이 사용할 수 있다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 783px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/16c3998ca212b2bd0b7a9d4af61c113e/e51a6/genericOut.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 47.55555555555556%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAACIElEQVR42lWSCU8aURhF+f9/o6klrbUa05q2VtkGZgWhpGosGlkEHBHQYVhmOb2DTVMnuXnztvO+9+7NkaZkX5rGJKsJK/+c8WWBUfuI+9YhfnOfSWufzfUx0W2BqF8lHp8RP15t12f7/gK2TS5NE+KgTzS0SfsG65syF8VdLku7dMx9ru09OvZHknENJjb4JsmgRNIvEXdLRHe29g+ESgQVMPKbpL0y3DlSXYu1aWIST6pcuHnaVp6rn59oWTs0K284V39zb0iCScl9Bj7Rf4s02ajCngHDumAecb9C7JdJZhbJ3GEl8GJUZvrrmKl3wswqMKsWCB2DsF4lbKm9KLK+E7z/neihTY5hQzCXdFBTVao0EHzuwrNHMrUJmyVCyxTEYSGt6h6BrXHX2Y4tbUd9g2XnlI2g/4BxX5XNdd0n7wW4cAmvdLrj4RslrHdv8d7naXx4j5PfwZZc9Ttfv7BpNFh4NRY3h7pyt0IGTQcW0bioytwXaOCx0VxQq7D26qwarqpzWdadV+2qoTm3wdw8UEK8zJQWidxi4MqQDFraviFPWZUe69uKGsmqsXQFcD2W2QHSUlcOzAJza49QccqczqXyOrM9GgnYq5B2DeLeKfGwSOIbpDO97UOZVU9mXP4gaH8jODsiaH7muX1AeCOHgy7bzGSxeR3sR+LZb2JFIB55ck7x6CrMvaLyJg3LiodJ5LtEs3OS9fQlf/8F+w96RNZi2cqAkAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"genericOut\"\n        title=\"\"\n        src=\"/static/16c3998ca212b2bd0b7a9d4af61c113e/e51a6/genericOut.png\"\n        srcset=\"/static/16c3998ca212b2bd0b7a9d4af61c113e/3684f/genericOut.png 225w,\n/static/16c3998ca212b2bd0b7a9d4af61c113e/fc2a6/genericOut.png 450w,\n/static/16c3998ca212b2bd0b7a9d4af61c113e/e51a6/genericOut.png 783w\"\n        sizes=\"(max-width: 783px) 100vw, 783px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">abstract class ReadOnlyList&lt;T&gt; {\n    abstract fun get(index: Int): T\n}</code>\n        </deckgo-highlight-code>\n<p>위와 같이 선언된 List는 원소를 추가할 수도 없는 주제에 불변이기까지 한 불편한 리스트일 뿐이다.<br>\n<code class=\"language-text\">T</code>를 입력에 사용하는 메서드를 추가하려고 계획 중인 게 아니라면, 굳이 이런 리스트를 정의할 필요는 없다.</p>\n<h3>반변</h3>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">abstract class Map&lt;in K, V&gt; {\n    abstract fun size(): Int\n    abstract fun get(key: K): V\n    abstract fun add(key: K, value: V)\n}</code>\n        </deckgo-highlight-code>\n<p>타입 매개변수를 반변으로 만들고 싶을 때는 <code class=\"language-text\">in</code>을 붙여 <strong>그 타입 매개변수를 입력에만 사용한다는 뜻이다.</strong><br>\n<code class=\"language-text\">abstract fun getKey(value: V): K</code> 이 메서드는 컴파일 에러를 발생시킨다.</p>\n<p><code class=\"language-text\">Map&lt;in K, V></code> 클래스는 두 개의 타입 매개변수를 가지며, <code class=\"language-text\">in</code>으로 가변성이 지정된 <code class=\"language-text\">K</code>는 <code class=\"language-text\">get()</code>과 <code class=\"language-text\">add()</code>에서 입력으로만 사용되었기 때문에 <strong>반변</strong> 으로 정의해도 타입 검사기가 문제 삼지 않는다.<br>\n반면 <code class=\"language-text\">V</code>는 <code class=\"language-text\">get()</code>에서는 출력, <code class=\"language-text\">add()</code>에서는 입력으로 사용되었기 때문에 <strong>반드시 불변이어야 한다.</strong></p>\n<p>열쇠 타입에 대해 반변이므로 <code class=\"language-text\">B</code>가 <code class=\"language-text\">A</code>의 서브타입일 때 <code class=\"language-text\">Map&lt;A, V></code>가 <code class=\"language-text\">Map&lt;B, V></code>의 서브타입이다.<br>\n예를 들면 <code class=\"language-text\">Map&lt;Person, Int></code>가 <code class=\"language-text\">Map&lt;Marathoner, Int></code>의 서브타입이다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">val personKey: Map&lt;Person, Int&gt; = ..\npersonKey.add(Person(10), 1)\npersonKey.add(Marathoner(10), 1)\n\nval marathonerKey: Map&lt;Marathoner, Int&gt; = ..\nmarathonerKey.add(Person(10), 1)        // 컴파일 에러\nmarathonerKey.add(Marathoner(10), 1)</code>\n        </deckgo-highlight-code>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 783px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/6b9822e8b29a39a5df81410ae89c62ce/e51a6/genericIn.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 47.55555555555556%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAACJUlEQVR42k2SiU7bUBBF8//fUVGVqiyNuggUwFmI4y0hhCYFKpTVZIM4OI4d2+907FQVlkbvWfacuTNzCyhF9iiVoKIlm+kdbveS2d1PZu0iL50iy9tTto9nJH2NZFQnmbZIXh5Iw2We9w+QHwWlUhJ/ROwaMLlm3SvRPj+gq32mWz7kyTymb5+wGWiwNEifr0lH5TySQZl4Ykj+WFCpQAUYz29Qw4rATAkH5ZqohQ5vBt7kglv9I/ftI3rOIT3rE16/hFrq7KYCm1VIZxn4Qu5tVLoThcMauI7AbGmnSjyX6qsGam2RrEx8t4wnql+tEp6h4RtVArNG4EjcSPQ0oonAR+fEiw4F3KbALNRYZrMUpb7APUsU2qSvDUkqE5oGkW2ztSy2cga2RWCZhNm7IUWNGts/l+wE+h+YjES+J3Nc23vgRn5+KBM0JLFpE7cc7r8X0Q8+cHv8hV9fT2QqOlHLJpQiG7vO5qkoLQ+qZFA1bhBPZfBv1h7q2+zkm1+v5gkZNHSkiGOKSjO/h02LqOmI0iaefko4t7OltEllW4wt0hy6nyHrTKVN1K/KIdGo5y2GVqbIyWNrSrv6FV7jiGB0nW+6oGTX2drjZwEOq6hBjWR4SeJqpPMaaiWzXVQIh1cEv0v4nTP81g/8m2+8dU4JnmTD/oDcM5lt3hs7DV9ks48kYoHkWeY2qknbV8RDTfwm4VbEHro4wSJedUmj173/3hn7Lx1j2Krz2R/8AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"genericIn\"\n        title=\"\"\n        src=\"/static/6b9822e8b29a39a5df81410ae89c62ce/e51a6/genericIn.png\"\n        srcset=\"/static/6b9822e8b29a39a5df81410ae89c62ce/3684f/genericIn.png 225w,\n/static/6b9822e8b29a39a5df81410ae89c62ce/fc2a6/genericIn.png 450w,\n/static/6b9822e8b29a39a5df81410ae89c62ce/e51a6/genericIn.png 783w\"\n        sizes=\"(max-width: 783px) 100vw, 783px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p><strong>정의할 때 가변성을 지정하는 방법은 이해하기 쉬운 대신 클래스를 정의할 때 큰 제약이 생긴다는 문제가 있다.</strong><br>\n타입을 공변으로 만든다면 타입 매개변수를 입력에 사용하는 절반을 모두 포기해야 하고, 반변으로 만든나면 나머지 절반을 포기해야 한다.<br>\n그러니 공변이나 반변을 선택하면 <strong>반쪽짜리 클래스를 만들 수 밖에 없는 것이다.</strong><br>\n함수형 프로그래밍에서는 대부분의 경우 수정할 수 없는 자료구조만 사용해 프로그램을 작성하기 때문에 함수형 언어에서는 이 단점이 상대적으로 덜 드러난다.</p>\n<blockquote>\n<p>서브타입 관계를 추가하는 대신 기능이 빠진 타입을 만들거나, 기능을 다 갖춘 타입을 만드는 대신 서브타입 관계를 포기하거나, 개발자는 반드시 이 둘 중 하나를 골라야 한다.</p>\n</blockquote>\n<h3 id=\"사용할-때-가변성-지정하기\" style=\"position:relative;\">사용할 때 가변성 지정하기<a href=\"#%EC%82%AC%EC%9A%A9%ED%95%A0-%EB%95%8C-%EA%B0%80%EB%B3%80%EC%84%B1-%EC%A7%80%EC%A0%95%ED%95%98%EA%B8%B0\" aria-label=\"사용할 때 가변성 지정하기 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>제네릭 타입을 사용할 때 가변성을 지정하는 경우, 제네릭 타입을 정의할 때는 가변성을 지정할 수 없다.<br>\n<strong>모든 제네릭 타입은 불변으로 정의되며 타입 매개변수를 아무 데서나 사용할 수 있다.</strong></p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">abstract class ReadWriteList&lt;T&gt; {\n    abstract fun length(): Int\n    abstract fun get(index: Int): T\n    abstract fun add(element: T)\n}</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">val onlyReadPeople: ReadWriteList&lt;out Person&gt; = ..\nval size = onlyReadPeople.length()\nval person: Person = onlyReadPeople.get(0)\nonlyReadPeople.add(Person(10)) // 컴파일 에러</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">onlyReadPeople</code>은 출력 기능만 사용할 수 있고, 원소 타입이 매개변수 타입으로 사용되지 않는 메서드만 사용할 수 있다는 뜻이다.<br>\n그리고 <strong>\"A를 출력과 입력에 모두 사용할 수 있는 불변 <code class=\"language-text\">List&lt;A></code>는 A를 출력에 사용할 수 있는 리스트다.\"</strong> 가 사실이기 때문에 <code class=\"language-text\">List&lt;A></code>는 <code class=\"language-text\">List&lt;out A></code>의 서브타입이다.<br>\n<code class=\"language-text\">ReadWriteList&lt;T></code>는 불변이지만 <code class=\"language-text\">ReadWriteList&lt;out Person></code>는 공변이다. 따라서 <strong><code class=\"language-text\">B</code>가 <code class=\"language-text\">A</code>의 서브타입일 때 <code class=\"language-text\">List&lt;out B></code>는 <code class=\"language-text\">List&lt;out A></code>의 서브타입이다.</strong></p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">fun averageAge(people: ReadWriteList&lt;out Person&gt;): Int {\n    people.get(0)\n    people.add(Person(10)) // 컴파일 에러\n}\n\nval onlyReadPeople: ReadWriteList&lt;out Person&gt; = ..\naverageAge(onlyReadPeople)\n\nval onlyReadMarathoners: ReadWriteList&lt;out Marathoner&gt; = ..\naverageAge(onlyReadMarathoners)\n\nval readWriteMarathoner: ReadWriteList&lt;Marathoner&gt; = ..\naverageAge(readWriteMarathoner)</code>\n        </deckgo-highlight-code>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 900px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/0372e7ff130078424ceddb061324fb5c/38124/chainingOut.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 43.55555555555555%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB5ElEQVR42k1S2XLaQBDk//8klVRBnASwzCVucTix8+ALgYQOTscIJ0KwR6cRhMpWTWm1s9vTM90ZnJfWAvttiG34E++uhWTagvKbUFMT2qtD+w3osA0160Et76DebKh4mb77f2W0EhDRBHreR/RUxrj9CY51hei5AcwHBGwhscvYHWNUgnRrLGBCOSXmaixgQW2nF+CMXNzyQhsIBgT4DqzugeUPKK/BB1XEowoL5OD0chh3stg+FrEfGwQ3ED/nET/mIOxvkCyu5Y4MvQ7ANnTYgQ4sRh/SqZKJyQI9Bs/S/BAIm9g8FAmexcT6iFHnA7zhZ+zta0j7CyTJZNRrF3/CGt5DE4d1C3LGr1uAWHewntxgxYjndai5CcG9Wlh4c0tY2kaai7wy9KILMT4yz5PhrwYTZdj3OfzmQ71uY+98RbKoYPZiIHgqYONzbqtmCiiCMsHy8B7yaW5pF3Hwr3F4yUKs7pA5HFULapzbsbVj24O0beHcUNkSz5r8Z4Sc8eyWcyVbr8oc2foG5OTqBMbxaJmQoZaQkQsZ9nmJ80wF6qePtdeFcusnENrnFNw7NQpRSNsUQfussjypfPEh7aN2K6jNCJI+kyHt4LfOapsUqQJJm8iAc14MeY8+TF4vQP98+Beos5JXTnVBiAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"chainingOut\"\n        title=\"\"\n        src=\"/static/0372e7ff130078424ceddb061324fb5c/1cfc2/chainingOut.png\"\n        srcset=\"/static/0372e7ff130078424ceddb061324fb5c/3684f/chainingOut.png 225w,\n/static/0372e7ff130078424ceddb061324fb5c/fc2a6/chainingOut.png 450w,\n/static/0372e7ff130078424ceddb061324fb5c/1cfc2/chainingOut.png 900w,\n/static/0372e7ff130078424ceddb061324fb5c/38124/chainingOut.png 953w\"\n        sizes=\"(max-width: 900px) 100vw, 900px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p><code class=\"language-text\">averageAge()</code> 함수와 같이 새로운 <code class=\"language-text\">&lt;out Person></code> 타입을 통해 함수 내부에서는 출력의 용도로만 사용하겠다고 선언하여 공변으로 지정하여 사용할 수 있다.</p>\n<p><code class=\"language-text\">ReadWriteList&lt;in A></code> 역시 <code class=\"language-text\">ReadWriteList&lt;A></code>와 비슷하게 <code class=\"language-text\">A</code> 타입의 원소들로 구성된 리스트를 나타내지만 <strong>입력 기능만 사용할 수 있다는 차이가 있다.</strong><br>\n정확히 말하면 <strong>메서드 중 원소 타입이 결과 타입으로 사용되지 않는 메서드만 사용할 수 있다.</strong></p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">val readWritePeople: ReadWriteList&lt;in Person&gt; = TODO()\nval people: Any? = readWritePeople.get(0)\nreadWritePeople.add(Person(10))\nreadWritePeople.add(Marathoner(10))\n\nval readWriteMarathoners: ReadWriteList&lt;in Marathoner&gt; = TODO()\nval marathoner: Any? = readWriteMarathoners.get(0)\nreadWriteMarathoners.add(Marathoner(10))</code>\n        </deckgo-highlight-code>\n<p><strong>\"A를 출력과 입력에 모두 사용할 수 있는 불변 <code class=\"language-text\">List&lt;A></code>는 A를 입력에 사용할 수 있는 리스트다.\"</strong> 가 사실이기 때문에 <code class=\"language-text\">List&lt;A></code>는 <code class=\"language-text\">List&lt;in A></code>의 서브타입이다.<br>\n따라서 <strong><code class=\"language-text\">B</code>가 <code class=\"language-text\">A</code>의 서브타입일 때 <code class=\"language-text\">List&lt;in A></code>는 <code class=\"language-text\">List&lt;in B></code>의 서브타입이다.</strong></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 900px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/48da0b2963cedd8e26b04c7ad7f470a3/38124/chainingIn.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 43.55555555555555%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB5ElEQVR42k1Si27aQBDk/z+lqgRJ1EDAPEwMmEdQkqqqmhrw2ca8AoEkCo7vMR2bJOpJq1tbtzs7s1PAx9E6xesuwEv8EwffxcvUhgqvoQOb0YZhbuZd6MUAen0HvZ9Av61hjMT/p2C0hH6eIZ27EP0ipt3v8LpFiOElVODCRF0kkzqOHoO3FDZMBiIsArWgY5f14qtxQa3GRO8C8Q1AZGzuGbf8dljQxPvMhhicwR+UMOuX2NSC9C0C1BgVpN4F1JTgyxGMOnLCyAWWQ5i4xyYD0hpB+U1O0uL/AaMPQ5pYjKHDNhA52P+uYeJ+QzguIvHbfE8Q7xyKwxSSxTWeAguHqIXXuIU0biIVFcjHHh5ntTzelixa2pDMNQHUrodd0MBONPJcr1zIaYVsLlF48suY3J8zShC/LnCMWSh+IFk1sPhbxfxPGXuCmY3DhpwkqkNtHSy9KuIHUt52kEZXSB+KkJs7argekQ6prPvAihFTi2hIGjXeFuk6lMHJpchpc+PSr0NHnDas4t07OzWjPEYl1NAoqIMPNR/yAXXMFsQ8KzYhNyjaeZOTfT4sRH3lpEyaV5CZlZ4DZH3yLX/6J7fPcUN/eVDctor7nKJDkJMXVaYXbaLmHajVzcmHyfar0acP/wGdHpKfkVW4jAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"chainingIn\"\n        title=\"\"\n        src=\"/static/48da0b2963cedd8e26b04c7ad7f470a3/1cfc2/chainingIn.png\"\n        srcset=\"/static/48da0b2963cedd8e26b04c7ad7f470a3/3684f/chainingIn.png 225w,\n/static/48da0b2963cedd8e26b04c7ad7f470a3/fc2a6/chainingIn.png 450w,\n/static/48da0b2963cedd8e26b04c7ad7f470a3/1cfc2/chainingIn.png 900w,\n/static/48da0b2963cedd8e26b04c7ad7f470a3/38124/chainingIn.png 953w\"\n        sizes=\"(max-width: 900px) 100vw, 900px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">fun addPerson(people: ReadWriteList&lt;in Person&gt;) {\n    people.add(Person(..))\n    people.add(Marathoner(..))\n}\n\nval readWritePeople1: ReadWriteList&lt;in Person&gt; = ..\nval readWritePeople2: ReadWriteList&lt;Person&gt; = ..\naddPerson(readWritePeople1)\naddPerson(readWritePeople2)\n\nval readWriteMarathoners1: ReadWriteList&lt;in Marathoner&gt; = ..\nval readWriteMarathoners2: ReadWriteList&lt;Marathoner&gt; = ..\naddPerson(readWriteMarathoners1)    // 컴파일 에러\naddPerson(readWriteMarathoners2)    // 컴파일 에러</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">addPerson</code> 함수는 <code class=\"language-text\">ReadWriteList&lt;in Person></code> 반변으로 지정되어 있기 때문에 <code class=\"language-text\">ReadWriteList&lt;Marathoner></code>는 <code class=\"language-text\">Person</code>의 서브타입이긴 하지만 <code class=\"language-text\">addPerson</code>의 인자로 사용될 수 없다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">fun addMarathoner(people: ReadWriteList&lt;in Marathoner&gt;) {\n    people.add(Person(..))      // 컴파일 에러\n    people.add(Marathoner(..))\n}\n\nval readWritePeople1: ReadWriteList&lt;in Person&gt; = ..\nval readWritePeople2: ReadWriteList&lt;Person&gt; = ..\naddMarathoner(readWritePeople1)\naddMarathoner(readWritePeople2)\n\nval readWriteMarathoners1: ReadWriteList&lt;in Marathoner&gt; = ..\nval readWriteMarathoners2: ReadWriteList&lt;Marathoner&gt; = ..\naddMarathoner(readWriteMarathoners1)\naddMarathoner(readWriteMarathoners2)</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">ReadWriteList&lt;in Marathoner></code> 반변으로 지정하면 <code class=\"language-text\">List&lt;Person></code>은 <code class=\"language-text\">List&lt;in Marathoner></code>의 서브타입이기 때문에 <code class=\"language-text\">addMarathoner</code> 함수 호출이 다 가능해진다.<br>\n<code class=\"language-text\">List&lt;in Marathoner></code>에는 <code class=\"language-text\">Marathoner</code>가 보장되어야 하기 때문에 더 작은 의미를 가지는 <code class=\"language-text\">Person</code>을 직접 추가하지는 못한다.<br>\n이는 <strong>Person 리스트에 Marathoner 객체를 추가해도 괜찮고 Marathoner 리스트에 Person 객체를 추가하지 못한다는 직관과 일치한다.</strong></p>\n<p>추가적으로 자바에서는 <code class=\"language-text\">out</code> 대신 <code class=\"language-text\">? extends</code>, <code class=\"language-text\">in</code> 대신 <code class=\"language-text\">? super</code>를 사용하여 공변과 반변을 나타낸다.<br>\n<code class=\"language-text\">G&lt;? extends A></code>와 <code class=\"language-text\">G&lt;? super A></code> 형태의 타입은 만들 수 있지만, <code class=\"language-text\">G&lt;A extends ?></code>나 <code class=\"language-text\">G&lt;A super B></code> 등 여타 형태의 타입은 만들 수 없다.<br>\n그러니 <code class=\"language-text\">? extends</code>와 <code class=\"language-text\">? super</code>에서 <code class=\"language-text\">?</code>와 <code class=\"language-text\">extends/super</code>를 <strong>분리하여 생각하지 말고 하나의 키워드로 바라보는 것이 좋다.</strong></p>\n<h1 id=\"오버로딩에-의한-다형성\" style=\"position:relative;\">오버로딩에 의한 다형성<a href=\"#%EC%98%A4%EB%B2%84%EB%A1%9C%EB%94%A9%EC%97%90-%EC%9D%98%ED%95%9C-%EB%8B%A4%ED%98%95%EC%84%B1\" aria-label=\"오버로딩에 의한 다형성 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>한 함수가 여러 타입의 인자를 받아야 할 때 사용할 수 있다.<br>\n같은 이름의 함수들을 매개변수 타입을 서로 다르게 하여 여러 개 정의하는 것이다.<br>\n함수 오버로딩도 다형성을 만들어내는 방법 중 한 가지다.</p>\n<deckgo-highlight-code language=\"kotlin\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">fun aging(person: Person) = Person(person.age + 1)\nfun aging(marathoner: Marathoner) = Marathoner(marathoner.age + 1)</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">aging</code> 두 함수 중에 어느 것을 호출할지는 언어 수준에서 자동으로 결정된다.<br>\n함수 선택의 가장 기본적인 규칙은 <strong>인자의 타입에 맞는 함수를 고른다.</strong></p>\n<p>오버로딩은 어려운 개념이 아니다. 하지만 오버로딩에 의한 다형성을 서브타입에 의한 다형성이나 매개변수에 의한 다형성과 함께 사용하면 더 많은 개념이 등장한다.</p>","frontmatter":{"title":"다형성과 가변성에 대해","date":"February 11, 2024","description":null,"tags":["다형성"]},"tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EB%8B%A4%ED%98%95%EC%84%B1\">다형성</a></p>\n<ul>\n<li>\n<p><a href=\"#%EC%84%9C%EB%B8%8C%ED%83%80%EC%9E%85%EC%97%90-%EC%9D%98%ED%95%9C-%EB%8B%A4%ED%98%95%EC%84%B1\">서브타입에 의한 다형성</a></p>\n<ul>\n<li><a href=\"#%EC%9D%B4%EB%A6%84%EC%97%90-%EC%9D%98%ED%95%9C-%EC%84%9C%EB%B8%8C%ED%83%80%EC%9E%85\">이름에 의한 서브타입</a></li>\n<li><a href=\"#%EA%B5%AC%EC%A1%B0%EC%97%90-%EC%9D%98%ED%95%9C-%EC%84%9C%EB%B8%8C%ED%83%80%EC%9E%85\">구조에 의한 서브타입</a></li>\n<li><a href=\"#%EC%A7%91%ED%95%A9%EB%A1%A0%EC%A0%81-%EC%84%9C%EB%B8%8C%ED%83%80%EC%9E%85\">집합론적 서브타입</a></li>\n<li><a href=\"#%ED%95%A8%EC%88%98%EC%99%80-%EC%84%9C%EB%B8%8C%ED%83%80%EC%9E%85\">함수와 서브타입</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98%EC%97%90-%EC%9D%98%ED%95%9C-%EB%8B%A4%ED%98%95%EC%84%B1\">매개변수에 의한 다형성</a></p>\n<ul>\n<li><a href=\"#%EB%AC%B4%EC%97%87%EC%9D%B4%EB%93%A0-%ED%83%80%EC%9E%85\">무엇이든 타입</a></li>\n<li><a href=\"#%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-%ED%83%80%EC%9E%85\">무엇인가 타입</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%91%90-%EB%8B%A4%ED%98%95%EC%84%B1%EC%9D%98-%EB%A7%8C%EB%82%A8\">두 다형성의 만남</a></p>\n<ul>\n<li>\n<p><a href=\"#%EC%A0%9C%EB%84%A4%EB%A6%AD-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%EC%83%81%EC%86%8D\">제네릭 클래스와 상속</a></p>\n</li>\n<li>\n<p><a href=\"#%ED%83%80%EC%9E%85-%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98-%EC%A0%9C%ED%95%9C\">타입 매개변수 제한</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%9E%AC%EA%B7%80%EC%A0%81-%ED%83%80%EC%9E%85-%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98-%EC%A0%9C%ED%95%9C\">재귀적 타입 매개변수 제한</a></p>\n</li>\n<li>\n<p><a href=\"#%EA%B0%80%EB%B3%80%EC%84%B1\">가변성</a></p>\n<ul>\n<li><a href=\"#%EC%A0%95%EC%9D%98%ED%95%A0-%EB%95%8C-%EA%B0%80%EB%B3%80%EC%84%B1-%EC%A7%80%EC%A0%95%ED%95%98%EA%B8%B0\">정의할 때 가변성 지정하기</a></li>\n<li><a href=\"#%EC%82%AC%EC%9A%A9%ED%95%A0-%EB%95%8C-%EA%B0%80%EB%B3%80%EC%84%B1-%EC%A7%80%EC%A0%95%ED%95%98%EA%B8%B0\">사용할 때 가변성 지정하기</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%98%A4%EB%B2%84%EB%A1%9C%EB%94%A9%EC%97%90-%EC%9D%98%ED%95%9C-%EB%8B%A4%ED%98%95%EC%84%B1\">오버로딩에 의한 다형성</a></p>\n</li>\n</ul>"},"previous":{"fields":{"slug":"/2023y/retrospect/"},"frontmatter":{"title":"2023년 회고"}},"next":{"fields":{"slug":"/2024y/transaction/"},"frontmatter":{"title":"트랜잭션과 잠금"}}},"pageContext":{"id":"57ed670b-72c1-5c05-aaa0-b691a4c0e34c","previousPostId":"a81d0024-a600-58f9-9a17-cfc08d50ca78","nextPostId":"099bd161-b615-5200-ab96-c2a0d6a8dfa3"}},"staticQueryHashes":["230163734","3589320610"],"slicesMap":{}}