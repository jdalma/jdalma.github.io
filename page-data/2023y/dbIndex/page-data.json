{"componentChunkName":"component---src-templates-blog-post-js","path":"/2023y/dbIndex/","result":{"data":{"site":{"siteMetadata":{"title":"코딩 주머니"}},"markdownRemark":{"id":"0ad0f8f7-adf0-51ae-ba82-8d2e202f7ccd","excerpt":"서비스에 장애를 일으킨 이유를 재현해보고 정리하기 위해 작성한다.  EXPLAIN 출력 형식 문제 분석  FIR.FIRST_COL FIR.SECOND_COL SEC.FIRST_COL SEC.SECOND_COL 1 20230330 1 20230330 ... ... ... ...…","html":"<blockquote>\n<p>서비스에 장애를 일으킨 이유를 재현해보고 정리하기 위해 작성한다.<br>\n<a href=\"https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain-join-types\"><code class=\"language-text\">mysql docs</code> EXPLAIN 출력 형식</a></p>\n</blockquote>\n<h1 id=\"문제-분석\" style=\"position:relative;\">문제 분석<a href=\"#%EB%AC%B8%EC%A0%9C-%EB%B6%84%EC%84%9D\" aria-label=\"문제 분석 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/8ecfaea75db744b61b40da9bff8ae5a5/31493/case1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 31.645569620253163%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAABWUlEQVR42nXRXW/SYADF8X6YOenzlLYiUOkbfaAvUEILfaEszGnUJcsWJ5rpvZ/8r3beeOHFLznJOXdHG5oW0zDAjxQqzph5PirJCNWS0XiMLg10KRmNJzhhSKCWRMuk54VRvw0ixevpFMM00ebWkE/rhIe25vvba+73JU/XJx72JQd3SiYvScULTr7D7W7D+arj6/HwvKl2nLsDd+WWm3DGG2uIVo0kP8uIc9vwZbflW1NxGys+KI/3c5dCXLAVFzytHH40BY+7gs/Fhvs86/t3gcPN3OVx4aFMgTYZ21R7n3xTsF7lPW/mEvoBgethSYElJF3jcOhqqvpI3XTEcUoYhCi1QEWKOE6w7VdoQkguX0oGgwG6EAx0HSHlP3RhULcu+2NLc/pI2V6xLmuiOCVZb56tcizbRpNSYhgSKQ3+5P/JsglpviLLCxZJRppv8cN5L/jL/H3KL8Yj063ICzP3AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"case1\"\n        title=\"\"\n        src=\"/static/8ecfaea75db744b61b40da9bff8ae5a5/f058b/case1.png\"\n        srcset=\"/static/8ecfaea75db744b61b40da9bff8ae5a5/c26ae/case1.png 158w,\n/static/8ecfaea75db744b61b40da9bff8ae5a5/6bdcf/case1.png 315w,\n/static/8ecfaea75db744b61b40da9bff8ae5a5/f058b/case1.png 630w,\n/static/8ecfaea75db744b61b40da9bff8ae5a5/31493/case1.png 664w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">FIR.FIRST_COL</th>\n<th align=\"center\">FIR.SECOND_COL</th>\n<th align=\"center\">SEC.FIRST_COL</th>\n<th align=\"center\">SEC.SECOND_COL</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">20230330</td>\n<td align=\"center\">1</td>\n<td align=\"center\">20230330</td>\n</tr>\n<tr>\n<td align=\"center\">...</td>\n<td align=\"center\">...</td>\n<td align=\"center\">...</td>\n<td align=\"center\">...</td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">20230330</td>\n<td align=\"center\">10</td>\n<td align=\"center\">20230330</td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\">20231231</td>\n<td align=\"center\">11</td>\n<td align=\"center\">20231231</td>\n</tr>\n<tr>\n<td align=\"center\">...</td>\n<td align=\"center\">...</td>\n<td align=\"center\">...</td>\n<td align=\"center\">...</td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\">20231231</td>\n<td align=\"center\">20</td>\n<td align=\"center\">20231231</td>\n</tr>\n</tbody>\n</table>\n<p>두 테이블을 <code class=\"language-text\">SECOND_COL</code> 기준으로 <code class=\"language-text\">INNER JOIN</code>을 사용하여 <code class=\"language-text\">SECOND_TABLE</code>의 데이터들을 가져와야한다.<br>\n<code class=\"language-text\">FIRST_TABLE</code>의 <code class=\"language-text\">SECOND_COL</code>은 <strong>bigint</strong><br>\n<code class=\"language-text\">SECOND_TABLE</code>의 <code class=\"language-text\">SECOND_COL</code>은 <strong>varchar</strong>이며, 인덱스를 지정한 것을 볼 수 있다.</p>\n<ul>\n<li><code class=\"language-text\">FIRST_TABLE</code>에 2건, <code class=\"language-text\">SECOND_TABLE</code>에 20건이 있으며, 두 테이블의 관계는 <strong>1(bigint):N(varchar)</strong> 이다.</li>\n<li>기대하는 결과는 <code class=\"language-text\">SECOND_TABLE</code>의 <strong>탐색 row수가 10건이 나와야한다.</strong></li>\n</ul>\n<deckgo-highlight-code language=\"sql\"  >\n          <code slot=\"code\">explain\nselect COUNT(*)\nfrom FIRST_TABLE FIR inner join\n     SECOND_TABLE SEC\non FIR.SECOND_COL = SEC.SECOND_COL\nwhere FIR.FIRST_COL = 1\n\n# 조인 순서를 바꿔도 결과는 동일하게 20건을 모두 검색한다.\nEXPLAIN\nselect COUNT(*)\nfrom SECOND_TABLE SEC inner join\n     FIRST_TABLE FIR\n     on SEC.SECOND_COL = FIR.SECOND_COL\nwhere FIR.FIRST_COL = 1</code>\n        </deckgo-highlight-code>\n<table>\n<thead>\n<tr>\n<th align=\"center\">[id]</th>\n<th align=\"center\">[select_type]</th>\n<th align=\"center\">[table]</th>\n<th align=\"center\">[partitions]</th>\n<th align=\"center\">[type]</th>\n<th align=\"center\">[possible_keys]</th>\n<th align=\"center\">[key]</th>\n<th align=\"center\">[key_len]</th>\n<th align=\"center\">[ref]</th>\n<th align=\"center\">[rows]</th>\n<th align=\"center\">[filtered]</th>\n<th align=\"center\">[Extra]</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">SIMPLE</td>\n<td align=\"center\">FIR</td>\n<td align=\"center\"></td>\n<td align=\"center\">const</td>\n<td align=\"center\">PRIMARY</td>\n<td align=\"center\">PRIMARY</td>\n<td align=\"center\">4</td>\n<td align=\"center\">const</td>\n<td align=\"center\">1</td>\n<td align=\"center\">100</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">1</td>\n<td align=\"center\">SIMPLE</td>\n<td align=\"center\">SEC</td>\n<td align=\"center\"></td>\n<td align=\"center\">index</td>\n<td align=\"center\">SECOND_COL_INDEX</td>\n<td align=\"center\">SECOND_COL_INDEX</td>\n<td align=\"center\">1023</td>\n<td align=\"center\"></td>\n<td align=\"center\">20</td>\n<td align=\"center\">10</td>\n<td align=\"center\">Using where; Using index</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><code class=\"language-text\">id</code> : 질의문에 사용된 식별자 데이터</li>\n<li><strong><code class=\"language-text\">select_type</code> : <span style=\"background-color:#fff5b1\">SELECT 유형에 대해 설명, <strong>SIMPLE</strong>은 (UNION이나 서브쿼리를 사용하지 않은) 단순 SELECT</strong></span></li>\n<li><code class=\"language-text\">table</code> : 출력 테이블 이름</li>\n<li><strong><code class=\"language-text\">type</code> : <span style=\"background-color:#fff5b1\">조인 유형</span></strong>\n<ul>\n<li><strong>const</strong> : 기본 키나 유니크 제약조건 컬럼을 기준으로 조회할 때, 최대 하나와 일치하는 행이 있다는 것 (매우 빠르다)</li>\n<li><strong>index</strong> : 해당 유형은 두 가지 방식으로 실행된다\n<ul>\n<li>인덱스 트리만 스캔하며 <code class=\"language-text\">Extra</code>열에 인덱스 사용이 표시된다.</li>\n<li>인덱스 순서로 데이터 행을 조회하며 <strong>전체 테이블 스캔이 수행된다.</strong> <code class=\"language-text\">Extra</code>열에 인덱스 사용이 표시되지 않는다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code class=\"language-text\">possible_keys</code> : 데이터를 찾기위해 선택할 수 있는 인덱스를 나타낸다.\n<ul>\n<li>이 열은 <code class=\"language-text\">NULL</code>을 포함해서는 안된다</li>\n</ul>\n</li>\n<li><strong><code class=\"language-text\">key</code> : <span style=\"background-color:#fff5b1\">실제로 선택한 인덱스</span></strong></li>\n<li><code class=\"language-text\">key_len</code> : 선택한 키의 길이</li>\n<li><code class=\"language-text\">ref</code> : 인덱스와 비교한 열</li>\n<li><strong><code class=\"language-text\">rows</code> : <span style=\"background-color:#fff5b1\">검사할 행의 추정치</span></strong></li>\n<li><code class=\"language-text\">filtered</code> : 테이블 조건으로 필터링된 행의 비율</li>\n<li><strong><code class=\"language-text\">Extra</code> : <span style=\"background-color:#fff5b1\">이 쿼리를 해결하는 방법에 대한 추가 정보</span></strong>\n<ul>\n<li><strong>Using Where</strong></li>\n<li><strong>Using index</strong> : 행을 읽기 위해 추가 검색을 수행할 필요 없이 인덱스 트리의 정보만을 사용하여 검색한다.</li>\n<li><strong>Using join buffer (Block Nested Loop)</strong> (현재 상황에서는 표시되지 않지만 문제가 생겼을 당시 표현되었던 힌트)\n<ul>\n<li>Block Nested Loop 알고리즘을 사용하여, 이전 조인의 테이블을 조인 버퍼로 부분적으로 읽은 다음 해당 행을 버퍼에서 사용하여 현재 테이블과의 조인을 수행한다.</li>\n<li>EXPLAIN 출력의 이전 행에 있는 테이블의 키가 버퍼링되고 일치하는 행이 Using join buffer가 나타나는 행이 나타내는 테이블에서 일괄적으로 페치된다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>위의 내용을 보면 <strong>FIRST 테이블은 기본 키가 사용되었고, SECOND 테이블은 인덱스가 사용되었다는 것을 알 수 있지만 <code class=\"language-text\">rows</code>가 20건인 것을 알 수 있다.</strong></p>\n<blockquote>\n<p>MySQL은 필요에 따라 자동으로 문자열을 숫자로 변환하고 그 반대도 마찬가지입니다.<br>\n<a href=\"https://dev.mysql.com/doc/refman/8.0/en/type-conversion.html\"><code class=\"language-text\">mysql docs</code> Type Conversion</a></p>\n</blockquote>\n<p>이 내용 말고는 <strong>타입이 서로 다른 컬럼을 조인할 떄</strong>에 대한 직접적인 내용을 찾지 못 했다.<br>\nchatGPT에 따르면</p>\n<blockquote>\n<p>서로 다른 타입의 컬럼을 조인하면 MySQL은 자동으로 데이터 타입을 변환하여 일치하게 만들려고 시도합니다. 그러나 이러한 자동 타입 변환이 예상치 못한 결과를 초래할 수 있으므로 주의해야 합니다.<br>\n예를 들어, 하나의 테이블의 컬럼이 문자열이고 다른 테이블의 컬럼이 숫자라면, MySQL은 문자열을 숫자로 변환하려고 시도합니다.</p>\n</blockquote>\n<h1 id=\"서로-타입을-바꾸면\" style=\"position:relative;\">서로 타입을 바꾸면?<a href=\"#%EC%84%9C%EB%A1%9C-%ED%83%80%EC%9E%85%EC%9D%84-%EB%B0%94%EA%BE%B8%EB%A9%B4\" aria-label=\"서로 타입을 바꾸면 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>위의 제목과 같이 타입을 바꿔서 해보면 결과는 예측할 수 없다는 것을 알 수 있다.<br>\n<code class=\"language-text\">EXPLAIN</code>과 <code class=\"language-text\">EXPLAIN ANALYZE</code> 비교</p>\n<ul>\n<li><a href=\"https://dev.mysql.com/blog-archive/mysql-explain-analyze/\"><code class=\"language-text\">dev mysql</code> EXPLAIN ANALYZE</a></li>\n</ul>\n<h4>1(bigint):N(varchar) <strong>Join 순서 상관 없음</strong></h4>\n<table>\n<thead>\n<tr>\n<th align=\"center\">[type]</th>\n<th align=\"center\">[possible_keys]</th>\n<th align=\"center\">[key]</th>\n<th align=\"center\">[key_len]</th>\n<th align=\"center\">[ref]</th>\n<th align=\"center\">[rows]</th>\n<th align=\"center\">[filtered]</th>\n<th align=\"center\">[Extra]</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">const</td>\n<td align=\"center\">PRIMARY</td>\n<td align=\"center\">PRIMARY</td>\n<td align=\"center\">4</td>\n<td align=\"center\">const</td>\n<td align=\"center\">1</td>\n<td align=\"center\">100</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">index</td>\n<td align=\"center\">SECOND_COL_INDEX</td>\n<td align=\"center\">SECOND_COL_INDEX</td>\n<td align=\"center\">1023</td>\n<td align=\"center\"></td>\n<td align=\"center\">20</td>\n<td align=\"center\">10</td>\n<td align=\"center\">Using where; Using index</td>\n</tr>\n</tbody>\n</table>\n<deckgo-highlight-code   >\n          <code slot=\"code\">-&gt; Aggregate: count(0)  (cost=0.65 rows=1) (actual time=0.338..0.340 rows=1 loops=1)\n    -&gt; Filter: (SEC.SECOND_COL = &#39;20230330&#39;)  (cost=0.45 rows=2) (actual time=0.178..0.296 rows=10 loops=1)\n        -&gt; Covering index scan on SEC using SECOND_COL_INDEX  (cost=0.45 rows=20) (actual time=0.139..0.216 rows=20 loops=1)</code>\n        </deckgo-highlight-code>\n<ul>\n<li>cost 합 = 1.55</li>\n<li>첫 번째 행을 가져오는 시간 합 = 0.655</li>\n</ul>\n<h4>1(varchar):N(bigint) <strong>FIRST_TABLE FIR inner join SECOND_TABLE SEC</strong></h4>\n<table>\n<thead>\n<tr>\n<th align=\"center\">[type]</th>\n<th align=\"center\">[possible_keys]</th>\n<th align=\"center\">[key]</th>\n<th align=\"center\">[key_len]</th>\n<th align=\"center\">[ref]</th>\n<th align=\"center\">[rows]</th>\n<th align=\"center\">[filtered]</th>\n<th align=\"center\">[Extra]</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">const</td>\n<td align=\"center\">PRIMARY</td>\n<td align=\"center\">PRIMARY</td>\n<td align=\"center\">4</td>\n<td align=\"center\">const</td>\n<td align=\"center\">1</td>\n<td align=\"center\">100</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">ref</td>\n<td align=\"center\">SECOND_COL_INDEX</td>\n<td align=\"center\">SECOND_COL_INDEX</td>\n<td align=\"center\">9</td>\n<td align=\"center\">const</td>\n<td align=\"center\">10</td>\n<td align=\"center\">100</td>\n<td align=\"center\">Using where; Using index</td>\n</tr>\n</tbody>\n</table>\n<deckgo-highlight-code   >\n          <code slot=\"code\">-&gt; Aggregate: count(0)  (cost=2.81 rows=1) (actual time=0.264..0.265 rows=1 loops=1)\n    -&gt; Filter: (&#39;20230330&#39; = SEC.SECOND_COL)  (cost=1.81 rows=10) (actual time=0.138..0.224 rows=10 loops=1)\n        -&gt; Covering index lookup on SEC using SECOND_COL_INDEX (SECOND_COL=&#39;20230330&#39;)  (cost=1.81 rows=10) (actual time=0.118..0.182 rows=10 loops=1)</code>\n        </deckgo-highlight-code>\n<ul>\n<li>cost 합 = 6.43</li>\n<li>첫 번째 행을 가져오는 시간 합 = 0.52</li>\n</ul>\n<h4>1(varchar):N(bigint) <strong>SECOND_TABLE SEC inner join FIRST_TABLE FIR</strong></h4>\n<table>\n<thead>\n<tr>\n<th align=\"center\">[type]</th>\n<th align=\"center\">[possible_keys]</th>\n<th align=\"center\">[key]</th>\n<th align=\"center\">[key_len]</th>\n<th align=\"center\">[ref]</th>\n<th align=\"center\">[rows]</th>\n<th align=\"center\">[filtered]</th>\n<th align=\"center\">[Extra]</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">const</td>\n<td align=\"center\">PRIMARY</td>\n<td align=\"center\">PRIMARY</td>\n<td align=\"center\">4</td>\n<td align=\"center\">const</td>\n<td align=\"center\">1</td>\n<td align=\"center\">100</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">ref</td>\n<td align=\"center\">SECOND_COL_INDEX</td>\n<td align=\"center\">SECOND_COL_INDEX</td>\n<td align=\"center\">9</td>\n<td align=\"center\">const</td>\n<td align=\"center\">1</td>\n<td align=\"center\">100</td>\n<td align=\"center\">Using where; Using index</td>\n</tr>\n</tbody>\n</table>\n<deckgo-highlight-code   >\n          <code slot=\"code\">-&gt; Aggregate: count(0)  (cost=0.45 rows=1) (actual time=0.518..0.521 rows=1 loops=1)\n    -&gt; Filter: (SEC.SECOND_COL = &#39;20230330&#39;)  (cost=0.35 rows=1) (actual time=0.282..0.404 rows=10 loops=1)\n        -&gt; Covering index lookup on SEC using SECOND_COL_INDEX (SECOND_COL=&#39;20230330&#39;)  (cost=0.35 rows=1) (actual time=0.210..0.295 rows=10 loops=1)</code>\n        </deckgo-highlight-code>\n<ul>\n<li>cost 합 = 1.15</li>\n<li>첫 번째 행을 가져오는 시간 합 = 1.01</li>\n</ul>\n<h1 id=\"결론\" style=\"position:relative;\">결론<a href=\"#%EA%B2%B0%EB%A1%A0\" aria-label=\"결론 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>타입이 서로 다른 컬럼을 조인했을 때 <code class=\"language-text\">Extra</code>에 <code class=\"language-text\">Using Index</code>가 출력되지만, 실제로는 20건을 모두 조회하는 것을 확인해보았으며,<br>\n<code class=\"language-text\">1:N</code>관계에서 타입을 반대로 바꾸게 될 경우에는 10건만 조회하고, 조인 순서를 바꾸면 결과가 또 달라지는 것을 확인할 수 있다.<br>\nMySQL의 내부 최적화를 통해 결과가 바뀌는 것이 아닐까 싶다.<br>\n조사하면서 이해하기 힘든 부분이 많은만큼 <strong>가능하면 예측할 수 없는 결과를 만들어내는 이런 경우는 사전에 예방하는게 좋을 것이다.</strong></p>","frontmatter":{"title":"타입이 서로 다른 컬럼을 조인한다면?","date":"March 30, 2023","description":null,"tags":["Lab","db"]},"tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EB%AC%B8%EC%A0%9C-%EB%B6%84%EC%84%9D\">문제 분석</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%84%9C%EB%A1%9C-%ED%83%80%EC%9E%85%EC%9D%84-%EB%B0%94%EA%BE%B8%EB%A9%B4\">서로 타입을 바꾸면?</a></p>\n<ul>\n<li>\n<ul>\n<li>\n<ul>\n<li><a href=\"#1bigintnvarchar-join-%EC%88%9C%EC%84%9C-%EC%83%81%EA%B4%80-%EC%97%86%EC%9D%8C\">1(bigint):N(varchar) <strong>Join 순서 상관 없음</strong></a></li>\n<li><a href=\"#1varcharnbigint-first_table-fir-inner-join-second_table-sec\">1(varchar):N(bigint) <strong>FIRST_TABLE FIR inner join SECOND_TABLE SEC</strong></a></li>\n<li><a href=\"#1varcharnbigint-second_table-sec-inner-join-first_table-fir\">1(varchar):N(bigint) <strong>SECOND_TABLE SEC inner join FIRST_TABLE FIR</strong></a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EA%B2%B0%EB%A1%A0\">결론</a></p>\n</li>\n</ul>"},"previous":{"fields":{"slug":"/2023y/cicd/"},"frontmatter":{"title":"Jenkins CI/CD 구축하기"}},"next":{"fields":{"slug":"/2023y/kotlinFunction/kotlinFunction/"},"frontmatter":{"title":"코틀린의 함수는 어떻게 구현될까?"}}},"pageContext":{"id":"0ad0f8f7-adf0-51ae-ba82-8d2e202f7ccd","previousPostId":"b6b65c5c-5382-5c8a-9d9a-9b5f3e05fe3a","nextPostId":"dd24ae62-84db-5f8e-b21c-0dd43c1dcef3"}},"staticQueryHashes":["230163734","3589320610"],"slicesMap":{}}