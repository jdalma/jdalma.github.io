{"componentChunkName":"component---src-templates-blog-post-js","path":"/2023y/kotlinFunction/kotlinFunction/","result":{"data":{"site":{"siteMetadata":{"title":"코딩 주머니"}},"markdownRemark":{"id":"dd24ae62-84db-5f8e-b21c-0dd43c1dcef3","excerpt":"…","html":"<h1 id=\"의문\" style=\"position:relative;\">의문<a href=\"#%EC%9D%98%EB%AC%B8\" aria-label=\"의문 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<div class=\"gatsby-resp-iframe-wrapper\" style=\"padding-bottom: 26%; position: relative; height: 0; overflow: hidden; margin-bottom: 1.0725rem\" > <iframe src=\"https://www.facebook.com/plugins/post.php?href=https%3A%2F%2Fwww.facebook.com%2Fhika00%2Fposts%2Fpfbid036LeauGbWWn1uW14Qtpengk6tjQDCiYijFMJj2iSZ7tSG5Ls1PzofQ281gcU7BvDLl&amp;show_text=true&amp;width=500\" style=\"border:none;overflow:hidden; position: absolute; top: 0; left: 0; width: 100%; height: 100%; \" scrolling=\"no\" frameborder=\"0\" allowfullscreen=\"true\" allow=\"autoplay; clipboard-write; encrypted-media; picture-in-picture; web-share\"></iframe> </div>\n<p>이 글을 쓰게된 계기는 위의 스터디를 진행하면서 <code class=\"language-text\">자바의 함수 개념과 코틀린의 함수 개념은 완전히 다르다.</code>라는 얘기가 나왔다.<br>\n개인적인 생각으로는 코틀린 코드도 코틀린 컴파일러에 의해 <code class=\"language-text\">.class</code>로 컴파일되는데</p>\n<ul>\n<li><code class=\"language-text\">자바에서 불가능한 것을 코틀린에서 가능하게 할 수 있는것일까?</code></li>\n<li><code class=\"language-text\">코틀린에서 가능하다면 자바에서도 가능한 것이 아닐까?</code></li>\n</ul>\n<p>라는 의문에서 출발한다.</p>\n<p>코틀린에서 함수는 <strong>일급 시민</strong>으로 취급될 수 있고, <strong>고차 함수</strong>로 정의할 수 있다.<br>\n한 마디로, <strong>함수를 변수 취급할 수 있고, 함수 내에서 함수를 반환하는 것이 가능하다는 것이다.</strong><br>\n코틀린의 함수는 어떻게 자바로 작성되는지 확인해보자.(<code class=\"language-text\">@Metadata</code>는 제외)</p>\n<h1 id=\"코틀린의-람다-함수와-익명-함수\" style=\"position:relative;\">코틀린의 람다 함수와 익명 함수<a href=\"#%EC%BD%94%ED%8B%80%EB%A6%B0%EC%9D%98-%EB%9E%8C%EB%8B%A4-%ED%95%A8%EC%88%98%EC%99%80-%EC%9D%B5%EB%AA%85-%ED%95%A8%EC%88%98\" aria-label=\"코틀린의 람다 함수와 익명 함수 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<deckgo-highlight-code  terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">// 코틀린\nclass KotlinFunction {\n    val twiceLambda : (Int) -&gt; Int = { it * 2 }\n    val twiceAnonymousFunction : (Int) -&gt; Int = fun(param: Int) = param * 2\n}\n\nfun main() {\n    val function = KotlinFunction()\n    function.twiceLambda(10)\n    function.twiceAnonymousFunction(10)\n}</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"java\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">// 자바\npublic final class KotlinFunction {\n   @NotNull\n   private final Function1 twiceLambda;\n   @NotNull\n   private final Function1 twiceAnonymousFunction;\n\n   @NotNull\n   public final Function1 getTwiceLambda() {\n      return this.twiceLambda;\n   }\n\n   @NotNull\n   public final Function1 getTwiceAnonymousFunction() {\n      return this.twiceAnonymousFunction;\n   }\n\n   public KotlinFunction() {\n      this.twiceLambda = (Function1)null.INSTANCE;\n      this.twiceAnonymousFunction = (Function1)null.INSTANCE;\n   }\n}\n\npublic static final void main() {\n    KotlinFunction function = new KotlinFunction();\n    function.getTwiceLambda().invoke(10);\n    function.getTwiceAnonymousFunction().invoke(10);\n}</code>\n        </deckgo-highlight-code>\n<p>자바 코드를 확인해보면 <code class=\"language-text\">Function1</code> 타입 내부 필드로 정의되며, 클라이언트 측 코드는 <code class=\"language-text\">invoke()</code>를 통해 실행한다.<br>\n<code class=\"language-text\">Function1</code>타입은 <code class=\"language-text\">Functions.kt</code>에 정의된 PECS규칙을 지키는 <strong>SAM 인터페이스</strong>다.</p>\n<deckgo-highlight-code  terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">public interface Function0&lt;out R&gt; : Function&lt;R&gt; {\n    /** Invokes the function. */\n    public operator fun invoke(): R\n}\n/** A function that takes 1 argument. */\npublic interface Function1&lt;in P1, out R&gt; : Function&lt;R&gt; {\n    /** Invokes the function with the specified argument. */\n    public operator fun invoke(p1: P1): R\n}\n/** A function that takes 2 arguments. */\npublic interface Function2&lt;in P1, in P2, out R&gt; : Function&lt;R&gt; {\n    /** Invokes the function with the specified arguments. */\n    public operator fun invoke(p1: P1, p2: P2): R\n}\n\n...\n\n/** A function that takes 22 arguments. */\npublic interface Function22&lt;in P1, in P2, in P3, in P4, in P5, in P6, in P7, in P8, in P9, in P10, in P11, in P12, in P13, in P14, in P15, in P16, in P17, in P18, in P19, in P20, in P21, in P22, out R&gt; : Function&lt;R&gt; {\n    /** Invokes the function with the specified arguments. */\n    public operator fun invoke(p1: P1, p2: P2, p3: P3, p4: P4, p5: P5, p6: P6, p7: P7, p8: P8, p9: P9, p10: P10, p11: P11, p12: P12, p13: P13, p14: P14, p15: P15, p16: P16, p17: P17, p18: P18, p19: P19, p20: P20, p21: P21, p22: P22): R\n}</code>\n        </deckgo-highlight-code>\n<p>각 <code class=\"language-text\">interface</code>들이 추가로 상속 받고 있는 <code class=\"language-text\">Function&lt;out R></code>은 코틀린 패키지에 정의된 인터페이스다.<br>\n<strong>반환 타입의 공변을 지정하기 위해 선언한 인터페이스 인 것 같다.</strong></p>\n<deckgo-highlight-code  terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">package kotlin\n\n/**\n * Represents a value of a functional type, such as a lambda, an anonymous function or a function reference.\n *\n * @param R return type of the function.\n */\npublic interface Function&lt;out R&gt;</code>\n        </deckgo-highlight-code>\n<p>결국은 아래의 자바 예제와 같이 <strong>코틀린도 자바의 SAM 인터페이스를 미리 정의해놓고 이 인터페이스를 구현하는 익명 함수인 것으로 보인다.</strong></p>\n<deckgo-highlight-code language=\"java\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">@FunctionalInterface\npublic interface Twice {\n    int invoke(int value);\n}\n\npublic static void main(String[] args) {\n    Twice twiceLambda = value -&gt; value * 2;\n    Twice twiceAnonymousFunction = new Twice() {\n        @Override\n        public int invoke(int value) {\n            return value * 2;\n        }\n    };\n\n    twiceLambda.invoke(10);\n    twiceAnonymousFunction.invoke(10);\n}</code>\n        </deckgo-highlight-code>\n<p>그렇다면 일급 시민과 고차 함수가 포함된 클로저를 작성해 확인해보자.</p>\n<h1 id=\"-인자가-22개를-초과하면-어떻게-될까\" style=\"position:relative;\">(+) 인자가 22개를 초과하면 어떻게 될까?<a href=\"#-%EC%9D%B8%EC%9E%90%EA%B0%80-22%EA%B0%9C%EB%A5%BC-%EC%B4%88%EA%B3%BC%ED%95%98%EB%A9%B4-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%90%A0%EA%B9%8C\" aria-label=\" 인자가 22개를 초과하면 어떻게 될까 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>코틀린의 <code class=\"language-text\">Functions.kt</code>에는 22개 인자까지만 명시되어 있었다.<br>\n22개를 초과하면 어떻게 될까?</p>\n<deckgo-highlight-code  terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">val argumentOver : (\n        Int, Int, Int, Int, Int, Int, Int, Int, Int, Int,\n        Int, Int, Int, Int, Int, Int, Int, Int, Int, Int,\n        Int, Int, Int\n    ) -&gt; Int =\n        { i: Int, ... i22: Int -&gt; 1 }</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"java\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">public final class KotlinFunction {\n   @NotNull\n   private final FunctionN argumentOver;\n\n   @NotNull\n   public final FunctionN getArgumentOver() {\n      return this.argumentOver;\n   }\n\n   public KotlinFunction() {\n      this.argumentOver = (FunctionN)null.INSTANCE;\n   }\n}\n\n@kotlin.SinceKotlin \npublic interface FunctionN&lt;out R&gt; : kotlin.Function&lt;R&gt;, kotlin.jvm.internal.FunctionBase&lt;R&gt; {\n    public abstract val arity: kotlin.Int\n\n    public abstract operator fun invoke(vararg args: kotlin.Any?): R\n}</code>\n        </deckgo-highlight-code>\n<p>그냥 인자를 가변 배열로 받는 <code class=\"language-text\">FunctionN</code>을 사용한다.</p>\n<h1 id=\"코틀린의-클로저\" style=\"position:relative;\">코틀린의 클로저<a href=\"#%EC%BD%94%ED%8B%80%EB%A6%B0%EC%9D%98-%ED%81%B4%EB%A1%9C%EC%A0%80\" aria-label=\"코틀린의 클로저 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>이전 입력을 저장하는 (반환 타입 람다 외부의 지역변수를 참조하는) 클로저를 예제로 만들어보자.</p>\n<ul>\n<li><code class=\"language-text\">0이면 기억된 값을 반환</code></li>\n<li><code class=\"language-text\">0이 아니면 기억된 값을 반환하고, 그 값을 저장</code></li>\n</ul>\n<deckgo-highlight-code  terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">// 코틀린\nclass KotlinFunction {\n    fun memoryClosure(param: Int) : (Int) -&gt; Int {\n        var memory = param\n        return { param2 -&gt;\n            when (param2) {\n                0 -&gt; memory\n                else -&gt; {\n                    val tmp = memory\n                    memory = param2\n                    tmp\n                }\n            }\n        }\n    }\n}\n\nfun main() {\n    val closure: (Int) -&gt; Int = KotlinFunction().memoryClosure(10)\n    println(closure(0))\n}</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"java\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">// 자바\npublic final class KotlinFunction {\n   @NotNull\n   public final Function1 memoryClosure(int param) {\n      final Ref.IntRef memory = new Ref.IntRef();\n      memory.element = param;\n      return (Function1)(new Function1() {\n         // $FF: synthetic method\n         // $FF: bridge method\n         public Object invoke(Object var1) {\n            return this.invoke(((Number)var1).intValue());\n         }\n\n         public final int invoke(int param2) {\n            int var10000;\n            switch (param2) {\n               case 0:\n                  var10000 = memory.element;\n                  break;\n               default:\n                  int tmp = memory.element;\n                  memory.element = param2;\n                  var10000 = tmp;\n            }\n\n            return var10000;\n         }\n      });\n   }\n}\n\npublic final class KotlinFunctionKt {\n   public static final void main() {\n      new KotlinFunction();\n      Function1 closure = (new KotlinFunction()).memoryClosure(10);\n      int var2 = ((Number)closure.invoke(0)).intValue();\n      System.out.println(var2);\n   }\n}</code>\n        </deckgo-highlight-code>\n<p>자바 코드로 디컴파일한 <code class=\"language-text\">memoryClosure()</code> 메소드를 보면 람다 외부로 지정된 <code class=\"language-text\">memory</code> 변수 참조를 유지하기 위해 <code class=\"language-text\">Ref</code> 클래스로 선언한 것을 제외하곤 큰 차이점은 없다.<br>\n위의 클로저 함수를 자바로 작성해보자.</p>\n<ul>\n<li><code class=\"language-text\">MemoryClousre</code> 함수형 인터페이스의 구현을 통해 <code class=\"language-text\">ClousreFunction</code>을 반환</li>\n</ul>\n<deckgo-highlight-code language=\"java\" terminal=\"carbon\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">@FunctionalInterface\npublic interface MemoryClosure {\n    ClosureFunction invoke(int value);\n}\n\n@FunctionalInterface\npublic interface ClosureFunction {\n    Integer invoke(Integer value);\n}\n\npublic class Program {\n    public static void main(String[] args) {\n        MemoryClosure closure = new MemoryClosure() {\n            @Override\n            public ClosureFunction invoke(int param) {\n                final Integer[] memory = {param};\n                return new ClosureFunction() {\n                    @Override\n                    public Integer invoke(Integer value2) {\n                        Integer result;\n                        if (value2 == 0) {\n                            result = memory[0];\n                        } else {\n                            Integer tmp = memory[0];\n                            memory[0] = value2;\n                            result = tmp;\n                        }\n                        return result;\n                    }\n                };\n            }\n        };\n\n        ClosureFunction function = closure.invoke(10);\n        System.out.println(function.invoke(0));\n        System.out.println(function.invoke(11));\n        System.out.println(function.invoke(12));\n        // 10\n        // 10\n        // 11\n    }\n}</code>\n        </deckgo-highlight-code>\n<p>위와 같이 자바에서도 코틀린에서 작성한 예제와 같이 똑같은 기능을 할 수 있다.</p>\n<h1 id=\"결론\" style=\"position:relative;\">결론<a href=\"#%EA%B2%B0%EB%A1%A0\" aria-label=\"결론 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>코틀린의 람다 함수, 익명 함수, 클로저 예제들을 디컴파일해보고, 똑같이 (불편하지만) 자바로 작성해보았다.<br>\n<strong>코틀린 컴파일러가 마법같은 일을 해주진 않는 것을 확인했고, 코틀린도 결국 자바의 함수형 인터페이스를 사용하는 것을 확인했다.</strong><br>\n<code class=\"language-text\">자바의 함수 개념과 코틀린의 함수 개념은 완전히 다르다.</code>라는 말은 <strong>고수준 언어 관점에서 나온 이야기 인 것 같다.</strong></p>","frontmatter":{"title":"코틀린의 함수는 어떻게 구현될까?","date":"May 12, 2023","description":null,"tags":["kotlin","function"]},"tableOfContents":"<ul>\n<li><a href=\"#%EC%9D%98%EB%AC%B8\">의문</a></li>\n<li><a href=\"#%EC%BD%94%ED%8B%80%EB%A6%B0%EC%9D%98-%EB%9E%8C%EB%8B%A4-%ED%95%A8%EC%88%98%EC%99%80-%EC%9D%B5%EB%AA%85-%ED%95%A8%EC%88%98\">코틀린의 람다 함수와 익명 함수</a></li>\n<li><a href=\"#-%EC%9D%B8%EC%9E%90%EA%B0%80-22%EA%B0%9C%EB%A5%BC-%EC%B4%88%EA%B3%BC%ED%95%98%EB%A9%B4-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%90%A0%EA%B9%8C\">(+) 인자가 22개를 초과하면 어떻게 될까?</a></li>\n<li><a href=\"#%EC%BD%94%ED%8B%80%EB%A6%B0%EC%9D%98-%ED%81%B4%EB%A1%9C%EC%A0%80\">코틀린의 클로저</a></li>\n<li><a href=\"#%EA%B2%B0%EB%A1%A0\">결론</a></li>\n</ul>"},"previous":{"fields":{"slug":"/2023y/dbIndex/"},"frontmatter":{"title":"타입이 서로 다른 컬럼을 조인한다면?"}},"next":{"fields":{"slug":"/2023y/bookReview/bookReview/"},"frontmatter":{"title":"2023년 책,강의 서평"}}},"pageContext":{"id":"dd24ae62-84db-5f8e-b21c-0dd43c1dcef3","previousPostId":"0ad0f8f7-adf0-51ae-ba82-8d2e202f7ccd","nextPostId":"f3b698c4-c3b9-528f-8e0d-5b72c0a3f2ac"}},"staticQueryHashes":["230163734","3589320610"],"slicesMap":{}}