{"componentChunkName":"component---src-templates-blog-post-js","path":"/2025y/multiplexing/","result":{"data":{"site":{"siteMetadata":{"title":"코딩 주머니"}},"markdownRemark":{"id":"e3d18442-a047-5f12-84d4-4bab1d333bc7","excerpt":"멀티플렉싱 먼저 TCP…","html":"<h1 id=\"멀티플렉싱\" style=\"position:relative;\">멀티플렉싱<a href=\"#%EB%A9%80%ED%8B%B0%ED%94%8C%EB%A0%89%EC%8B%B1\" aria-label=\"멀티플렉싱 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>먼저 TCP 소켓에 대해 이해하자.<br>\n소켓은 네트워크에서 서버와 클라이언트, 두 개의 프로세스가 특정 포트를 통해 양방향 통신이 가능하도록 만들어 주는 추상화된 장치이다.<br>\n<code class=\"language-text\">{srcIP, srcPort, destIP, destPort}</code>로 이루어져 있다.<br>\n(사용하는 입장에서는) 위의 정보가 유일함이 보장된다.<br>\n하지만 실제 구현에서는 조금 다르다. 외부적으로 알릴 IP와 Port로 소켓을 만들고 해당 소켓을 리스닝 소켓으로 등록한다.<br>\n<strong>리스닝 소켓으로 들어오는 클라이언트 연결 요청을 받고 수락한다면 클라이언트와 연결된 새로운 소켓이 생성된다.</strong></p>\n<p><img src=\"https://vos.line-scdn.net/landpress-content-v2_954/1663603039179.png?updatedAt=1663603039000\" alt=\"alter\"></p>\n<p>한 개의 서버에 여러 클라이언트가 접속 요청을 보낸다면 서버는 어떻게 수용할 수 있을까?<br>\n문제를 해결하기 위해 아래의 방법들이 있다.</p>\n<h2 id=\"멀티프로세싱multiprocessing-기반-서버\" style=\"position:relative;\">멀티프로세싱(multiprocessing) 기반 서버<a href=\"#%EB%A9%80%ED%8B%B0%ED%94%84%EB%A1%9C%EC%84%B8%EC%8B%B1multiprocessing-%EA%B8%B0%EB%B0%98-%EC%84%9C%EB%B2%84\" aria-label=\"멀티프로세싱multiprocessing 기반 서버 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><strong>'프로세스를 다수 생성'하는 방식으로 서비스를 제공한다.</strong></p>\n<p><img src=\"https://vos.line-scdn.net/landpress-content-v2_954/1663603730433.png?updatedAt%253D1663603731000\" alt=\"Alt text\"></p>\n<blockquote>\n<p>부모 프로세스는 리스닝 소켓으로 accept 함수를 호출해서 연결 요청을 수락한다.<br>\n이때 얻는 소켓의 파일 디스크립터(클라이언트와 연결된 연결 소켓)를 자식 프로세스를 생성해 넘겨준다.<br>\n자식 프로세스는 전달받은 파일 디스크립터를 바탕으로 서비스를 제공한다.</p>\n</blockquote>\n<p><strong>단점</strong><br>\n클라이언트가 연결하는 만큼 프로세스를 복사하기 때문에 리소스를 많이 사용한다.<br>\n프로세스는 서로 독립적인 메모리 공간을 갖기 때문에 정보 교환이 어렵다.<br>\n이 단점을 멀티스레딩으로 처리하면 해결할 수 있다.</p>\n<h2 id=\"멀티스레딩multithreading-기반-서버\" style=\"position:relative;\">멀티스레딩(multithreading) 기반 서버<a href=\"#%EB%A9%80%ED%8B%B0%EC%8A%A4%EB%A0%88%EB%94%A9multithreading-%EA%B8%B0%EB%B0%98-%EC%84%9C%EB%B2%84\" aria-label=\"멀티스레딩multithreading 기반 서버 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><strong>'스레드를 다수 생성'하는 방식으로 서비스를 제공한다.</strong></p>\n<p><img src=\"https://vos.line-scdn.net/landpress-content-v2_954/1663604015232.png?updatedAt%253D1663604016000\" alt=\"Alt text\"></p>\n<blockquote>\n<p>메인 스레드는 리스닝 소켓으로 accept 함수를 호출해서 연결 요청을 수락한다.<br>\n이때 얻는 소켓의 파일 디스크립터(클라이언트와 연결된 연결 소켓)를 별도 워커 스레드를 생성해 넘겨준다.<br>\n워커 스레드는 전달받은 파일 디스크립터를 바탕으로 서비스를 제공한다.</p>\n</blockquote>\n<p><strong>단점</strong><br>\n한 개의 프로세스 내에 다수의 스레드가 존재하기 때문에 하나의 스레드에서 발생한 문제가 전체에 영향을 미쳐 나머지 다수의 스레드에 영향을 끼칠 수 있다.<br>\n일정 크기의 스레드를 생성해 풀로 관리하며 운영할 수 있지만 클라이언트의 요청마다 스레드를 무한정 생성할 수 없기 때문에 많은 수의 요청을 동시에 처리할 수 없다.<br>\n또한 스레드들이 idle한 시간동안 불필요하게 블로킹되기에 낭비가 많다.</p>\n<p>I/O 멀티플렉싱 기법을 사용한다면 각 클라이언트마다 별도 스레드를 이용하는게 아니라,<br>\n<strong>하나의 스레드에서 다수의 클라이언트에 연결된 소켓(파일 디스크립터)을 관리하면서 소켓에 이벤트 (<code class=\"language-text\">read</code>/<code class=\"language-text\">write</code>)가 발생할 때만 해당 이벤트를 처리하도록 구현해서 더 적은 리소스를 사용하도록 개선할 수 있다.</strong></p>\n<h2 id=\"멀티플렉싱multiplexing-기반-서버\" style=\"position:relative;\">멀티플렉싱(multiplexing) 기반 서버<a href=\"#%EB%A9%80%ED%8B%B0%ED%94%8C%EB%A0%89%EC%8B%B1multiplexing-%EA%B8%B0%EB%B0%98-%EC%84%9C%EB%B2%84\" aria-label=\"멀티플렉싱multiplexing 기반 서버 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><strong>'입출력 대상을 묶어서 관리'하는 방식으로 서비스를 제공한다.</strong></p>\n<p><strong>입출력 다중화</strong>란?<br>\n하나의 프로세스 혹은 스레드에서 입력과 출력을 모두 다룰 수 있는 기술을 말한다.<br>\n커널에서는 하나의 스레드가 여러 개의 소켓을 핸들링 할 수 있는 <code class=\"language-text\">select</code>, <code class=\"language-text\">poll</code>, <code class=\"language-text\">epoll</code>, <code class=\"language-text\">io_uring</code>과 같은 시스템 콜을 제공하고 있다.<br>\n<strong>그럼에도 지금까지 하나의 클라이언트에 대한 입출력만 처리할 수 있었던 이유는, 입출력 함수가 블록되면 입출력 데이터가 준비될 때까지 무한정 블록돼 여러 클라이언트의 입출력을 처리할 수 없었기 때문이다.</strong></p>\n<p><strong>I/O 멀티플렉싱 기법</strong>을 사용하면, 비록 입출력 함수 자체는 여전히 블록하는 것으로 작동하지만, 입출력 함수를 호출하기 전에 어떤 파일에서 입출력이 준비됐는지를 확인할 수 있다.</p>\n<p>블로킹 I/O 에서는 프로세스(스레드)가 하나의 소켓에 대해 <code class=\"language-text\">read</code> 함수를 호출(시스템 콜)을 하면 데이터가 도착할 때 까지 기다린다.<br>\n패킷이 도착하면 커널 내 버퍼에 복사되고, 이 데이터를 사용하기 위해서는 사용자 공간에 다시 복사해야 한다.<br>\n<strong>이 작업들이 끝날 때까지 시스템 콜이 반환되지 않는다.</strong></p>\n<p><img src=\"https://vos.line-scdn.net/landpress-content-v2_954/1663604384989.png?updatedAt%253D1663604385000\" alt=\"Alt text\"></p>\n<p>I/O 멀티플렉싱 시스템 콜들은 여러 파일 디스크립터를 감시하여, 어떤 파일에서 읽기, 쓰기 또는 예외 이벤트가 발생했는지를 확인하는 시스템 콜이다.<br>\n즉, 이벤트(입력, 출력, 에러)가 준비된 파일에 대해 입출력을 수행하기 때문에 <strong>무한정 대기해야하는 블록이 발생하지 않을 것이라는게 보장된다.</strong></p>\n<ol>\n<li><strong>파일 디스크립터 준비</strong>: 감시할 파일 디스크립터를 fd_set이라는 구조체에 등록합니다.</li>\n<li><strong>이벤트 대기</strong>: select 함수를 호출하여 등록된 파일 디스크립터 중 이벤트가 발생할 때까지 대기합니다.</li>\n<li><strong>이벤트 처리</strong>: 이벤트가 발생한 파일 디스크립터에 대해 적절한 입출력 작업을 수행합니다.</li>\n</ol>\n<p>아래는 I/O 멀티플렉싱의 select와 epoll의 주요 차이점을 정리한 마크다운 테이블입니다.</p>\n<table>\n<thead>\n<tr>\n<th>특성</th>\n<th>select</th>\n<th>epoll</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>감시 대상 등록</strong></td>\n<td>매 호출 시마다 전체 FD 집합 전달</td>\n<td>한 번 등록 후 커널 내에서 유지</td>\n</tr>\n<tr>\n<td><strong>이벤트 감지 방식</strong></td>\n<td>전체 파일 디스크립터 순회 검사</td>\n<td>이벤트 발생한 FD만 알림</td>\n</tr>\n<tr>\n<td><strong>최대 파일 디스크립터 수</strong></td>\n<td>일반적으로 1024개 제한</td>\n<td>사실상 제한 없음</td>\n</tr>\n<tr>\n<td><strong>CPU 및 메모리 오버헤드</strong></td>\n<td>매 호출마다 FD 집합 복사 및 전체 검사 발생</td>\n<td>변화 있는 FD만 처리, 복사 및 검사 비용 매우 적음</td>\n</tr>\n<tr>\n<td><strong>지원 운영체제</strong></td>\n<td>대부분 OS 지원</td>\n<td>리눅스 커널 2.6 이상</td>\n</tr>\n<tr>\n<td><strong>성능 및 확장성</strong></td>\n<td>제한적, 대규모 연결에 비효율적</td>\n<td>대규모 연결 처리에 매우 효율적</td>\n</tr>\n<tr>\n<td><strong>API 복잡도</strong></td>\n<td>단순</td>\n<td>상대적으로 복잡</td>\n</tr>\n</tbody>\n</table>\n<p>요약하면, <code class=\"language-text\">epoll</code>은 대규모 소켓 처리와 높은 효율성이 요구되는 리눅스 환경에서 <code class=\"language-text\">select</code> 대비 월등한 성능과 확장성을 제공하도록 설계된 시스템 호출이다.<br>\n반면, select는 낮은 이식성과 확장성 문제로 인해 소규모 혹은 범용 환경에서만 주로 사용된다.</p>\n<p>Java NIO가 시스템 수준의 I/O 멀티플렉싱 기술(특히 select, poll, epoll 등)을 추상화하여 자바 개발자가 쉽게 비동기 입출력을 구현할 수 있게 해준다</p>\n<h1 id=\"java-nio\" style=\"position:relative;\">Java NIO<a href=\"#java-nio\" aria-label=\"java nio permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<h2 id=\"채널과-버퍼\" style=\"position:relative;\">채널과 버퍼<a href=\"#%EC%B1%84%EB%84%90%EA%B3%BC-%EB%B2%84%ED%8D%BC\" aria-label=\"채널과 버퍼 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<ul>\n<li>kernel 버퍼를 직접 핸들링 할 수 없어 복사 오버헤드가 존재했지만, ByteBuffer가 등장하면서 개선됐다. (zero copy)</li>\n<li>FileChannel, DatagramChaneel, SocketChannel, ServerSocketChannel</li>\n<li>채널은 양방향으로 사용하기 때문에 버퍼에 데이터를 쓰다가 이후 데이터를 읽어야 한다면 <code class=\"language-text\">filp()</code>을 호출해서 버퍼를 쓰기 모드에서 읽기 모드로 전환해야 한다.</li>\n<li><code class=\"language-text\">clear()</code>로 전체 버퍼를 지울 수 있다.</li>\n</ul>\n<h2 id=\"논블로킹non-blocking-io\" style=\"position:relative;\">논블로킹(non-blocking) I/O<a href=\"#%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9non-blocking-io\" aria-label=\"논블로킹non blocking io permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<ul>\n<li>Java NIO에서는 논블로킹 I/O를 사용할 수 있다.</li>\n<li>예를 들어, 스레드가 버퍼로 데이터를 읽어달라고 채널에 요청하면, 채널이 버퍼에 데이터를 채워 넣는 동안 해당 스레드는 다른 작업을 수행할 수 있다.</li>\n<li>이후 채널이 버퍼에 데이터를 채워 넣고 나면 스레드는 해당 버퍼를 이용해 계속 처리를 진행할 수 있다.</li>\n<li>반대로 데이터를 채널로 보내는 경우에도 논블로킹으로 처리할 수 있다.</li>\n</ul>\n<h2 id=\"셀렉터\" style=\"position:relative;\">셀렉터<a href=\"#%EC%85%80%EB%A0%89%ED%84%B0\" aria-label=\"셀렉터 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<ul>\n<li>Java NIO에는 여러 개의 채널에서 이벤트(예: 연결 생성, 데이터 도착 등)를 모니터링할 수 있는 셀렉터가 포함돼 있기 때문에 하나의 스레드로 여러 채널을 모니터링할 수 있다.</li>\n<li>내부적으로 SelectorProvider에서 운영체제와 버전에 따라 사용 가능한 <strong>멀티플렉싱 기술을 선택해 사용한다</strong>.</li>\n<li><strong>하나 이상의 채널을 셀렉터에 등록하고 <code class=\"language-text\">select()</code>를 호출하면, 등록된 채널 중 이벤트 준비가 완료된 하나 이상의 채널이 생길 때까지 블록된다.</strong></li>\n</ul>\n<p>Java NIO에는 이 외에도 더 많은 클래스와 컴포넌트가 있지만 <strong>채널</strong>과 <strong>버퍼</strong>, <strong>셀렉터</strong>가 API의 핵심이다.</p>\n<deckgo-highlight-code language=\"java\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">ServerSocketChannel channel = ServerSocketChannel.open();\nchannel.bind(new InetSocketAddress(&quot;localhost&quot;, 8080));\nchannel.configureBlocking(false); // 논블로킹 모드로 변경\n\nSelector selector = Selector.open();\n\n// 하나의 Selector는 여러 Channel을 관리할 수 있습니다\n// 각 Channel마다 독립적으로 관심 이벤트(interest ops)를 설정합니다\n// 이 코드는 해당 channel에 대해 OP_READ만 등록한 것입니다\nSelectionKey key = channel.register(selector, SelectionKey.OP_READ); // 채널을 셀렉터에 등록</code>\n        </deckgo-highlight-code>\n<p>ServerSocketChannel을 열고 Channel에 IP와 Port를 바인딩한다.<br>\nSelector에 Channel을 등록하고, 준비된 채널의 집합을 받는다.</p>\n<blockquote>\n<p><strong>ServerSocketChannel</strong></p>\n<ul>\n<li>역할: 클라이언트의 연결 요청을 **듣고(listen) 수락(accept)**하는 채널</li>\n<li>생성: 한 번만 생성 (서버당 포트당 1개)</li>\n<li>이벤트: OP_ACCEPT (연결 요청 감지)</li>\n</ul>\n<p><strong>SocketChannel</strong></p>\n<ul>\n<li>역할: 실제 클라이언트와 데이터를 주고받는 채널</li>\n<li>생성: 클라이언트마다 생성 (클라이언트 수만큼)</li>\n<li>이벤트: OP_READ, OP_WRITE (데이터 읽기/쓰기)</li>\n</ul>\n<p><strong>SelectionKey</strong></p>\n<ul>\n<li>역할: Channel과 Selector의 연결 관계 표현, 관심 이벤트 관리, 핸들러 저장</li>\n<li>생성: Channel을 Selector에 등록하는 경우 반환</li>\n</ul>\n</blockquote>\n<deckgo-highlight-code language=\"java\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();\nIterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();\n \nwhile(keyIterator.hasNext()) {\n     \n    SelectionKey key = keyIterator.next();\n \n    if(key.isAcceptable()) {\n        // a connection was accepted by a ServerSocketChannel.\n    } else if (key.isConnectable()) {\n        // a connection was established with a remote server.\n    } else if (key.isReadable()) {\n        // a channel is ready for reading\n    } else if (key.isWritable()) {\n        // a channel is ready for writing\n    }\n \n    keyIterator.remove();\n}</code>\n        </deckgo-highlight-code>\n<p>key의 상태에 따라 분기된다.</p>\n<h1 id=\"reactor-패턴-이벤트-핸들링-패턴\" style=\"position:relative;\">Reactor 패턴 (이벤트 핸들링 패턴)<a href=\"#reactor-%ED%8C%A8%ED%84%B4-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%ED%95%B8%EB%93%A4%EB%A7%81-%ED%8C%A8%ED%84%B4\" aria-label=\"reactor 패턴 이벤트 핸들링 패턴 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p><a href=\"https://github.com/jdalma/footprints/blob/main/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/%ED%96%89%EB%8F%99_%EA%B4%80%EB%A0%A8.md#observer-pattern\">Observer 패턴 참고</a></p>\n<blockquote>\n<p>Reactor: 무한 반복문을 실행해 이벤트가 발생할 때까지 대기하다가 이벤트가 발생하면 처리할 수 있는 핸들러에게 디스패치합니다. 이벤트 루프라고도 부릅니다.<br>\n핸들러: 이벤트를 받아 필요한 비즈니스 로직을 수행합니다.<br>\n세부적인 구현은 상황에 맞게 변경할 수 있습니다.<br>\n따라서 세부 구현 내용에 초점을 맞추기보다는 리소스에서 발생한 이벤트를 처리하기까지의 과정과, 그 과정에서 Reactor와 핸들러가 어떤 역할을 하는지 이해하는 것이 Reactor 패턴을 이해하는 데 더 많은 도움이 됩니다.</p>\n<ul>\n<li><a href=\"https://github.com/jdalma/reactor/tree/main/src/main/java/org/example\">예제</a></li>\n</ul>\n</blockquote>\n<deckgo-highlight-code language=\"java\" terminal=\"carbon\" theme=\"one-light\" line-numbers=\"true\"  >\n          <code slot=\"code\">@Override\npublic void run() {\n    try {\n        while (true) {\n            selector.select();\n            Set&lt;SelectionKey&gt; selected = selector.selectedKeys();\n            for (SelectionKey selectionKey : selected) {\n                dispatch(selectionKey);\n            }\n            selected.clear();\n        }\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}</code>\n        </deckgo-highlight-code>\n<h1 id=\"eventloop\" style=\"position:relative;\">EventLoop<a href=\"#eventloop\" aria-label=\"eventloop permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<blockquote>\n<p>이벤트 루프(event loop)는 동시성(concurrency)을 제공하기 위한 프로그래밍 모델 중 하나로,<br>\n특정 이벤트가 발생할 때까지 대기하다가 이벤트가 발생하면 디스패치해 처리하는 방식으로 작동합니다.</p>\n</blockquote>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 560px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/f35be33cdc63b3fca328dcd390bb4ba7/ac282/netty_eventloop.webp\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 96.88888888888889%; position: relative; bottom: 0; left: 0; background-image: url('data:image/webp;base64,UklGRlgAAABXRUJQVlA4IEwAAACQAwCdASoUABMAPtFgqE+oJSOiKAgBABoJaQAAPS/0oEGI3aQAAP7xiTh7btuqZqeuzFag3O4IUVk45CoKOyVYhTlUztxE2KUCgAAA'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"netty eventloop\"\n        title=\"\"\n        src=\"/static/f35be33cdc63b3fca328dcd390bb4ba7/ac282/netty_eventloop.webp\"\n        srcset=\"/static/f35be33cdc63b3fca328dcd390bb4ba7/d7e55/netty_eventloop.webp 225w,\n/static/f35be33cdc63b3fca328dcd390bb4ba7/8626f/netty_eventloop.webp 450w,\n/static/f35be33cdc63b3fca328dcd390bb4ba7/ac282/netty_eventloop.webp 560w\"\n        sizes=\"(max-width: 560px) 100vw, 560px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>\n<em>출처: <a href=\"https://mark-kim.blog/netty_deepdive_1/\">Netty Deep Dive</a></em></p>\n<p><strong>내부적으로 <code class=\"language-text\">Selector</code>를 이용해 특정 이벤트가 발생할 때까지 대기하다가 이벤트가 발생하면 적절한 핸들러로 이벤트를 전달(dispatch)해 처리하는 역할을 무한 루프로 실행해 반복하던 Reactor가 바로 이벤트 루프이다.</strong></p>\n<ol>\n<li>이벤트가 발생하기를 대기한다.</li>\n<li>이벤트가 발생하면 처리할 수 있는 핸들러에 이벤트를 디스패치한다.</li>\n<li>핸들러에서 이벤트를 처리한다.</li>\n<li>다시 1~3 단계를 반복한다.</li>\n</ol>\n<hr>\n<blockquote>\n<p><strong>참고</strong></p>\n<ol>\n<li><a href=\"https://engineering.linecorp.com/ko/blog/do-not-block-the-event-loop-part1\">이벤트 루프를 블록하면 안되는 이유 - 파트1</a></li>\n<li><a href=\"https://engineering.linecorp.com/ko/blog/do-not-block-the-event-loop-part2\">이벤트 루프를 블록하면 안되는 이유 - 파트2</a></li>\n<li><a href=\"https://mark-kim.blog/understanding-non-blocking-io-and-nio/\">사례를 통해 이해하는 네트워크 논블로킹 I/O와 Java NIO</a></li>\n<li><a href=\"https://mark-kim.blog/netty_deepdive_1/\">Netty Deep Dive</a></li>\n<li><a href=\"https://github.com/jdalma/footprints/blob/main/Netty/%EB%84%A4%ED%8B%B0%EC%9D%98%20%ED%95%B5%EC%8B%AC%20%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8.md\">Netty의 핵심 컴포넌트</a></li>\n<li><a href=\"https://github.com/jdalma/footprints/blob/main/Netty/ChannelHandler%EC%99%80%20ChannelPipeline.md\">ChannelHandler와 ChannelPipeline</a></li>\n</ol>\n</blockquote>","frontmatter":{"title":"I/O 멀티플렉싱에 대해","date":"2025-09-02","update":"2025-10-24","description":null,"tags":["multiplexing","nio","deep-dive"]},"tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EB%A9%80%ED%8B%B0%ED%94%8C%EB%A0%89%EC%8B%B1\">멀티플렉싱</a></p>\n<ul>\n<li><a href=\"#%EB%A9%80%ED%8B%B0%ED%94%84%EB%A1%9C%EC%84%B8%EC%8B%B1multiprocessing-%EA%B8%B0%EB%B0%98-%EC%84%9C%EB%B2%84\">멀티프로세싱(multiprocessing) 기반 서버</a></li>\n<li><a href=\"#%EB%A9%80%ED%8B%B0%EC%8A%A4%EB%A0%88%EB%94%A9multithreading-%EA%B8%B0%EB%B0%98-%EC%84%9C%EB%B2%84\">멀티스레딩(multithreading) 기반 서버</a></li>\n<li><a href=\"#%EB%A9%80%ED%8B%B0%ED%94%8C%EB%A0%89%EC%8B%B1multiplexing-%EA%B8%B0%EB%B0%98-%EC%84%9C%EB%B2%84\">멀티플렉싱(multiplexing) 기반 서버</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#java-nio\">Java NIO</a></p>\n<ul>\n<li><a href=\"#%EC%B1%84%EB%84%90%EA%B3%BC-%EB%B2%84%ED%8D%BC\">채널과 버퍼</a></li>\n<li><a href=\"#%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9non-blocking-io\">논블로킹(non-blocking) I/O</a></li>\n<li><a href=\"#%EC%85%80%EB%A0%89%ED%84%B0\">셀렉터</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#reactor-%ED%8C%A8%ED%84%B4-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%ED%95%B8%EB%93%A4%EB%A7%81-%ED%8C%A8%ED%84%B4\">Reactor 패턴 (이벤트 핸들링 패턴)</a></p>\n</li>\n<li>\n<p><a href=\"#eventloop\">EventLoop</a></p>\n</li>\n</ul>"},"previous":{"fields":{"slug":"/2025y/graphql/"},"frontmatter":{"title":"GraphQL 이해하고 사용하기"}},"next":{"fields":{"slug":"/2025y/coroutinescope/"},"frontmatter":{"title":"API가 왜 멈췄을까? 코루틴 이해하기"}}},"pageContext":{"id":"e3d18442-a047-5f12-84d4-4bab1d333bc7","previousPostId":"003a0373-05e2-5137-a60a-e2d20bc60346","nextPostId":"44185076-e856-5646-974d-b8c8a058bc63"}},"staticQueryHashes":["230163734","3589320610"],"slicesMap":{}}